( () => {
    var a1 = Object.defineProperty
      , Vh = Object.getOwnPropertySymbols
      , o1 = Object.prototype.hasOwnProperty
      , c1 = Object.prototype.propertyIsEnumerable
      , Wh = (i, e, t) => e in i ? a1(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , l1 = (i, e) => {
        for (var t in e || (e = {}))
            o1.call(e, t) && Wh(i, t, e[t]);
        if (Vh)
            for (var t of Vh(e))
                c1.call(e, t) && Wh(i, t, e[t]);
        return i
    }
      , h1 = Object.defineProperty
      , u1 = Object.defineProperties
      , d1 = Object.getOwnPropertyDescriptors
      , Yh = Object.getOwnPropertySymbols
      , f1 = Object.prototype.hasOwnProperty
      , p1 = Object.prototype.propertyIsEnumerable
      , $h = (i, e, t) => e in i ? h1(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Kh = (i, e) => {
        for (var t in e || (e = {}))
            f1.call(e, t) && $h(i, t, e[t]);
        if (Yh)
            for (var t of Yh(e))
                p1.call(e, t) && $h(i, t, e[t]);
        return i
    }
      , b1 = (i, e) => u1(i, d1(e))
      , B = (i => (i.Application = "application",
    i.WebGLPipes = "webgl-pipes",
    i.WebGLPipesAdaptor = "webgl-pipes-adaptor",
    i.WebGLSystem = "webgl-system",
    i.WebGPUPipes = "webgpu-pipes",
    i.WebGPUPipesAdaptor = "webgpu-pipes-adaptor",
    i.WebGPUSystem = "webgpu-system",
    i.CanvasSystem = "canvas-system",
    i.CanvasPipesAdaptor = "canvas-pipes-adaptor",
    i.CanvasPipes = "canvas-pipes",
    i.Asset = "asset",
    i.LoadParser = "load-parser",
    i.ResolveParser = "resolve-parser",
    i.CacheParser = "cache-parser",
    i.DetectionParser = "detection-parser",
    i.MaskEffect = "mask-effect",
    i.BlendMode = "blend-mode",
    i.TextureSource = "texture-source",
    i.Environment = "environment",
    i.ShapeBuilder = "shape-builder",
    i.Batcher = "batcher",
    i))(B || {})
      , Pc = i => {
        if (typeof i == "function" || typeof i == "object" && i.extension) {
            let e = typeof i.extension != "object" ? {
                type: i.extension
            } : i.extension;
            i = b1(Kh({}, e), {
                ref: i
            })
        }
        if (typeof i == "object")
            i = Kh({}, i);
        else
            throw new Error("Invalid extension type");
        return typeof i.type == "string" && (i.type = [i.type]),
        i
    }
      , Us = (i, e) => {
        var t;
        return (t = Pc(i).priority) != null ? t : e
    }
      , be = {
        _addHandlers: {},
        _removeHandlers: {},
        _queue: {},
        remove(...i) {
            return i.map(Pc).forEach(e => {
                e.type.forEach(t => {
                    var r, s;
                    return (s = (r = this._removeHandlers)[t]) == null ? void 0 : s.call(r, e)
                }
                )
            }
            ),
            this
        },
        add(...i) {
            return i.map(Pc).forEach(e => {
                e.type.forEach(t => {
                    var r, s;
                    let n = this._addHandlers
                      , a = this._queue;
                    n[t] ? (s = n[t]) == null || s.call(n, e) : (a[t] = a[t] || [],
                    (r = a[t]) == null || r.push(e))
                }
                )
            }
            ),
            this
        },
        handle(i, e, t) {
            var r;
            let s = this._addHandlers
              , n = this._removeHandlers;
            s[i] = e,
            n[i] = t;
            let a = this._queue;
            return a[i] && ((r = a[i]) == null || r.forEach(c => e(c)),
            delete a[i]),
            this
        },
        handleByMap(i, e) {
            return this.handle(i, t => {
                t.name && (e[t.name] = t.ref)
            }
            , t => {
                t.name && delete e[t.name]
            }
            )
        },
        handleByNamedList(i, e, t=-1) {
            return this.handle(i, r => {
                e.findIndex(s => s.name === r.name) >= 0 || (e.push({
                    name: r.name,
                    value: r.ref
                }),
                e.sort( (s, n) => Us(n.value, t) - Us(s.value, t)))
            }
            , r => {
                let s = e.findIndex(n => n.name === r.name);
                s !== -1 && e.splice(s, 1)
            }
            )
        },
        handleByList(i, e, t=-1) {
            return this.handle(i, r => {
                e.includes(r.ref) || (e.push(r.ref),
                e.sort( (s, n) => Us(n, t) - Us(s, t)))
            }
            , r => {
                let s = e.indexOf(r.ref);
                s !== -1 && e.splice(s, 1)
            }
            )
        },
        mixin(i, ...e) {
            for (let t of e)
                Object.defineProperties(i.prototype, Object.getOwnPropertyDescriptors(t))
        }
    };
    function Lb(i) {
        return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
    }
    var Th = {
        exports: {}
    }
      , vw = Th.exports;
    (function(i) {
        "use strict";
        var e = Object.prototype.hasOwnProperty
          , t = "~";
        function r() {}
        Object.create && (r.prototype = Object.create(null),
        new r().__proto__ || (t = !1));
        function s(l, u, d) {
            this.fn = l,
            this.context = u,
            this.once = d || !1
        }
        function n(l, u, d, f, b) {
            if (typeof d != "function")
                throw new TypeError("The listener must be a function");
            var m = new s(d,f || l,b)
              , x = t ? t + u : u;
            return l._events[x] ? l._events[x].fn ? l._events[x] = [l._events[x], m] : l._events[x].push(m) : (l._events[x] = m,
            l._eventsCount++),
            l
        }
        function a(l, u) {
            --l._eventsCount === 0 ? l._events = new r : delete l._events[u]
        }
        function c() {
            this._events = new r,
            this._eventsCount = 0
        }
        c.prototype.eventNames = function() {
            var l = [], u, d;
            if (this._eventsCount === 0)
                return l;
            for (d in u = this._events)
                e.call(u, d) && l.push(t ? d.slice(1) : d);
            return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(u)) : l
        }
        ,
        c.prototype.listeners = function(l) {
            var u = t ? t + l : l
              , d = this._events[u];
            if (!d)
                return [];
            if (d.fn)
                return [d.fn];
            for (var f = 0, b = d.length, m = new Array(b); f < b; f++)
                m[f] = d[f].fn;
            return m
        }
        ,
        c.prototype.listenerCount = function(l) {
            var u = t ? t + l : l
              , d = this._events[u];
            return d ? d.fn ? 1 : d.length : 0
        }
        ,
        c.prototype.emit = function(l, u, d, f, b, m) {
            var x = t ? t + l : l;
            if (!this._events[x])
                return !1;
            var y = this._events[x], S = arguments.length, A, E;
            if (y.fn) {
                switch (y.once && this.removeListener(l, y.fn, void 0, !0),
                S) {
                case 1:
                    return y.fn.call(y.context),
                    !0;
                case 2:
                    return y.fn.call(y.context, u),
                    !0;
                case 3:
                    return y.fn.call(y.context, u, d),
                    !0;
                case 4:
                    return y.fn.call(y.context, u, d, f),
                    !0;
                case 5:
                    return y.fn.call(y.context, u, d, f, b),
                    !0;
                case 6:
                    return y.fn.call(y.context, u, d, f, b, m),
                    !0
                }
                for (E = 1,
                A = new Array(S - 1); E < S; E++)
                    A[E - 1] = arguments[E];
                y.fn.apply(y.context, A)
            } else {
                var O = y.length, M;
                for (E = 0; E < O; E++)
                    switch (y[E].once && this.removeListener(l, y[E].fn, void 0, !0),
                    S) {
                    case 1:
                        y[E].fn.call(y[E].context);
                        break;
                    case 2:
                        y[E].fn.call(y[E].context, u);
                        break;
                    case 3:
                        y[E].fn.call(y[E].context, u, d);
                        break;
                    case 4:
                        y[E].fn.call(y[E].context, u, d, f);
                        break;
                    default:
                        if (!A)
                            for (M = 1,
                            A = new Array(S - 1); M < S; M++)
                                A[M - 1] = arguments[M];
                        y[E].fn.apply(y[E].context, A)
                    }
            }
            return !0
        }
        ,
        c.prototype.on = function(l, u, d) {
            return n(this, l, u, d, !1)
        }
        ,
        c.prototype.once = function(l, u, d) {
            return n(this, l, u, d, !0)
        }
        ,
        c.prototype.removeListener = function(l, u, d, f) {
            var b = t ? t + l : l;
            if (!this._events[b])
                return this;
            if (!u)
                return a(this, b),
                this;
            var m = this._events[b];
            if (m.fn)
                m.fn === u && (!f || m.once) && (!d || m.context === d) && a(this, b);
            else {
                for (var x = 0, y = [], S = m.length; x < S; x++)
                    (m[x].fn !== u || f && !m[x].once || d && m[x].context !== d) && y.push(m[x]);
                y.length ? this._events[b] = y.length === 1 ? y[0] : y : a(this, b)
            }
            return this
        }
        ,
        c.prototype.removeAllListeners = function(l) {
            var u;
            return l ? (u = t ? t + l : l,
            this._events[u] && a(this, u)) : (this._events = new r,
            this._eventsCount = 0),
            this
        }
        ,
        c.prototype.off = c.prototype.removeListener,
        c.prototype.addListener = c.prototype.on,
        c.prefixed = t,
        c.EventEmitter = c,
        i.exports = c
    }
    )(Th);
    var m1 = Th.exports
      , Ft = Lb(m1)
      , g1 = {
        grad: .9,
        turn: 360,
        rad: 360 / (2 * Math.PI)
    }
      , ui = function(i) {
        return typeof i == "string" ? i.length > 0 : typeof i == "number"
    }
      , st = function(i, e, t) {
        return e === void 0 && (e = 0),
        t === void 0 && (t = Math.pow(10, e)),
        Math.round(t * i) / t + 0
    }
      , Ut = function(i, e, t) {
        return e === void 0 && (e = 0),
        t === void 0 && (t = 1),
        i > t ? t : i > e ? i : e
    }
      , Nb = function(i) {
        return (i = isFinite(i) ? i % 360 : 0) > 0 ? i : i + 360
    }
      , qh = function(i) {
        return {
            r: Ut(i.r, 0, 255),
            g: Ut(i.g, 0, 255),
            b: Ut(i.b, 0, 255),
            a: Ut(i.a)
        }
    }
      , Ao = function(i) {
        return {
            r: st(i.r),
            g: st(i.g),
            b: st(i.b),
            a: st(i.a, 3)
        }
    }
      , _1 = /^#([0-9a-f]{3,8})$/i
      , Ls = function(i) {
        var e = i.toString(16);
        return e.length < 2 ? "0" + e : e
    }
      , Xb = function(i) {
        var e = i.r
          , t = i.g
          , r = i.b
          , s = i.a
          , n = Math.max(e, t, r)
          , a = n - Math.min(e, t, r)
          , c = a ? n === e ? (t - r) / a : n === t ? 2 + (r - e) / a : 4 + (e - t) / a : 0;
        return {
            h: 60 * (c < 0 ? c + 6 : c),
            s: n ? a / n * 100 : 0,
            v: n / 255 * 100,
            a: s
        }
    }
      , jb = function(i) {
        var e = i.h
          , t = i.s
          , r = i.v
          , s = i.a;
        e = e / 360 * 6,
        t /= 100,
        r /= 100;
        var n = Math.floor(e)
          , a = r * (1 - t)
          , c = r * (1 - (e - n) * t)
          , l = r * (1 - (1 - e + n) * t)
          , u = n % 6;
        return {
            r: 255 * [r, c, a, a, l, r][u],
            g: 255 * [l, r, r, c, a, a][u],
            b: 255 * [a, a, l, r, r, c][u],
            a: s
        }
    }
      , Zh = function(i) {
        return {
            h: Nb(i.h),
            s: Ut(i.s, 0, 100),
            l: Ut(i.l, 0, 100),
            a: Ut(i.a)
        }
    }
      , Qh = function(i) {
        return {
            h: st(i.h),
            s: st(i.s),
            l: st(i.l),
            a: st(i.a, 3)
        }
    }
      , Jh = function(i) {
        return jb((t = (e = i).s,
        {
            h: e.h,
            s: (t *= ((r = e.l) < 50 ? r : 100 - r) / 100) > 0 ? 2 * t / (r + t) * 100 : 0,
            v: r + t,
            a: e.a
        }));
        var e, t, r
    }
      , es = function(i) {
        return {
            h: (e = Xb(i)).h,
            s: (s = (200 - (t = e.s)) * (r = e.v) / 100) > 0 && s < 200 ? t * r / 100 / (s <= 100 ? s : 200 - s) * 100 : 0,
            l: s / 2,
            a: e.a
        };
        var e, t, r, s
    }
      , x1 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
      , y1 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
      , v1 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
      , T1 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
      , Rc = {
        string: [[function(i) {
            var e = _1.exec(i);
            return e ? (i = e[1]).length <= 4 ? {
                r: parseInt(i[0] + i[0], 16),
                g: parseInt(i[1] + i[1], 16),
                b: parseInt(i[2] + i[2], 16),
                a: i.length === 4 ? st(parseInt(i[3] + i[3], 16) / 255, 2) : 1
            } : i.length === 6 || i.length === 8 ? {
                r: parseInt(i.substr(0, 2), 16),
                g: parseInt(i.substr(2, 2), 16),
                b: parseInt(i.substr(4, 2), 16),
                a: i.length === 8 ? st(parseInt(i.substr(6, 2), 16) / 255, 2) : 1
            } : null : null
        }
        , "hex"], [function(i) {
            var e = v1.exec(i) || T1.exec(i);
            return e ? e[2] !== e[4] || e[4] !== e[6] ? null : qh({
                r: Number(e[1]) / (e[2] ? 100 / 255 : 1),
                g: Number(e[3]) / (e[4] ? 100 / 255 : 1),
                b: Number(e[5]) / (e[6] ? 100 / 255 : 1),
                a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1)
            }) : null
        }
        , "rgb"], [function(i) {
            var e = x1.exec(i) || y1.exec(i);
            if (!e)
                return null;
            var t, r, s = Zh({
                h: (t = e[1],
                r = e[2],
                r === void 0 && (r = "deg"),
                Number(t) * (g1[r] || 1)),
                s: Number(e[3]),
                l: Number(e[4]),
                a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1)
            });
            return Jh(s)
        }
        , "hsl"]],
        object: [[function(i) {
            var e = i.r
              , t = i.g
              , r = i.b
              , s = i.a
              , n = s === void 0 ? 1 : s;
            return ui(e) && ui(t) && ui(r) ? qh({
                r: Number(e),
                g: Number(t),
                b: Number(r),
                a: Number(n)
            }) : null
        }
        , "rgb"], [function(i) {
            var e = i.h
              , t = i.s
              , r = i.l
              , s = i.a
              , n = s === void 0 ? 1 : s;
            if (!ui(e) || !ui(t) || !ui(r))
                return null;
            var a = Zh({
                h: Number(e),
                s: Number(t),
                l: Number(r),
                a: Number(n)
            });
            return Jh(a)
        }
        , "hsl"], [function(i) {
            var e = i.h
              , t = i.s
              , r = i.v
              , s = i.a
              , n = s === void 0 ? 1 : s;
            if (!ui(e) || !ui(t) || !ui(r))
                return null;
            var a = (function(c) {
                return {
                    h: Nb(c.h),
                    s: Ut(c.s, 0, 100),
                    v: Ut(c.v, 0, 100),
                    a: Ut(c.a)
                }
            }
            )({
                h: Number(e),
                s: Number(t),
                v: Number(r),
                a: Number(n)
            });
            return jb(a)
        }
        , "hsv"]]
    }
      , eu = function(i, e) {
        for (var t = 0; t < e.length; t++) {
            var r = e[t][0](i);
            if (r)
                return [r, e[t][1]]
        }
        return [null, void 0]
    }
      , S1 = function(i) {
        return typeof i == "string" ? eu(i.trim(), Rc.string) : typeof i == "object" && i !== null ? eu(i, Rc.object) : [null, void 0]
    };
    var Eo = function(i, e) {
        var t = es(i);
        return {
            h: t.h,
            s: Ut(t.s + 100 * e, 0, 100),
            l: t.l,
            a: t.a
        }
    }
      , Po = function(i) {
        return (299 * i.r + 587 * i.g + 114 * i.b) / 1e3 / 255
    }
      , tu = function(i, e) {
        var t = es(i);
        return {
            h: t.h,
            s: t.s,
            l: Ut(t.l + 100 * e, 0, 100),
            a: t.a
        }
    }
      , Mc = (function() {
        function i(e) {
            this.parsed = S1(e)[0],
            this.rgba = this.parsed || {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            }
        }
        return i.prototype.isValid = function() {
            return this.parsed !== null
        }
        ,
        i.prototype.brightness = function() {
            return st(Po(this.rgba), 2)
        }
        ,
        i.prototype.isDark = function() {
            return Po(this.rgba) < .5
        }
        ,
        i.prototype.isLight = function() {
            return Po(this.rgba) >= .5
        }
        ,
        i.prototype.toHex = function() {
            return e = Ao(this.rgba),
            t = e.r,
            r = e.g,
            s = e.b,
            a = (n = e.a) < 1 ? Ls(st(255 * n)) : "",
            "#" + Ls(t) + Ls(r) + Ls(s) + a;
            var e, t, r, s, n, a
        }
        ,
        i.prototype.toRgb = function() {
            return Ao(this.rgba)
        }
        ,
        i.prototype.toRgbString = function() {
            return e = Ao(this.rgba),
            t = e.r,
            r = e.g,
            s = e.b,
            (n = e.a) < 1 ? "rgba(" + t + ", " + r + ", " + s + ", " + n + ")" : "rgb(" + t + ", " + r + ", " + s + ")";
            var e, t, r, s, n
        }
        ,
        i.prototype.toHsl = function() {
            return Qh(es(this.rgba))
        }
        ,
        i.prototype.toHslString = function() {
            return e = Qh(es(this.rgba)),
            t = e.h,
            r = e.s,
            s = e.l,
            (n = e.a) < 1 ? "hsla(" + t + ", " + r + "%, " + s + "%, " + n + ")" : "hsl(" + t + ", " + r + "%, " + s + "%)";
            var e, t, r, s, n
        }
        ,
        i.prototype.toHsv = function() {
            return e = Xb(this.rgba),
            {
                h: st(e.h),
                s: st(e.s),
                v: st(e.v),
                a: st(e.a, 3)
            };
            var e
        }
        ,
        i.prototype.invert = function() {
            return ni({
                r: 255 - (e = this.rgba).r,
                g: 255 - e.g,
                b: 255 - e.b,
                a: e.a
            });
            var e
        }
        ,
        i.prototype.saturate = function(e) {
            return e === void 0 && (e = .1),
            ni(Eo(this.rgba, e))
        }
        ,
        i.prototype.desaturate = function(e) {
            return e === void 0 && (e = .1),
            ni(Eo(this.rgba, -e))
        }
        ,
        i.prototype.grayscale = function() {
            return ni(Eo(this.rgba, -1))
        }
        ,
        i.prototype.lighten = function(e) {
            return e === void 0 && (e = .1),
            ni(tu(this.rgba, e))
        }
        ,
        i.prototype.darken = function(e) {
            return e === void 0 && (e = .1),
            ni(tu(this.rgba, -e))
        }
        ,
        i.prototype.rotate = function(e) {
            return e === void 0 && (e = 15),
            this.hue(this.hue() + e)
        }
        ,
        i.prototype.alpha = function(e) {
            return typeof e == "number" ? ni({
                r: (t = this.rgba).r,
                g: t.g,
                b: t.b,
                a: e
            }) : st(this.rgba.a, 3);
            var t
        }
        ,
        i.prototype.hue = function(e) {
            var t = es(this.rgba);
            return typeof e == "number" ? ni({
                h: e,
                s: t.s,
                l: t.l,
                a: t.a
            }) : st(t.h)
        }
        ,
        i.prototype.isEqual = function(e) {
            return this.toHex() === ni(e).toHex()
        }
        ,
        i
    }
    )()
      , ni = function(i) {
        return i instanceof Mc ? i : new Mc(i)
    }
      , iu = []
      , w1 = function(i) {
        i.forEach(function(e) {
            iu.indexOf(e) < 0 && (e(Mc, Rc),
            iu.push(e))
        })
    };
    function A1(i, e) {
        var t = {
            white: "#ffffff",
            bisque: "#ffe4c4",
            blue: "#0000ff",
            cadetblue: "#5f9ea0",
            chartreuse: "#7fff00",
            chocolate: "#d2691e",
            coral: "#ff7f50",
            antiquewhite: "#faebd7",
            aqua: "#00ffff",
            azure: "#f0ffff",
            whitesmoke: "#f5f5f5",
            papayawhip: "#ffefd5",
            plum: "#dda0dd",
            blanchedalmond: "#ffebcd",
            black: "#000000",
            gold: "#ffd700",
            goldenrod: "#daa520",
            gainsboro: "#dcdcdc",
            cornsilk: "#fff8dc",
            cornflowerblue: "#6495ed",
            burlywood: "#deb887",
            aquamarine: "#7fffd4",
            beige: "#f5f5dc",
            crimson: "#dc143c",
            cyan: "#00ffff",
            darkblue: "#00008b",
            darkcyan: "#008b8b",
            darkgoldenrod: "#b8860b",
            darkkhaki: "#bdb76b",
            darkgray: "#a9a9a9",
            darkgreen: "#006400",
            darkgrey: "#a9a9a9",
            peachpuff: "#ffdab9",
            darkmagenta: "#8b008b",
            darkred: "#8b0000",
            darkorchid: "#9932cc",
            darkorange: "#ff8c00",
            darkslateblue: "#483d8b",
            gray: "#808080",
            darkslategray: "#2f4f4f",
            darkslategrey: "#2f4f4f",
            deeppink: "#ff1493",
            deepskyblue: "#00bfff",
            wheat: "#f5deb3",
            firebrick: "#b22222",
            floralwhite: "#fffaf0",
            ghostwhite: "#f8f8ff",
            darkviolet: "#9400d3",
            magenta: "#ff00ff",
            green: "#008000",
            dodgerblue: "#1e90ff",
            grey: "#808080",
            honeydew: "#f0fff0",
            hotpink: "#ff69b4",
            blueviolet: "#8a2be2",
            forestgreen: "#228b22",
            lawngreen: "#7cfc00",
            indianred: "#cd5c5c",
            indigo: "#4b0082",
            fuchsia: "#ff00ff",
            brown: "#a52a2a",
            maroon: "#800000",
            mediumblue: "#0000cd",
            lightcoral: "#f08080",
            darkturquoise: "#00ced1",
            lightcyan: "#e0ffff",
            ivory: "#fffff0",
            lightyellow: "#ffffe0",
            lightsalmon: "#ffa07a",
            lightseagreen: "#20b2aa",
            linen: "#faf0e6",
            mediumaquamarine: "#66cdaa",
            lemonchiffon: "#fffacd",
            lime: "#00ff00",
            khaki: "#f0e68c",
            mediumseagreen: "#3cb371",
            limegreen: "#32cd32",
            mediumspringgreen: "#00fa9a",
            lightskyblue: "#87cefa",
            lightblue: "#add8e6",
            midnightblue: "#191970",
            lightpink: "#ffb6c1",
            mistyrose: "#ffe4e1",
            moccasin: "#ffe4b5",
            mintcream: "#f5fffa",
            lightslategray: "#778899",
            lightslategrey: "#778899",
            navajowhite: "#ffdead",
            navy: "#000080",
            mediumvioletred: "#c71585",
            powderblue: "#b0e0e6",
            palegoldenrod: "#eee8aa",
            oldlace: "#fdf5e6",
            paleturquoise: "#afeeee",
            mediumturquoise: "#48d1cc",
            mediumorchid: "#ba55d3",
            rebeccapurple: "#663399",
            lightsteelblue: "#b0c4de",
            mediumslateblue: "#7b68ee",
            thistle: "#d8bfd8",
            tan: "#d2b48c",
            orchid: "#da70d6",
            mediumpurple: "#9370db",
            purple: "#800080",
            pink: "#ffc0cb",
            skyblue: "#87ceeb",
            springgreen: "#00ff7f",
            palegreen: "#98fb98",
            red: "#ff0000",
            yellow: "#ffff00",
            slateblue: "#6a5acd",
            lavenderblush: "#fff0f5",
            peru: "#cd853f",
            palevioletred: "#db7093",
            violet: "#ee82ee",
            teal: "#008080",
            slategray: "#708090",
            slategrey: "#708090",
            aliceblue: "#f0f8ff",
            darkseagreen: "#8fbc8f",
            darkolivegreen: "#556b2f",
            greenyellow: "#adff2f",
            seagreen: "#2e8b57",
            seashell: "#fff5ee",
            tomato: "#ff6347",
            silver: "#c0c0c0",
            sienna: "#a0522d",
            lavender: "#e6e6fa",
            lightgreen: "#90ee90",
            orange: "#ffa500",
            orangered: "#ff4500",
            steelblue: "#4682b4",
            royalblue: "#4169e1",
            turquoise: "#40e0d0",
            yellowgreen: "#9acd32",
            salmon: "#fa8072",
            saddlebrown: "#8b4513",
            sandybrown: "#f4a460",
            rosybrown: "#bc8f8f",
            darksalmon: "#e9967a",
            lightgoldenrodyellow: "#fafad2",
            snow: "#fffafa",
            lightgrey: "#d3d3d3",
            lightgray: "#d3d3d3",
            dimgray: "#696969",
            dimgrey: "#696969",
            olivedrab: "#6b8e23",
            olive: "#808000"
        }
          , r = {};
        for (var s in t)
            r[t[s]] = s;
        var n = {};
        i.prototype.toName = function(a) {
            if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
                return "transparent";
            var c, l, u = r[this.toHex()];
            if (u)
                return u;
            if (a != null && a.closest) {
                var d = this.toRgb()
                  , f = 1 / 0
                  , b = "black";
                if (!n.length)
                    for (var m in t)
                        n[m] = new i(t[m]).toRgb();
                for (var x in t) {
                    var y = (c = d,
                    l = n[x],
                    Math.pow(c.r - l.r, 2) + Math.pow(c.g - l.g, 2) + Math.pow(c.b - l.b, 2));
                    y < f && (f = y,
                    b = x)
                }
                return b
            }
        }
        ,
        e.string.push([function(a) {
            var c = a.toLowerCase()
              , l = c === "transparent" ? "#0000" : t[c];
            return l ? new i(l).toRgb() : null
        }
        , "name"])
    }
    var E1 = Object.defineProperty
      , ru = Object.getOwnPropertySymbols
      , P1 = Object.prototype.hasOwnProperty
      , R1 = Object.prototype.propertyIsEnumerable
      , su = (i, e, t) => e in i ? E1(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , M1 = (i, e) => {
        for (var t in e || (e = {}))
            P1.call(e, t) && su(i, t, e[t]);
        if (ru)
            for (var t of ru(e))
                R1.call(e, t) && su(i, t, e[t]);
        return i
    }
    ;
    w1([A1]);
    var pr = class qr {
        constructor(e=16777215) {
            this._value = null,
            this._components = new Float32Array(4),
            this._components.fill(1),
            this._int = 16777215,
            this.value = e
        }
        get red() {
            return this._components[0]
        }
        get green() {
            return this._components[1]
        }
        get blue() {
            return this._components[2]
        }
        get alpha() {
            return this._components[3]
        }
        setValue(e) {
            return this.value = e,
            this
        }
        set value(e) {
            if (e instanceof qr)
                this._value = this._cloneSource(e._value),
                this._int = e._int,
                this._components.set(e._components);
            else {
                if (e === null)
                    throw new Error("Cannot set Color#value to null");
                (this._value === null || !this._isSourceEqual(this._value, e)) && (this._value = this._cloneSource(e),
                this._normalize(this._value))
            }
        }
        get value() {
            return this._value
        }
        _cloneSource(e) {
            return typeof e == "string" || typeof e == "number" || e instanceof Number || e === null ? e : Array.isArray(e) || ArrayBuffer.isView(e) ? e.slice(0) : typeof e == "object" && e !== null ? M1({}, e) : e
        }
        _isSourceEqual(e, t) {
            let r = typeof e;
            if (r !== typeof t)
                return !1;
            if (r === "number" || r === "string" || e instanceof Number)
                return e === t;
            if (Array.isArray(e) && Array.isArray(t) || ArrayBuffer.isView(e) && ArrayBuffer.isView(t))
                return e.length !== t.length ? !1 : e.every( (s, n) => s === t[n]);
            if (e !== null && t !== null) {
                let s = Object.keys(e)
                  , n = Object.keys(t);
                return s.length !== n.length ? !1 : s.every(a => e[a] === t[a])
            }
            return e === t
        }
        toRgba() {
            let[e,t,r,s] = this._components;
            return {
                r: e,
                g: t,
                b: r,
                a: s
            }
        }
        toRgb() {
            let[e,t,r] = this._components;
            return {
                r: e,
                g: t,
                b: r
            }
        }
        toRgbaString() {
            let[e,t,r] = this.toUint8RgbArray();
            return `rgba(${e},${t},${r},${this.alpha})`
        }
        toUint8RgbArray(e) {
            let[t,r,s] = this._components;
            return this._arrayRgb || (this._arrayRgb = []),
            e || (e = this._arrayRgb),
            e[0] = Math.round(t * 255),
            e[1] = Math.round(r * 255),
            e[2] = Math.round(s * 255),
            e
        }
        toArray(e) {
            this._arrayRgba || (this._arrayRgba = []),
            e || (e = this._arrayRgba);
            let[t,r,s,n] = this._components;
            return e[0] = t,
            e[1] = r,
            e[2] = s,
            e[3] = n,
            e
        }
        toRgbArray(e) {
            this._arrayRgb || (this._arrayRgb = []),
            e || (e = this._arrayRgb);
            let[t,r,s] = this._components;
            return e[0] = t,
            e[1] = r,
            e[2] = s,
            e
        }
        toNumber() {
            return this._int
        }
        toBgrNumber() {
            let[e,t,r] = this.toUint8RgbArray();
            return (r << 16) + (t << 8) + e
        }
        toLittleEndianNumber() {
            let e = this._int;
            return (e >> 16) + (e & 65280) + ((e & 255) << 16)
        }
        multiply(e) {
            let[t,r,s,n] = qr._temp.setValue(e)._components;
            return this._components[0] *= t,
            this._components[1] *= r,
            this._components[2] *= s,
            this._components[3] *= n,
            this._refreshInt(),
            this._value = null,
            this
        }
        premultiply(e, t=!0) {
            return t && (this._components[0] *= e,
            this._components[1] *= e,
            this._components[2] *= e),
            this._components[3] = e,
            this._refreshInt(),
            this._value = null,
            this
        }
        toPremultiplied(e, t=!0) {
            if (e === 1)
                return (255 << 24) + this._int;
            if (e === 0)
                return t ? 0 : this._int;
            let r = this._int >> 16 & 255
              , s = this._int >> 8 & 255
              , n = this._int & 255;
            return t && (r = r * e + .5 | 0,
            s = s * e + .5 | 0,
            n = n * e + .5 | 0),
            (e * 255 << 24) + (r << 16) + (s << 8) + n
        }
        toHex() {
            let e = this._int.toString(16);
            return `#${"000000".substring(0, 6 - e.length) + e}`
        }
        toHexa() {
            let e = Math.round(this._components[3] * 255).toString(16);
            return this.toHex() + "00".substring(0, 2 - e.length) + e
        }
        setAlpha(e) {
            return this._components[3] = this._clamp(e),
            this
        }
        _normalize(e) {
            let t, r, s, n;
            if ((typeof e == "number" || e instanceof Number) && e >= 0 && e <= 16777215) {
                let a = e;
                t = (a >> 16 & 255) / 255,
                r = (a >> 8 & 255) / 255,
                s = (a & 255) / 255,
                n = 1
            } else if ((Array.isArray(e) || e instanceof Float32Array) && e.length >= 3 && e.length <= 4)
                e = this._clamp(e),
                [t,r,s,n=1] = e;
            else if ((e instanceof Uint8Array || e instanceof Uint8ClampedArray) && e.length >= 3 && e.length <= 4)
                e = this._clamp(e, 0, 255),
                [t,r,s,n=255] = e,
                t /= 255,
                r /= 255,
                s /= 255,
                n /= 255;
            else if (typeof e == "string" || typeof e == "object") {
                if (typeof e == "string") {
                    let c = qr.HEX_PATTERN.exec(e);
                    c && (e = `#${c[2]}`)
                }
                let a = ni(e);
                a.isValid() && ({r: t, g: r, b: s, a: n} = a.rgba,
                t /= 255,
                r /= 255,
                s /= 255)
            }
            if (t !== void 0)
                this._components[0] = t,
                this._components[1] = r,
                this._components[2] = s,
                this._components[3] = n,
                this._refreshInt();
            else
                throw new Error(`Unable to convert color ${e}`)
        }
        _refreshInt() {
            this._clamp(this._components);
            let[e,t,r] = this._components;
            this._int = (e * 255 << 16) + (t * 255 << 8) + (r * 255 | 0)
        }
        _clamp(e, t=0, r=1) {
            return typeof e == "number" ? Math.min(Math.max(e, t), r) : (e.forEach( (s, n) => {
                e[n] = Math.min(Math.max(s, t), r)
            }
            ),
            e)
        }
        static isColorLike(e) {
            return typeof e == "number" || typeof e == "string" || e instanceof Number || e instanceof qr || Array.isArray(e) || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Float32Array || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 && e.a !== void 0
        }
    }
    ;
    pr.shared = new pr,
    pr._temp = new pr,
    pr.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
    var Ie = pr
      , C1 = {
        cullArea: null,
        cullable: !1,
        cullableChildren: !0
    }
      , O1 = Math.PI * 2
      , I1 = 180 / Math.PI
      , G1 = Math.PI / 180
      , Ne = class i {
        constructor(e=0, t=0) {
            this.x = 0,
            this.y = 0,
            this.x = e,
            this.y = t
        }
        clone() {
            return new i(this.x,this.y)
        }
        copyFrom(e) {
            return this.set(e.x, e.y),
            this
        }
        copyTo(e) {
            return e.set(this.x, this.y),
            e
        }
        equals(e) {
            return e.x === this.x && e.y === this.y
        }
        set(e=0, t=e) {
            return this.x = e,
            this.y = t,
            this
        }
        static get shared() {
            return Ro.x = 0,
            Ro.y = 0,
            Ro
        }
    }
      , Ro = new Ne
      , ce = class i {
        constructor(e=1, t=0, r=0, s=1, n=0, a=0) {
            this.array = null,
            this.a = e,
            this.b = t,
            this.c = r,
            this.d = s,
            this.tx = n,
            this.ty = a
        }
        fromArray(e) {
            this.a = e[0],
            this.b = e[1],
            this.c = e[3],
            this.d = e[4],
            this.tx = e[2],
            this.ty = e[5]
        }
        set(e, t, r, s, n, a) {
            return this.a = e,
            this.b = t,
            this.c = r,
            this.d = s,
            this.tx = n,
            this.ty = a,
            this
        }
        toArray(e, t) {
            this.array || (this.array = new Float32Array(9));
            let r = t || this.array;
            return e ? (r[0] = this.a,
            r[1] = this.b,
            r[2] = 0,
            r[3] = this.c,
            r[4] = this.d,
            r[5] = 0,
            r[6] = this.tx,
            r[7] = this.ty,
            r[8] = 1) : (r[0] = this.a,
            r[1] = this.c,
            r[2] = this.tx,
            r[3] = this.b,
            r[4] = this.d,
            r[5] = this.ty,
            r[6] = 0,
            r[7] = 0,
            r[8] = 1),
            r
        }
        apply(e, t) {
            t = t || new Ne;
            let r = e.x
              , s = e.y;
            return t.x = this.a * r + this.c * s + this.tx,
            t.y = this.b * r + this.d * s + this.ty,
            t
        }
        applyInverse(e, t) {
            t = t || new Ne;
            let r = this.a
              , s = this.b
              , n = this.c
              , a = this.d
              , c = this.tx
              , l = this.ty
              , u = 1 / (r * a + n * -s)
              , d = e.x
              , f = e.y;
            return t.x = a * u * d + -n * u * f + (l * n - c * a) * u,
            t.y = r * u * f + -s * u * d + (-l * r + c * s) * u,
            t
        }
        translate(e, t) {
            return this.tx += e,
            this.ty += t,
            this
        }
        scale(e, t) {
            return this.a *= e,
            this.d *= t,
            this.c *= e,
            this.b *= t,
            this.tx *= e,
            this.ty *= t,
            this
        }
        rotate(e) {
            let t = Math.cos(e)
              , r = Math.sin(e)
              , s = this.a
              , n = this.c
              , a = this.tx;
            return this.a = s * t - this.b * r,
            this.b = s * r + this.b * t,
            this.c = n * t - this.d * r,
            this.d = n * r + this.d * t,
            this.tx = a * t - this.ty * r,
            this.ty = a * r + this.ty * t,
            this
        }
        append(e) {
            let t = this.a
              , r = this.b
              , s = this.c
              , n = this.d;
            return this.a = e.a * t + e.b * s,
            this.b = e.a * r + e.b * n,
            this.c = e.c * t + e.d * s,
            this.d = e.c * r + e.d * n,
            this.tx = e.tx * t + e.ty * s + this.tx,
            this.ty = e.tx * r + e.ty * n + this.ty,
            this
        }
        appendFrom(e, t) {
            let r = e.a
              , s = e.b
              , n = e.c
              , a = e.d
              , c = e.tx
              , l = e.ty
              , u = t.a
              , d = t.b
              , f = t.c
              , b = t.d;
            return this.a = r * u + s * f,
            this.b = r * d + s * b,
            this.c = n * u + a * f,
            this.d = n * d + a * b,
            this.tx = c * u + l * f + t.tx,
            this.ty = c * d + l * b + t.ty,
            this
        }
        setTransform(e, t, r, s, n, a, c, l, u) {
            return this.a = Math.cos(c + u) * n,
            this.b = Math.sin(c + u) * n,
            this.c = -Math.sin(c - l) * a,
            this.d = Math.cos(c - l) * a,
            this.tx = e - (r * this.a + s * this.c),
            this.ty = t - (r * this.b + s * this.d),
            this
        }
        prepend(e) {
            let t = this.tx;
            if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
                let r = this.a
                  , s = this.c;
                this.a = r * e.a + this.b * e.c,
                this.b = r * e.b + this.b * e.d,
                this.c = s * e.a + this.d * e.c,
                this.d = s * e.b + this.d * e.d
            }
            return this.tx = t * e.a + this.ty * e.c + e.tx,
            this.ty = t * e.b + this.ty * e.d + e.ty,
            this
        }
        decompose(e) {
            let t = this.a
              , r = this.b
              , s = this.c
              , n = this.d
              , a = e.pivot
              , c = -Math.atan2(-s, n)
              , l = Math.atan2(r, t)
              , u = Math.abs(c + l);
            return u < 1e-5 || Math.abs(O1 - u) < 1e-5 ? (e.rotation = l,
            e.skew.x = e.skew.y = 0) : (e.rotation = 0,
            e.skew.x = c,
            e.skew.y = l),
            e.scale.x = Math.sqrt(t * t + r * r),
            e.scale.y = Math.sqrt(s * s + n * n),
            e.position.x = this.tx + (a.x * t + a.y * s),
            e.position.y = this.ty + (a.x * r + a.y * n),
            e
        }
        invert() {
            let e = this.a
              , t = this.b
              , r = this.c
              , s = this.d
              , n = this.tx
              , a = e * s - t * r;
            return this.a = s / a,
            this.b = -t / a,
            this.c = -r / a,
            this.d = e / a,
            this.tx = (r * this.ty - s * n) / a,
            this.ty = -(e * this.ty - t * n) / a,
            this
        }
        isIdentity() {
            return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0
        }
        identity() {
            return this.a = 1,
            this.b = 0,
            this.c = 0,
            this.d = 1,
            this.tx = 0,
            this.ty = 0,
            this
        }
        clone() {
            let e = new i;
            return e.a = this.a,
            e.b = this.b,
            e.c = this.c,
            e.d = this.d,
            e.tx = this.tx,
            e.ty = this.ty,
            e
        }
        copyTo(e) {
            return e.a = this.a,
            e.b = this.b,
            e.c = this.c,
            e.d = this.d,
            e.tx = this.tx,
            e.ty = this.ty,
            e
        }
        copyFrom(e) {
            return this.a = e.a,
            this.b = e.b,
            this.c = e.c,
            this.d = e.d,
            this.tx = e.tx,
            this.ty = e.ty,
            this
        }
        equals(e) {
            return e.a === this.a && e.b === this.b && e.c === this.c && e.d === this.d && e.tx === this.tx && e.ty === this.ty
        }
        static get IDENTITY() {
            return F1.identity()
        }
        static get shared() {
            return B1.identity()
        }
    }
      , B1 = new ce
      , F1 = new ce
      , We = class i {
        constructor(e, t, r) {
            this._x = t || 0,
            this._y = r || 0,
            this._observer = e
        }
        clone(e) {
            return new i(e ?? this._observer,this._x,this._y)
        }
        set(e=0, t=e) {
            return (this._x !== e || this._y !== t) && (this._x = e,
            this._y = t,
            this._observer._onUpdate(this)),
            this
        }
        copyFrom(e) {
            return (this._x !== e.x || this._y !== e.y) && (this._x = e.x,
            this._y = e.y,
            this._observer._onUpdate(this)),
            this
        }
        copyTo(e) {
            return e.set(this._x, this._y),
            e
        }
        equals(e) {
            return e.x === this._x && e.y === this._y
        }
        get x() {
            return this._x
        }
        set x(e) {
            this._x !== e && (this._x = e,
            this._observer._onUpdate(this))
        }
        get y() {
            return this._y
        }
        set y(e) {
            this._y !== e && (this._y = e,
            this._observer._onUpdate(this))
        }
    }
      , Mo = {
        default: -1
    };
    function Xe(i="default") {
        return Mo[i] === void 0 && (Mo[i] = -1),
        ++Mo[i]
    }
    var Cr = {
        _registeredResources: new Set,
        register(i) {
            this._registeredResources.add(i)
        },
        unregister(i) {
            this._registeredResources.delete(i)
        },
        release() {
            this._registeredResources.forEach(i => i.clear())
        },
        get registeredCount() {
            return this._registeredResources.size
        },
        isRegistered(i) {
            return this._registeredResources.has(i)
        },
        reset() {
            this._registeredResources.clear()
        }
    }
      , Cc = class {
        constructor(e, t) {
            this._pool = [],
            this._count = 0,
            this._index = 0,
            this._classType = e,
            t && this.prepopulate(t)
        }
        prepopulate(e) {
            for (let t = 0; t < e; t++)
                this._pool[this._index++] = new this._classType;
            this._count += e
        }
        get(e) {
            var t;
            let r;
            return this._index > 0 ? r = this._pool[--this._index] : r = new this._classType,
            (t = r.init) == null || t.call(r, e),
            r
        }
        return(e) {
            var t;
            (t = e.reset) == null || t.call(e),
            this._pool[this._index++] = e
        }
        get totalSize() {
            return this._count
        }
        get totalFree() {
            return this._index
        }
        get totalUsed() {
            return this._count - this._index
        }
        clear() {
            if (this._pool.length > 0 && this._pool[0].destroy)
                for (let e = 0; e < this._index; e++)
                    this._pool[e].destroy();
            this._pool.length = 0,
            this._count = 0,
            this._index = 0
        }
    }
      , Oc = class {
        constructor() {
            this._poolsByClass = new Map
        }
        prepopulate(e, t) {
            this.getPool(e).prepopulate(t)
        }
        get(e, t) {
            return this.getPool(e).get(t)
        }
        return(e) {
            this.getPool(e.constructor).return(e)
        }
        getPool(e) {
            return this._poolsByClass.has(e) || this._poolsByClass.set(e, new Cc(e)),
            this._poolsByClass.get(e)
        }
        stats() {
            let e = {};
            return this._poolsByClass.forEach(t => {
                let r = e[t._classType.name] ? t._classType.name + t._classType.ID : t._classType.name;
                e[r] = {
                    free: t.totalFree,
                    used: t.totalUsed,
                    size: t.totalSize
                }
            }
            ),
            e
        }
        clear() {
            this._poolsByClass.forEach(e => e.clear()),
            this._poolsByClass.clear()
        }
    }
      , et = new Oc;
    Cr.register(et);
    var D1 = {
        get isCachedAsTexture() {
            var i;
            return !!((i = this.renderGroup) != null && i.isCachedAsTexture)
        },
        cacheAsTexture(i) {
            typeof i == "boolean" && i === !1 ? this.disableRenderGroup() : (this.enableRenderGroup(),
            this.renderGroup.enableCacheAsTexture(i === !0 ? {} : i))
        },
        updateCacheTexture() {
            var i;
            (i = this.renderGroup) == null || i.updateCacheTexture()
        },
        get cacheAsBitmap() {
            return this.isCachedAsTexture
        },
        set cacheAsBitmap(i) {
            this.cacheAsTexture(i)
        }
    };
    function Hb(i, e, t) {
        let r = i.length, s;
        if (e >= r || t === 0)
            return;
        t = e + t > r ? r - e : t;
        let n = r - t;
        for (s = e; s < n; ++s)
            i[s] = i[s + t];
        i.length = n
    }
    var k1 = {
        allowChildren: !0,
        removeChildren(i=0, e) {
            var t;
            let r = e ?? this.children.length
              , s = r - i
              , n = [];
            if (s > 0 && s <= r) {
                for (let c = r - 1; c >= i; c--) {
                    let l = this.children[c];
                    l && (n.push(l),
                    l.parent = null)
                }
                Hb(this.children, i, r);
                let a = this.renderGroup || this.parentRenderGroup;
                a && a.removeChildren(n);
                for (let c = 0; c < n.length; ++c) {
                    let l = n[c];
                    (t = l.parentRenderLayer) == null || t.detach(l),
                    this.emit("childRemoved", l, this, c),
                    n[c].emit("removed", this)
                }
                return n.length > 0 && this._didViewChangeTick++,
                n
            } else if (s === 0 && this.children.length === 0)
                return n;
            throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
        },
        removeChildAt(i) {
            let e = this.getChildAt(i);
            return this.removeChild(e)
        },
        getChildAt(i) {
            if (i < 0 || i >= this.children.length)
                throw new Error(`getChildAt: Index (${i}) does not exist.`);
            return this.children[i]
        },
        setChildIndex(i, e) {
            if (e < 0 || e >= this.children.length)
                throw new Error(`The index ${e} supplied is out of bounds ${this.children.length}`);
            this.getChildIndex(i),
            this.addChildAt(i, e)
        },
        getChildIndex(i) {
            let e = this.children.indexOf(i);
            if (e === -1)
                throw new Error("The supplied Container must be a child of the caller");
            return e
        },
        addChildAt(i, e) {
            let {children: t} = this;
            if (e < 0 || e > t.length)
                throw new Error(`${i}addChildAt: The index ${e} supplied is out of bounds ${t.length}`);
            if (i.parent) {
                let s = i.parent.children.indexOf(i);
                if (i.parent === this && s === e)
                    return i;
                s !== -1 && i.parent.children.splice(s, 1)
            }
            e === t.length ? t.push(i) : t.splice(e, 0, i),
            i.parent = this,
            i.didChange = !0,
            i._updateFlags = 15;
            let r = this.renderGroup || this.parentRenderGroup;
            return r && r.addChild(i),
            this.sortableChildren && (this.sortDirty = !0),
            this.emit("childAdded", i, this, e),
            i.emit("added", this),
            i
        },
        swapChildren(i, e) {
            if (i === e)
                return;
            let t = this.getChildIndex(i)
              , r = this.getChildIndex(e);
            this.children[t] = e,
            this.children[r] = i;
            let s = this.renderGroup || this.parentRenderGroup;
            s && (s.structureDidChange = !0),
            this._didContainerChangeTick++
        },
        removeFromParent() {
            var i;
            (i = this.parent) == null || i.removeChild(this)
        },
        reparentChild(...i) {
            return i.length === 1 ? this.reparentChildAt(i[0], this.children.length) : (i.forEach(e => this.reparentChildAt(e, this.children.length)),
            i[0])
        },
        reparentChildAt(i, e) {
            if (i.parent === this)
                return this.setChildIndex(i, e),
                i;
            let t = i.worldTransform.clone();
            i.removeFromParent(),
            this.addChildAt(i, e);
            let r = this.worldTransform.clone();
            return r.invert(),
            t.prepend(r),
            i.setFromMatrix(t),
            i
        },
        replaceChild(i, e) {
            i.updateLocalTransform(),
            this.addChildAt(e, this.getChildIndex(i)),
            e.setFromMatrix(i.localTransform),
            e.updateLocalTransform(),
            this.removeChild(i)
        }
    }
      , U1 = {
        collectRenderables(i, e, t) {
            this.parentRenderLayer && this.parentRenderLayer !== t || this.globalDisplayStatus < 7 || !this.includeInBuild || (this.sortableChildren && this.sortChildren(),
            this.isSimple ? this.collectRenderablesSimple(i, e, t) : this.renderGroup ? e.renderPipes.renderGroup.addRenderGroup(this.renderGroup, i) : this.collectRenderablesWithEffects(i, e, t))
        },
        collectRenderablesSimple(i, e, t) {
            let r = this.children
              , s = r.length;
            for (let n = 0; n < s; n++)
                r[n].collectRenderables(i, e, t)
        },
        collectRenderablesWithEffects(i, e, t) {
            let {renderPipes: r} = e;
            for (let s = 0; s < this.effects.length; s++) {
                let n = this.effects[s];
                r[n.pipe].push(n, this, i)
            }
            this.collectRenderablesSimple(i, e, t);
            for (let s = this.effects.length - 1; s >= 0; s--) {
                let n = this.effects[s];
                r[n.pipe].pop(n, this, i)
            }
        }
    }
      , Tr = class {
        constructor() {
            this.pipe = "filter",
            this.priority = 1
        }
        destroy() {
            for (let e = 0; e < this.filters.length; e++)
                this.filters[e].destroy();
            this.filters = null,
            this.filterArea = null
        }
    }
      , Ic = class {
        constructor() {
            this._effectClasses = [],
            this._tests = [],
            this._initialized = !1
        }
        init() {
            this._initialized || (this._initialized = !0,
            this._effectClasses.forEach(e => {
                this.add({
                    test: e.test,
                    maskClass: e
                })
            }
            ))
        }
        add(e) {
            this._tests.push(e)
        }
        getMaskEffect(e) {
            this._initialized || this.init();
            for (let t = 0; t < this._tests.length; t++) {
                let r = this._tests[t];
                if (r.test(e))
                    return et.get(r.maskClass, e)
            }
            return e
        }
        returnMaskEffect(e) {
            et.return(e)
        }
    }
      , Gc = new Ic;
    be.handleByList(B.MaskEffect, Gc._effectClasses);
    var L1 = Object.defineProperty
      , nu = Object.getOwnPropertySymbols
      , N1 = Object.prototype.hasOwnProperty
      , X1 = Object.prototype.propertyIsEnumerable
      , au = (i, e, t) => e in i ? L1(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , ou = (i, e) => {
        for (var t in e || (e = {}))
            N1.call(e, t) && au(i, t, e[t]);
        if (nu)
            for (var t of nu(e))
                X1.call(e, t) && au(i, t, e[t]);
        return i
    }
      , j1 = {
        _maskEffect: null,
        _maskOptions: {
            inverse: !1
        },
        _filterEffect: null,
        effects: [],
        _markStructureAsChanged() {
            let i = this.renderGroup || this.parentRenderGroup;
            i && (i.structureDidChange = !0)
        },
        addEffect(i) {
            this.effects.indexOf(i) === -1 && (this.effects.push(i),
            this.effects.sort( (e, t) => e.priority - t.priority),
            this._markStructureAsChanged(),
            this._updateIsSimple())
        },
        removeEffect(i) {
            let e = this.effects.indexOf(i);
            e !== -1 && (this.effects.splice(e, 1),
            this._markStructureAsChanged(),
            this._updateIsSimple())
        },
        set mask(i) {
            let e = this._maskEffect;
            e?.mask !== i && (e && (this.removeEffect(e),
            Gc.returnMaskEffect(e),
            this._maskEffect = null),
            i != null && (this._maskEffect = Gc.getMaskEffect(i),
            this.addEffect(this._maskEffect)))
        },
        get mask() {
            var i;
            return (i = this._maskEffect) == null ? void 0 : i.mask
        },
        setMask(i) {
            this._maskOptions = ou(ou({}, this._maskOptions), i),
            i.mask && (this.mask = i.mask),
            this._markStructureAsChanged()
        },
        set filters(i) {
            var e;
            !Array.isArray(i) && i && (i = [i]);
            let t = this._filterEffect || (this._filterEffect = new Tr);
            i = i;
            let r = i?.length > 0
              , s = ((e = t.filters) == null ? void 0 : e.length) > 0
              , n = r !== s;
            i = Array.isArray(i) ? i.slice(0) : i,
            t.filters = Object.freeze(i),
            n && (r ? this.addEffect(t) : (this.removeEffect(t),
            t.filters = i ?? null))
        },
        get filters() {
            var i;
            return (i = this._filterEffect) == null ? void 0 : i.filters
        },
        set filterArea(i) {
            this._filterEffect || (this._filterEffect = new Tr),
            this._filterEffect.filterArea = i
        },
        get filterArea() {
            var i;
            return (i = this._filterEffect) == null ? void 0 : i.filterArea
        }
    }
      , H1 = {
        label: null,
        get name() {
            return this.label
        },
        set name(i) {
            this.label = i
        },
        getChildByName(i, e=!1) {
            return this.getChildByLabel(i, e)
        },
        getChildByLabel(i, e=!1) {
            let t = this.children;
            for (let r = 0; r < t.length; r++) {
                let s = t[r];
                if (s.label === i || i instanceof RegExp && i.test(s.label))
                    return s
            }
            if (e)
                for (let r = 0; r < t.length; r++) {
                    let s = t[r].getChildByLabel(i, !0);
                    if (s)
                        return s
                }
            return null
        },
        getChildrenByLabel(i, e=!1, t=[]) {
            let r = this.children;
            for (let s = 0; s < r.length; s++) {
                let n = r[s];
                (n.label === i || i instanceof RegExp && i.test(n.label)) && t.push(n)
            }
            if (e)
                for (let s = 0; s < r.length; s++)
                    r[s].getChildrenByLabel(i, !0, t);
            return t
        }
    }
      , Ns = [new Ne, new Ne, new Ne, new Ne]
      , Re = class i {
        constructor(e=0, t=0, r=0, s=0) {
            this.type = "rectangle",
            this.x = Number(e),
            this.y = Number(t),
            this.width = Number(r),
            this.height = Number(s)
        }
        get left() {
            return this.x
        }
        get right() {
            return this.x + this.width
        }
        get top() {
            return this.y
        }
        get bottom() {
            return this.y + this.height
        }
        isEmpty() {
            return this.left === this.right || this.top === this.bottom
        }
        static get EMPTY() {
            return new i(0,0,0,0)
        }
        clone() {
            return new i(this.x,this.y,this.width,this.height)
        }
        copyFromBounds(e) {
            return this.x = e.minX,
            this.y = e.minY,
            this.width = e.maxX - e.minX,
            this.height = e.maxY - e.minY,
            this
        }
        copyFrom(e) {
            return this.x = e.x,
            this.y = e.y,
            this.width = e.width,
            this.height = e.height,
            this
        }
        copyTo(e) {
            return e.copyFrom(this),
            e
        }
        contains(e, t) {
            return this.width <= 0 || this.height <= 0 ? !1 : e >= this.x && e < this.x + this.width && t >= this.y && t < this.y + this.height
        }
        strokeContains(e, t, r, s=.5) {
            let {width: n, height: a} = this;
            if (n <= 0 || a <= 0)
                return !1;
            let c = this.x
              , l = this.y
              , u = r * (1 - s)
              , d = r - u
              , f = c - u
              , b = c + n + u
              , m = l - u
              , x = l + a + u
              , y = c + d
              , S = c + n - d
              , A = l + d
              , E = l + a - d;
            return e >= f && e <= b && t >= m && t <= x && !(e > y && e < S && t > A && t < E)
        }
        intersects(e, t) {
            if (!t) {
                let Y = this.x < e.x ? e.x : this.x;
                if ((this.right > e.right ? e.right : this.right) <= Y)
                    return !1;
                let ie = this.y < e.y ? e.y : this.y;
                return (this.bottom > e.bottom ? e.bottom : this.bottom) > ie
            }
            let r = this.left
              , s = this.right
              , n = this.top
              , a = this.bottom;
            if (s <= r || a <= n)
                return !1;
            let c = Ns[0].set(e.left, e.top)
              , l = Ns[1].set(e.left, e.bottom)
              , u = Ns[2].set(e.right, e.top)
              , d = Ns[3].set(e.right, e.bottom);
            if (u.x <= c.x || l.y <= c.y)
                return !1;
            let f = Math.sign(t.a * t.d - t.b * t.c);
            if (f === 0 || (t.apply(c, c),
            t.apply(l, l),
            t.apply(u, u),
            t.apply(d, d),
            Math.max(c.x, l.x, u.x, d.x) <= r || Math.min(c.x, l.x, u.x, d.x) >= s || Math.max(c.y, l.y, u.y, d.y) <= n || Math.min(c.y, l.y, u.y, d.y) >= a))
                return !1;
            let b = f * (l.y - c.y)
              , m = f * (c.x - l.x)
              , x = b * r + m * n
              , y = b * s + m * n
              , S = b * r + m * a
              , A = b * s + m * a;
            if (Math.max(x, y, S, A) <= b * c.x + m * c.y || Math.min(x, y, S, A) >= b * d.x + m * d.y)
                return !1;
            let E = f * (c.y - u.y)
              , O = f * (u.x - c.x)
              , M = E * r + O * n
              , j = E * s + O * n
              , L = E * r + O * a
              , N = E * s + O * a;
            return !(Math.max(M, j, L, N) <= E * c.x + O * c.y || Math.min(M, j, L, N) >= E * d.x + O * d.y)
        }
        pad(e=0, t=e) {
            return this.x -= e,
            this.y -= t,
            this.width += e * 2,
            this.height += t * 2,
            this
        }
        fit(e) {
            let t = Math.max(this.x, e.x)
              , r = Math.min(this.x + this.width, e.x + e.width)
              , s = Math.max(this.y, e.y)
              , n = Math.min(this.y + this.height, e.y + e.height);
            return this.x = t,
            this.width = Math.max(r - t, 0),
            this.y = s,
            this.height = Math.max(n - s, 0),
            this
        }
        ceil(e=1, t=.001) {
            let r = Math.ceil((this.x + this.width - t) * e) / e
              , s = Math.ceil((this.y + this.height - t) * e) / e;
            return this.x = Math.floor((this.x + t) * e) / e,
            this.y = Math.floor((this.y + t) * e) / e,
            this.width = r - this.x,
            this.height = s - this.y,
            this
        }
        scale(e, t=e) {
            return this.x *= e,
            this.y *= t,
            this.width *= e,
            this.height *= t,
            this
        }
        enlarge(e) {
            let t = Math.min(this.x, e.x)
              , r = Math.max(this.x + this.width, e.x + e.width)
              , s = Math.min(this.y, e.y)
              , n = Math.max(this.y + this.height, e.y + e.height);
            return this.x = t,
            this.width = r - t,
            this.y = s,
            this.height = n - s,
            this
        }
        getBounds(e) {
            return e || (e = new i),
            e.copyFrom(this),
            e
        }
        containsRect(e) {
            if (this.width <= 0 || this.height <= 0)
                return !1;
            let t = e.x
              , r = e.y
              , s = e.x + e.width
              , n = e.y + e.height;
            return t >= this.x && t < this.x + this.width && r >= this.y && r < this.y + this.height && s >= this.x && s < this.x + this.width && n >= this.y && n < this.y + this.height
        }
        set(e, t, r, s) {
            return this.x = e,
            this.y = t,
            this.width = r,
            this.height = s,
            this
        }
    }
      , cu = new ce
      , at = class i {
        constructor(e=1 / 0, t=1 / 0, r=-1 / 0, s=-1 / 0) {
            this.minX = 1 / 0,
            this.minY = 1 / 0,
            this.maxX = -1 / 0,
            this.maxY = -1 / 0,
            this.matrix = cu,
            this.minX = e,
            this.minY = t,
            this.maxX = r,
            this.maxY = s
        }
        isEmpty() {
            return this.minX > this.maxX || this.minY > this.maxY
        }
        get rectangle() {
            this._rectangle || (this._rectangle = new Re);
            let e = this._rectangle;
            return this.minX > this.maxX || this.minY > this.maxY ? (e.x = 0,
            e.y = 0,
            e.width = 0,
            e.height = 0) : e.copyFromBounds(this),
            e
        }
        clear() {
            return this.minX = 1 / 0,
            this.minY = 1 / 0,
            this.maxX = -1 / 0,
            this.maxY = -1 / 0,
            this.matrix = cu,
            this
        }
        set(e, t, r, s) {
            this.minX = e,
            this.minY = t,
            this.maxX = r,
            this.maxY = s
        }
        addFrame(e, t, r, s, n) {
            n || (n = this.matrix);
            let a = n.a
              , c = n.b
              , l = n.c
              , u = n.d
              , d = n.tx
              , f = n.ty
              , b = this.minX
              , m = this.minY
              , x = this.maxX
              , y = this.maxY
              , S = a * e + l * t + d
              , A = c * e + u * t + f;
            S < b && (b = S),
            A < m && (m = A),
            S > x && (x = S),
            A > y && (y = A),
            S = a * r + l * t + d,
            A = c * r + u * t + f,
            S < b && (b = S),
            A < m && (m = A),
            S > x && (x = S),
            A > y && (y = A),
            S = a * e + l * s + d,
            A = c * e + u * s + f,
            S < b && (b = S),
            A < m && (m = A),
            S > x && (x = S),
            A > y && (y = A),
            S = a * r + l * s + d,
            A = c * r + u * s + f,
            S < b && (b = S),
            A < m && (m = A),
            S > x && (x = S),
            A > y && (y = A),
            this.minX = b,
            this.minY = m,
            this.maxX = x,
            this.maxY = y
        }
        addRect(e, t) {
            this.addFrame(e.x, e.y, e.x + e.width, e.y + e.height, t)
        }
        addBounds(e, t) {
            this.addFrame(e.minX, e.minY, e.maxX, e.maxY, t)
        }
        addBoundsMask(e) {
            this.minX = this.minX > e.minX ? this.minX : e.minX,
            this.minY = this.minY > e.minY ? this.minY : e.minY,
            this.maxX = this.maxX < e.maxX ? this.maxX : e.maxX,
            this.maxY = this.maxY < e.maxY ? this.maxY : e.maxY
        }
        applyMatrix(e) {
            let t = this.minX
              , r = this.minY
              , s = this.maxX
              , n = this.maxY
              , {a, b: c, c: l, d: u, tx: d, ty: f} = e
              , b = a * t + l * r + d
              , m = c * t + u * r + f;
            this.minX = b,
            this.minY = m,
            this.maxX = b,
            this.maxY = m,
            b = a * s + l * r + d,
            m = c * s + u * r + f,
            this.minX = b < this.minX ? b : this.minX,
            this.minY = m < this.minY ? m : this.minY,
            this.maxX = b > this.maxX ? b : this.maxX,
            this.maxY = m > this.maxY ? m : this.maxY,
            b = a * t + l * n + d,
            m = c * t + u * n + f,
            this.minX = b < this.minX ? b : this.minX,
            this.minY = m < this.minY ? m : this.minY,
            this.maxX = b > this.maxX ? b : this.maxX,
            this.maxY = m > this.maxY ? m : this.maxY,
            b = a * s + l * n + d,
            m = c * s + u * n + f,
            this.minX = b < this.minX ? b : this.minX,
            this.minY = m < this.minY ? m : this.minY,
            this.maxX = b > this.maxX ? b : this.maxX,
            this.maxY = m > this.maxY ? m : this.maxY
        }
        fit(e) {
            return this.minX < e.left && (this.minX = e.left),
            this.maxX > e.right && (this.maxX = e.right),
            this.minY < e.top && (this.minY = e.top),
            this.maxY > e.bottom && (this.maxY = e.bottom),
            this
        }
        fitBounds(e, t, r, s) {
            return this.minX < e && (this.minX = e),
            this.maxX > t && (this.maxX = t),
            this.minY < r && (this.minY = r),
            this.maxY > s && (this.maxY = s),
            this
        }
        pad(e, t=e) {
            return this.minX -= e,
            this.maxX += e,
            this.minY -= t,
            this.maxY += t,
            this
        }
        ceil() {
            return this.minX = Math.floor(this.minX),
            this.minY = Math.floor(this.minY),
            this.maxX = Math.ceil(this.maxX),
            this.maxY = Math.ceil(this.maxY),
            this
        }
        clone() {
            return new i(this.minX,this.minY,this.maxX,this.maxY)
        }
        scale(e, t=e) {
            return this.minX *= e,
            this.minY *= t,
            this.maxX *= e,
            this.maxY *= t,
            this
        }
        get x() {
            return this.minX
        }
        set x(e) {
            let t = this.maxX - this.minX;
            this.minX = e,
            this.maxX = e + t
        }
        get y() {
            return this.minY
        }
        set y(e) {
            let t = this.maxY - this.minY;
            this.minY = e,
            this.maxY = e + t
        }
        get width() {
            return this.maxX - this.minX
        }
        set width(e) {
            this.maxX = this.minX + e
        }
        get height() {
            return this.maxY - this.minY
        }
        set height(e) {
            this.maxY = this.minY + e
        }
        get left() {
            return this.minX
        }
        get right() {
            return this.maxX
        }
        get top() {
            return this.minY
        }
        get bottom() {
            return this.maxY
        }
        get isPositive() {
            return this.maxX - this.minX > 0 && this.maxY - this.minY > 0
        }
        get isValid() {
            return this.minX + this.minY !== 1 / 0
        }
        addVertexData(e, t, r, s) {
            let n = this.minX
              , a = this.minY
              , c = this.maxX
              , l = this.maxY;
            s || (s = this.matrix);
            let u = s.a
              , d = s.b
              , f = s.c
              , b = s.d
              , m = s.tx
              , x = s.ty;
            for (let y = t; y < r; y += 2) {
                let S = e[y]
                  , A = e[y + 1]
                  , E = u * S + f * A + m
                  , O = d * S + b * A + x;
                n = E < n ? E : n,
                a = O < a ? O : a,
                c = E > c ? E : c,
                l = O > l ? O : l
            }
            this.minX = n,
            this.minY = a,
            this.maxX = c,
            this.maxY = l
        }
        containsPoint(e, t) {
            return this.minX <= e && this.minY <= t && this.maxX >= e && this.maxY >= t
        }
        toString() {
            return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`
        }
        copyFrom(e) {
            return this.minX = e.minX,
            this.minY = e.minY,
            this.maxX = e.maxX,
            this.maxY = e.maxY,
            this
        }
    }
      , mt = et.getPool(ce)
      , bi = et.getPool(at)
      , z1 = new ce
      , V1 = {
        getFastGlobalBounds(i, e) {
            e || (e = new at),
            e.clear(),
            this._getGlobalBoundsRecursive(!!i, e, this.parentRenderLayer),
            e.isValid || e.set(0, 0, 0, 0);
            let t = this.renderGroup || this.parentRenderGroup;
            return e.applyMatrix(t.worldTransform),
            e
        },
        _getGlobalBoundsRecursive(i, e, t) {
            let r = e;
            if (i && this.parentRenderLayer && this.parentRenderLayer !== t || this.localDisplayStatus !== 7 || !this.measurable)
                return;
            let s = !!this.effects.length;
            if ((this.renderGroup || s) && (r = bi.get().clear()),
            this.boundsArea)
                e.addRect(this.boundsArea, this.worldTransform);
            else {
                if (this.renderPipeId) {
                    let a = this.bounds;
                    r.addFrame(a.minX, a.minY, a.maxX, a.maxY, this.groupTransform)
                }
                let n = this.children;
                for (let a = 0; a < n.length; a++)
                    n[a]._getGlobalBoundsRecursive(i, r, t)
            }
            if (s) {
                let n = !1
                  , a = this.renderGroup || this.parentRenderGroup;
                for (let c = 0; c < this.effects.length; c++)
                    this.effects[c].addBounds && (n || (n = !0,
                    r.applyMatrix(a.worldTransform)),
                    this.effects[c].addBounds(r, !0));
                n && r.applyMatrix(a.worldTransform.copyTo(z1).invert()),
                e.addBounds(r),
                bi.return(r)
            } else
                this.renderGroup && (e.addBounds(r, this.relativeGroupTransform),
                bi.return(r))
        }
    };
    function uo(i, e, t) {
        t.clear();
        let r, s;
        return i.parent ? e ? r = i.parent.worldTransform : (s = mt.get().identity(),
        r = Sh(i, s)) : r = ce.IDENTITY,
        zb(i, t, r, e),
        s && mt.return(s),
        t.isValid || t.set(0, 0, 0, 0),
        t
    }
    function zb(i, e, t, r) {
        var s, n;
        if (!i.visible || !i.measurable)
            return;
        let a;
        r ? a = i.worldTransform : (i.updateLocalTransform(),
        a = mt.get(),
        a.appendFrom(i.localTransform, t));
        let c = e
          , l = !!i.effects.length;
        if (l && (e = bi.get().clear()),
        i.boundsArea)
            e.addRect(i.boundsArea, a);
        else {
            let u = i.bounds;
            u && !u.isEmpty() && (e.matrix = a,
            e.addBounds(u));
            for (let d = 0; d < i.children.length; d++)
                zb(i.children[d], e, a, r)
        }
        if (l) {
            for (let u = 0; u < i.effects.length; u++)
                (n = (s = i.effects[u]).addBounds) == null || n.call(s, e);
            c.addBounds(e, ce.IDENTITY),
            bi.return(e)
        }
        r || mt.return(a)
    }
    function Sh(i, e) {
        let t = i.parent;
        return t && (Sh(t, e),
        t.updateLocalTransform(),
        e.append(t.localTransform)),
        e
    }
    function Vb(i, e) {
        if (i === 16777215 || !e)
            return e;
        if (e === 16777215 || !i)
            return i;
        let t = i >> 16 & 255
          , r = i >> 8 & 255
          , s = i & 255
          , n = e >> 16 & 255
          , a = e >> 8 & 255
          , c = e & 255
          , l = t * n / 255 | 0
          , u = r * a / 255 | 0
          , d = s * c / 255 | 0;
        return (l << 16) + (u << 8) + d
    }
    var lu = 16777215;
    function pn(i, e) {
        return i === lu ? e : e === lu ? i : Vb(i, e)
    }
    function ts(i) {
        return ((i & 255) << 16) + (i & 65280) + (i >> 16 & 255)
    }
    var W1 = {
        getGlobalAlpha(i) {
            if (i)
                return this.renderGroup ? this.renderGroup.worldAlpha : this.parentRenderGroup ? this.parentRenderGroup.worldAlpha * this.alpha : this.alpha;
            let e = this.alpha
              , t = this.parent;
            for (; t; )
                e *= t.alpha,
                t = t.parent;
            return e
        },
        getGlobalTransform(i=new ce, e) {
            if (e)
                return i.copyFrom(this.worldTransform);
            this.updateLocalTransform();
            let t = Sh(this, mt.get().identity());
            return i.appendFrom(this.localTransform, t),
            mt.return(t),
            i
        },
        getGlobalTint(i) {
            if (i)
                return this.renderGroup ? ts(this.renderGroup.worldColor) : this.parentRenderGroup ? ts(pn(this.localColor, this.parentRenderGroup.worldColor)) : this.tint;
            let e = this.localColor
              , t = this.parent;
            for (; t; )
                e = pn(e, t.localColor),
                t = t.parent;
            return ts(e)
        }
    };
    function wh(i, e, t) {
        return e.clear(),
        t || (t = ce.IDENTITY),
        Wb(i, e, t, i, !0),
        e.isValid || e.set(0, 0, 0, 0),
        e
    }
    function Wb(i, e, t, r, s) {
        var n, a;
        let c;
        if (s)
            c = mt.get(),
            c = t.copyTo(c);
        else {
            if (!i.visible || !i.measurable)
                return;
            i.updateLocalTransform();
            let d = i.localTransform;
            c = mt.get(),
            c.appendFrom(d, t)
        }
        let l = e
          , u = !!i.effects.length;
        if (u && (e = bi.get().clear()),
        i.boundsArea)
            e.addRect(i.boundsArea, c);
        else {
            i.renderPipeId && (e.matrix = c,
            e.addBounds(i.bounds));
            let d = i.children;
            for (let f = 0; f < d.length; f++)
                Wb(d[f], e, c, r, !1)
        }
        if (u) {
            for (let d = 0; d < i.effects.length; d++)
                (a = (n = i.effects[d]).addLocalBounds) == null || a.call(n, e, r);
            l.addBounds(e, ce.IDENTITY),
            bi.return(e)
        }
        mt.return(c)
    }
    function Yb(i, e) {
        let t = i.children;
        for (let r = 0; r < t.length; r++) {
            let s = t[r]
              , n = s.uid
              , a = (s._didViewChangeTick & 65535) << 16 | s._didContainerChangeTick & 65535
              , c = e.index;
            (e.data[c] !== n || e.data[c + 1] !== a) && (e.data[e.index] = n,
            e.data[e.index + 1] = a,
            e.didChange = !0),
            e.index = c + 2,
            s.children.length && Yb(s, e)
        }
        return e.didChange
    }
    var Y1 = new ce
      , $1 = {
        _localBoundsCacheId: -1,
        _localBoundsCacheData: null,
        _setWidth(i, e) {
            let t = Math.sign(this.scale.x) || 1;
            e !== 0 ? this.scale.x = i / e * t : this.scale.x = t
        },
        _setHeight(i, e) {
            let t = Math.sign(this.scale.y) || 1;
            e !== 0 ? this.scale.y = i / e * t : this.scale.y = t
        },
        getLocalBounds() {
            this._localBoundsCacheData || (this._localBoundsCacheData = {
                data: [],
                index: 1,
                didChange: !1,
                localBounds: new at
            });
            let i = this._localBoundsCacheData;
            return i.index = 1,
            i.didChange = !1,
            i.data[0] !== this._didViewChangeTick && (i.didChange = !0,
            i.data[0] = this._didViewChangeTick),
            Yb(this, i),
            i.didChange && wh(this, i.localBounds, Y1),
            i.localBounds
        },
        getBounds(i, e) {
            return uo(this, i, e || new at)
        }
    }
      , K1 = {
        _onRender: null,
        set onRender(i) {
            let e = this.renderGroup || this.parentRenderGroup;
            if (!i) {
                this._onRender && e?.removeOnRender(this),
                this._onRender = null;
                return
            }
            this._onRender || e == null || e.addOnRender(this),
            this._onRender = i
        },
        get onRender() {
            return this._onRender
        }
    }
      , q1 = {
        _zIndex: 0,
        sortDirty: !1,
        sortableChildren: !1,
        get zIndex() {
            return this._zIndex
        },
        set zIndex(i) {
            this._zIndex !== i && (this._zIndex = i,
            this.depthOfChildModified())
        },
        depthOfChildModified() {
            this.parent && (this.parent.sortableChildren = !0,
            this.parent.sortDirty = !0),
            this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0)
        },
        sortChildren() {
            this.sortDirty && (this.sortDirty = !1,
            this.children.sort(Z1))
        }
    };
    function Z1(i, e) {
        return i._zIndex - e._zIndex
    }
    var Q1 = {
        getGlobalPosition(i=new Ne, e=!1) {
            return this.parent ? this.parent.toGlobal(this._position, i, e) : (i.x = this._position.x,
            i.y = this._position.y),
            i
        },
        toGlobal(i, e, t=!1) {
            let r = this.getGlobalTransform(mt.get(), t);
            return e = r.apply(i, e),
            mt.return(r),
            e
        },
        toLocal(i, e, t, r) {
            e && (i = e.toGlobal(i, t, r));
            let s = this.getGlobalTransform(mt.get(), r);
            return t = s.applyInverse(i, t),
            mt.return(s),
            t
        }
    }
      , bn = class {
        constructor() {
            this.uid = Xe("instructionSet"),
            this.instructions = [],
            this.instructionSize = 0,
            this.renderables = [],
            this.gcTick = 0
        }
        reset() {
            this.instructionSize = 0
        }
        destroy() {
            this.instructions.length = 0,
            this.renderables.length = 0,
            this.renderPipes = null,
            this.gcTick = 0
        }
        add(e) {
            this.instructions[this.instructionSize++] = e
        }
        log() {
            this.instructions.length = this.instructionSize
        }
    }
    ;
    function Sr(i) {
        return i += i === 0 ? 1 : 0,
        --i,
        i |= i >>> 1,
        i |= i >>> 2,
        i |= i >>> 4,
        i |= i >>> 8,
        i |= i >>> 16,
        i + 1
    }
    function hu(i) {
        return !(i & i - 1) && !!i
    }
    function wr(i) {
        let e = {};
        for (let t in i)
            i[t] !== void 0 && (e[t] = i[t]);
        return e
    }
    var J1 = Object.defineProperty
      , uu = Object.getOwnPropertySymbols
      , e_ = Object.prototype.hasOwnProperty
      , t_ = Object.prototype.propertyIsEnumerable
      , du = (i, e, t) => e in i ? J1(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , fu = (i, e) => {
        for (var t in e || (e = {}))
            e_.call(e, t) && du(i, t, e[t]);
        if (uu)
            for (var t of uu(e))
                t_.call(e, t) && du(i, t, e[t]);
        return i
    }
      , pu = Object.create(null);
    function i_(i) {
        let e = pu[i];
        return e === void 0 && (pu[i] = Xe("resource")),
        e
    }
    var $b = class Kb extends Ft {
        constructor(e={}) {
            var t, r, s, n, a, c, l;
            super(),
            this._resourceType = "textureSampler",
            this._touched = 0,
            this._maxAnisotropy = 1,
            this.destroyed = !1,
            e = fu(fu({}, Kb.defaultOptions), e),
            this.addressMode = e.addressMode,
            this.addressModeU = (t = e.addressModeU) != null ? t : this.addressModeU,
            this.addressModeV = (r = e.addressModeV) != null ? r : this.addressModeV,
            this.addressModeW = (s = e.addressModeW) != null ? s : this.addressModeW,
            this.scaleMode = e.scaleMode,
            this.magFilter = (n = e.magFilter) != null ? n : this.magFilter,
            this.minFilter = (a = e.minFilter) != null ? a : this.minFilter,
            this.mipmapFilter = (c = e.mipmapFilter) != null ? c : this.mipmapFilter,
            this.lodMinClamp = e.lodMinClamp,
            this.lodMaxClamp = e.lodMaxClamp,
            this.compare = e.compare,
            this.maxAnisotropy = (l = e.maxAnisotropy) != null ? l : 1
        }
        set addressMode(e) {
            this.addressModeU = e,
            this.addressModeV = e,
            this.addressModeW = e
        }
        get addressMode() {
            return this.addressModeU
        }
        set wrapMode(e) {
            this.addressMode = e
        }
        get wrapMode() {
            return this.addressMode
        }
        set scaleMode(e) {
            this.magFilter = e,
            this.minFilter = e,
            this.mipmapFilter = e
        }
        get scaleMode() {
            return this.magFilter
        }
        set maxAnisotropy(e) {
            this._maxAnisotropy = Math.min(e, 16),
            this._maxAnisotropy > 1 && (this.scaleMode = "linear")
        }
        get maxAnisotropy() {
            return this._maxAnisotropy
        }
        get _resourceId() {
            return this._sharedResourceId || this._generateResourceId()
        }
        update() {
            this.emit("change", this),
            this._sharedResourceId = null
        }
        _generateResourceId() {
            let e = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
            return this._sharedResourceId = i_(e),
            this._resourceId
        }
        destroy() {
            this.destroyed = !0,
            this.emit("destroy", this),
            this.emit("change", this),
            this.removeAllListeners()
        }
    }
    ;
    $b.defaultOptions = {
        addressMode: "clamp-to-edge",
        scaleMode: "linear"
    };
    var Lt = $b
      , r_ = Object.defineProperty
      , bu = Object.getOwnPropertySymbols
      , s_ = Object.prototype.hasOwnProperty
      , n_ = Object.prototype.propertyIsEnumerable
      , mu = (i, e, t) => e in i ? r_(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , gu = (i, e) => {
        for (var t in e || (e = {}))
            s_.call(e, t) && mu(i, t, e[t]);
        if (bu)
            for (var t of bu(e))
                n_.call(e, t) && mu(i, t, e[t]);
        return i
    }
      , qb = class Zb extends Ft {
        constructor(e={}) {
            var t, r, s;
            super(),
            this.options = e,
            this.uid = Xe("textureSource"),
            this._resourceType = "textureSource",
            this._resourceId = Xe("resource"),
            this.uploadMethodId = "unknown",
            this._resolution = 1,
            this.pixelWidth = 1,
            this.pixelHeight = 1,
            this.width = 1,
            this.height = 1,
            this.sampleCount = 1,
            this.mipLevelCount = 1,
            this.autoGenerateMipmaps = !1,
            this.format = "rgba8unorm",
            this.dimension = "2d",
            this.antialias = !1,
            this._touched = 0,
            this._batchTick = -1,
            this._textureBindLocation = -1,
            e = gu(gu({}, Zb.defaultOptions), e),
            this.label = (t = e.label) != null ? t : "",
            this.resource = e.resource,
            this.autoGarbageCollect = e.autoGarbageCollect,
            this._resolution = e.resolution,
            e.width ? this.pixelWidth = e.width * this._resolution : this.pixelWidth = this.resource && (r = this.resourceWidth) != null ? r : 1,
            e.height ? this.pixelHeight = e.height * this._resolution : this.pixelHeight = this.resource && (s = this.resourceHeight) != null ? s : 1,
            this.width = this.pixelWidth / this._resolution,
            this.height = this.pixelHeight / this._resolution,
            this.format = e.format,
            this.dimension = e.dimensions,
            this.mipLevelCount = e.mipLevelCount,
            this.autoGenerateMipmaps = e.autoGenerateMipmaps,
            this.sampleCount = e.sampleCount,
            this.antialias = e.antialias,
            this.alphaMode = e.alphaMode,
            this.style = new Lt(wr(e)),
            this.destroyed = !1,
            this._refreshPOT()
        }
        get source() {
            return this
        }
        get style() {
            return this._style
        }
        set style(e) {
            var t, r;
            this.style !== e && ((t = this._style) == null || t.off("change", this._onStyleChange, this),
            this._style = e,
            (r = this._style) == null || r.on("change", this._onStyleChange, this),
            this._onStyleChange())
        }
        set maxAnisotropy(e) {
            this._style.maxAnisotropy = e
        }
        get maxAnisotropy() {
            return this._style.maxAnisotropy
        }
        get addressMode() {
            return this._style.addressMode
        }
        set addressMode(e) {
            this._style.addressMode = e
        }
        get repeatMode() {
            return this._style.addressMode
        }
        set repeatMode(e) {
            this._style.addressMode = e
        }
        get magFilter() {
            return this._style.magFilter
        }
        set magFilter(e) {
            this._style.magFilter = e
        }
        get minFilter() {
            return this._style.minFilter
        }
        set minFilter(e) {
            this._style.minFilter = e
        }
        get mipmapFilter() {
            return this._style.mipmapFilter
        }
        set mipmapFilter(e) {
            this._style.mipmapFilter = e
        }
        get lodMinClamp() {
            return this._style.lodMinClamp
        }
        set lodMinClamp(e) {
            this._style.lodMinClamp = e
        }
        get lodMaxClamp() {
            return this._style.lodMaxClamp
        }
        set lodMaxClamp(e) {
            this._style.lodMaxClamp = e
        }
        _onStyleChange() {
            this.emit("styleChange", this)
        }
        update() {
            if (this.resource) {
                let e = this._resolution;
                if (this.resize(this.resourceWidth / e, this.resourceHeight / e))
                    return
            }
            this.emit("update", this)
        }
        destroy() {
            this.destroyed = !0,
            this.emit("destroy", this),
            this.emit("change", this),
            this._style && (this._style.destroy(),
            this._style = null),
            this.uploadMethodId = null,
            this.resource = null,
            this.removeAllListeners()
        }
        unload() {
            this._resourceId = Xe("resource"),
            this.emit("change", this),
            this.emit("unload", this)
        }
        get resourceWidth() {
            let {resource: e} = this;
            return e.naturalWidth || e.videoWidth || e.displayWidth || e.width
        }
        get resourceHeight() {
            let {resource: e} = this;
            return e.naturalHeight || e.videoHeight || e.displayHeight || e.height
        }
        get resolution() {
            return this._resolution
        }
        set resolution(e) {
            this._resolution !== e && (this._resolution = e,
            this.width = this.pixelWidth / e,
            this.height = this.pixelHeight / e)
        }
        resize(e, t, r) {
            r || (r = this._resolution),
            e || (e = this.width),
            t || (t = this.height);
            let s = Math.round(e * r)
              , n = Math.round(t * r);
            return this.width = s / r,
            this.height = n / r,
            this._resolution = r,
            this.pixelWidth === s && this.pixelHeight === n ? !1 : (this._refreshPOT(),
            this.pixelWidth = s,
            this.pixelHeight = n,
            this.emit("resize", this),
            this._resourceId = Xe("resource"),
            this.emit("change", this),
            !0)
        }
        updateMipmaps() {
            this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this)
        }
        set wrapMode(e) {
            this._style.wrapMode = e
        }
        get wrapMode() {
            return this._style.wrapMode
        }
        set scaleMode(e) {
            this._style.scaleMode = e
        }
        get scaleMode() {
            return this._style.scaleMode
        }
        _refreshPOT() {
            this.isPowerOfTwo = hu(this.pixelWidth) && hu(this.pixelHeight)
        }
        static test(e) {
            throw new Error("Unimplemented")
        }
    }
    ;
    qb.defaultOptions = {
        resolution: 1,
        format: "bgra8unorm",
        alphaMode: "premultiply-alpha-on-upload",
        dimensions: "2d",
        mipLevelCount: 1,
        autoGenerateMipmaps: !1,
        sampleCount: 1,
        antialias: !1,
        autoGarbageCollect: !1
    };
    var He = qb
      , Wi = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]
      , Yi = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1]
      , $i = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1]
      , Ki = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1]
      , Bc = []
      , Qb = []
      , Xs = Math.sign;
    function a_() {
        for (let i = 0; i < 16; i++) {
            let e = [];
            Bc.push(e);
            for (let t = 0; t < 16; t++) {
                let r = Xs(Wi[i] * Wi[t] + $i[i] * Yi[t])
                  , s = Xs(Yi[i] * Wi[t] + Ki[i] * Yi[t])
                  , n = Xs(Wi[i] * $i[t] + $i[i] * Ki[t])
                  , a = Xs(Yi[i] * $i[t] + Ki[i] * Ki[t]);
                for (let c = 0; c < 16; c++)
                    if (Wi[c] === r && Yi[c] === s && $i[c] === n && Ki[c] === a) {
                        e.push(c);
                        break
                    }
            }
        }
        for (let i = 0; i < 16; i++) {
            let e = new ce;
            e.set(Wi[i], Yi[i], $i[i], Ki[i], 0, 0),
            Qb.push(e)
        }
    }
    a_();
    var De = {
        E: 0,
        SE: 1,
        S: 2,
        SW: 3,
        W: 4,
        NW: 5,
        N: 6,
        NE: 7,
        MIRROR_VERTICAL: 8,
        MAIN_DIAGONAL: 10,
        MIRROR_HORIZONTAL: 12,
        REVERSE_DIAGONAL: 14,
        uX: i => Wi[i],
        uY: i => Yi[i],
        vX: i => $i[i],
        vY: i => Ki[i],
        inv: i => i & 8 ? i & 15 : -i & 7,
        add: (i, e) => Bc[i][e],
        sub: (i, e) => Bc[i][De.inv(e)],
        rotate180: i => i ^ 4,
        isVertical: i => (i & 3) === 2,
        byDirection: (i, e) => Math.abs(i) * 2 <= Math.abs(e) ? e >= 0 ? De.S : De.N : Math.abs(e) * 2 <= Math.abs(i) ? i > 0 ? De.E : De.W : e > 0 ? i > 0 ? De.SE : De.SW : i > 0 ? De.NE : De.NW,
        matrixAppendRotationInv: (i, e, t=0, r=0) => {
            let s = Qb[De.inv(e)];
            s.tx = t,
            s.ty = r,
            i.append(s)
        }
        ,
        transformRectCoords: (i, e, t, r) => {
            let {x: s, y: n, width: a, height: c} = i
              , {x: l, y: u, width: d, height: f} = e;
            return t === De.E ? (r.set(s + l, n + u, a, c),
            r) : t === De.S ? r.set(d - n - c + l, s + u, c, a) : t === De.W ? r.set(d - s - a + l, f - n - c + u, a, c) : t === De.N ? r.set(n + l, f - s - a + u, c, a) : r.set(s + l, n + u, a, c)
        }
    }
      , _u = () => {}
      , o_ = Object.defineProperty
      , c_ = Object.defineProperties
      , l_ = Object.getOwnPropertyDescriptors
      , xu = Object.getOwnPropertySymbols
      , h_ = Object.prototype.hasOwnProperty
      , u_ = Object.prototype.propertyIsEnumerable
      , yu = (i, e, t) => e in i ? o_(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , d_ = (i, e) => {
        for (var t in e || (e = {}))
            h_.call(e, t) && yu(i, t, e[t]);
        if (xu)
            for (var t of xu(e))
                u_.call(e, t) && yu(i, t, e[t]);
        return i
    }
      , f_ = (i, e) => c_(i, l_(e))
      , us = class extends He {
        constructor(e) {
            let t = e.resource || new Float32Array(e.width * e.height * 4)
              , r = e.format;
            r || (t instanceof Float32Array ? r = "rgba32float" : t instanceof Int32Array || t instanceof Uint32Array ? r = "rgba32uint" : t instanceof Int16Array || t instanceof Uint16Array ? r = "rgba16uint" : (t instanceof Int8Array,
            r = "bgra8unorm")),
            super(f_(d_({}, e), {
                resource: t,
                format: r
            })),
            this.uploadMethodId = "buffer"
        }
        static test(e) {
            return e instanceof Int8Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array
        }
    }
    ;
    us.extension = B.TextureSource;
    var vu = new ce
      , mn = class {
        constructor(e, t) {
            this.mapCoord = new ce,
            this.uClampFrame = new Float32Array(4),
            this.uClampOffset = new Float32Array(2),
            this._textureID = -1,
            this._updateID = 0,
            this.clampOffset = 0,
            typeof t > "u" ? this.clampMargin = e.width < 10 ? 0 : .5 : this.clampMargin = t,
            this.isSimple = !1,
            this.texture = e
        }
        get texture() {
            return this._texture
        }
        set texture(e) {
            var t;
            this.texture !== e && ((t = this._texture) == null || t.removeListener("update", this.update, this),
            this._texture = e,
            this._texture.addListener("update", this.update, this),
            this.update())
        }
        multiplyUvs(e, t) {
            t === void 0 && (t = e);
            let r = this.mapCoord;
            for (let s = 0; s < e.length; s += 2) {
                let n = e[s]
                  , a = e[s + 1];
                t[s] = n * r.a + a * r.c + r.tx,
                t[s + 1] = n * r.b + a * r.d + r.ty
            }
            return t
        }
        update() {
            let e = this._texture;
            this._updateID++;
            let t = e.uvs;
            this.mapCoord.set(t.x1 - t.x0, t.y1 - t.y0, t.x3 - t.x0, t.y3 - t.y0, t.x0, t.y0);
            let r = e.orig
              , s = e.trim;
            s && (vu.set(r.width / s.width, 0, 0, r.height / s.height, -s.x / s.width, -s.y / s.height),
            this.mapCoord.append(vu));
            let n = e.source
              , a = this.uClampFrame
              , c = this.clampMargin / n._resolution
              , l = this.clampOffset / n._resolution;
            return a[0] = (e.frame.x + c + l) / n.width,
            a[1] = (e.frame.y + c + l) / n.height,
            a[2] = (e.frame.x + e.frame.width - c + l) / n.width,
            a[3] = (e.frame.y + e.frame.height - c + l) / n.height,
            this.uClampOffset[0] = this.clampOffset / n.pixelWidth,
            this.uClampOffset[1] = this.clampOffset / n.pixelHeight,
            this.isSimple = e.frame.width === n.width && e.frame.height === n.height && e.rotate === 0,
            !0
        }
    }
      , Z = class extends Ft {
        constructor({source: e, label: t, frame: r, orig: s, trim: n, defaultAnchor: a, defaultBorders: c, rotate: l, dynamic: u}={}) {
            var d;
            if (super(),
            this.uid = Xe("texture"),
            this.uvs = {
                x0: 0,
                y0: 0,
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                x3: 0,
                y3: 0
            },
            this.frame = new Re,
            this.noFrame = !1,
            this.dynamic = !1,
            this.isTexture = !0,
            this.label = t,
            this.source = (d = e?.source) != null ? d : new He,
            this.noFrame = !r,
            r)
                this.frame.copyFrom(r);
            else {
                let {width: f, height: b} = this._source;
                this.frame.width = f,
                this.frame.height = b
            }
            this.orig = s || this.frame,
            this.trim = n,
            this.rotate = l ?? 0,
            this.defaultAnchor = a,
            this.defaultBorders = c,
            this.destroyed = !1,
            this.dynamic = u || !1,
            this.updateUvs()
        }
        set source(e) {
            this._source && this._source.off("resize", this.update, this),
            this._source = e,
            e.on("resize", this.update, this),
            this.emit("update", this)
        }
        get source() {
            return this._source
        }
        get textureMatrix() {
            return this._textureMatrix || (this._textureMatrix = new mn(this)),
            this._textureMatrix
        }
        get width() {
            return this.orig.width
        }
        get height() {
            return this.orig.height
        }
        updateUvs() {
            let {uvs: e, frame: t} = this
              , {width: r, height: s} = this._source
              , n = t.x / r
              , a = t.y / s
              , c = t.width / r
              , l = t.height / s
              , u = this.rotate;
            if (u) {
                let d = c / 2
                  , f = l / 2
                  , b = n + d
                  , m = a + f;
                u = De.add(u, De.NW),
                e.x0 = b + d * De.uX(u),
                e.y0 = m + f * De.uY(u),
                u = De.add(u, 2),
                e.x1 = b + d * De.uX(u),
                e.y1 = m + f * De.uY(u),
                u = De.add(u, 2),
                e.x2 = b + d * De.uX(u),
                e.y2 = m + f * De.uY(u),
                u = De.add(u, 2),
                e.x3 = b + d * De.uX(u),
                e.y3 = m + f * De.uY(u)
            } else
                e.x0 = n,
                e.y0 = a,
                e.x1 = n + c,
                e.y1 = a,
                e.x2 = n + c,
                e.y2 = a + l,
                e.x3 = n,
                e.y3 = a + l
        }
        destroy(e=!1) {
            this._source && e && (this._source.destroy(),
            this._source = null),
            this._textureMatrix = null,
            this.destroyed = !0,
            this.emit("destroy", this),
            this.removeAllListeners()
        }
        update() {
            this.noFrame && (this.frame.width = this._source.width,
            this.frame.height = this._source.height),
            this.updateUvs(),
            this.emit("update", this)
        }
        get baseTexture() {
            return this._source
        }
    }
    ;
    Z.EMPTY = new Z({
        label: "EMPTY",
        source: new He({
            label: "EMPTY"
        })
    }),
    Z.EMPTY.destroy = _u,
    Z.WHITE = new Z({
        source: new us({
            resource: new Uint8Array([255, 255, 255, 255]),
            width: 1,
            height: 1,
            alphaMode: "premultiply-alpha-on-upload",
            label: "WHITE"
        }),
        label: "WHITE"
    }),
    Z.WHITE.destroy = _u;
    var p_ = Object.defineProperty
      , b_ = Object.defineProperties
      , m_ = Object.getOwnPropertyDescriptors
      , Tu = Object.getOwnPropertySymbols
      , g_ = Object.prototype.hasOwnProperty
      , __ = Object.prototype.propertyIsEnumerable
      , Su = (i, e, t) => e in i ? p_(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , x_ = (i, e) => {
        for (var t in e || (e = {}))
            g_.call(e, t) && Su(i, t, e[t]);
        if (Tu)
            for (var t of Tu(e))
                __.call(e, t) && Su(i, t, e[t]);
        return i
    }
      , y_ = (i, e) => b_(i, m_(e))
      , v_ = 0
      , Fc = class {
        constructor(e) {
            this._poolKeyHash = Object.create(null),
            this._texturePool = {},
            this.textureOptions = e || {},
            this.enableFullScreen = !1,
            this.textureStyle = new Lt(this.textureOptions)
        }
        createTexture(e, t, r) {
            let s = new He(y_(x_({}, this.textureOptions), {
                width: e,
                height: t,
                resolution: 1,
                antialias: r,
                autoGarbageCollect: !1
            }));
            return new Z({
                source: s,
                label: `texturePool_${v_++}`
            })
        }
        getOptimalTexture(e, t, r=1, s) {
            let n = Math.ceil(e * r - 1e-6)
              , a = Math.ceil(t * r - 1e-6);
            n = Sr(n),
            a = Sr(a);
            let c = (n << 17) + (a << 1) + (s ? 1 : 0);
            this._texturePool[c] || (this._texturePool[c] = []);
            let l = this._texturePool[c].pop();
            return l || (l = this.createTexture(n, a, s)),
            l.source._resolution = r,
            l.source.width = n / r,
            l.source.height = a / r,
            l.source.pixelWidth = n,
            l.source.pixelHeight = a,
            l.frame.x = 0,
            l.frame.y = 0,
            l.frame.width = e,
            l.frame.height = t,
            l.updateUvs(),
            this._poolKeyHash[l.uid] = c,
            l
        }
        getSameSizeTexture(e, t=!1) {
            let r = e.source;
            return this.getOptimalTexture(e.width, e.height, r._resolution, t)
        }
        returnTexture(e, t=!1) {
            let r = this._poolKeyHash[e.uid];
            t && (e.source.style = this.textureStyle),
            this._texturePool[r].push(e)
        }
        clear(e) {
            if (e = e !== !1,
            e)
                for (let t in this._texturePool) {
                    let r = this._texturePool[t];
                    if (r)
                        for (let s = 0; s < r.length; s++)
                            r[s].destroy(!0)
                }
            this._texturePool = {}
        }
    }
      , Qe = new Fc;
    Cr.register(Qe);
    var ds = class {
        constructor() {
            this.renderPipeId = "renderGroup",
            this.root = null,
            this.canBundle = !1,
            this.renderGroupParent = null,
            this.renderGroupChildren = [],
            this.worldTransform = new ce,
            this.worldColorAlpha = 4294967295,
            this.worldColor = 16777215,
            this.worldAlpha = 1,
            this.childrenToUpdate = Object.create(null),
            this.updateTick = 0,
            this.gcTick = 0,
            this.childrenRenderablesToUpdate = {
                list: [],
                index: 0
            },
            this.structureDidChange = !0,
            this.instructionSet = new bn,
            this._onRenderContainers = [],
            this.textureNeedsUpdate = !0,
            this.isCachedAsTexture = !1,
            this._matrixDirty = 7
        }
        init(e) {
            this.root = e,
            e._onRender && this.addOnRender(e),
            e.didChange = !0;
            let t = e.children;
            for (let r = 0; r < t.length; r++) {
                let s = t[r];
                s._updateFlags = 15,
                this.addChild(s)
            }
        }
        enableCacheAsTexture(e={}) {
            this.textureOptions = e,
            this.isCachedAsTexture = !0,
            this.textureNeedsUpdate = !0
        }
        disableCacheAsTexture() {
            this.isCachedAsTexture = !1,
            this.texture && (Qe.returnTexture(this.texture, !0),
            this.texture = null)
        }
        updateCacheTexture() {
            this.textureNeedsUpdate = !0;
            let e = this._parentCacheAsTextureRenderGroup;
            e && !e.textureNeedsUpdate && e.updateCacheTexture()
        }
        reset() {
            this.renderGroupChildren.length = 0;
            for (let e in this.childrenToUpdate) {
                let t = this.childrenToUpdate[e];
                t.list.fill(null),
                t.index = 0
            }
            this.childrenRenderablesToUpdate.index = 0,
            this.childrenRenderablesToUpdate.list.fill(null),
            this.root = null,
            this.updateTick = 0,
            this.structureDidChange = !0,
            this._onRenderContainers.length = 0,
            this.renderGroupParent = null,
            this.disableCacheAsTexture()
        }
        get localTransform() {
            return this.root.localTransform
        }
        addRenderGroupChild(e) {
            e.renderGroupParent && e.renderGroupParent._removeRenderGroupChild(e),
            e.renderGroupParent = this,
            this.renderGroupChildren.push(e)
        }
        _removeRenderGroupChild(e) {
            let t = this.renderGroupChildren.indexOf(e);
            t > -1 && this.renderGroupChildren.splice(t, 1),
            e.renderGroupParent = null
        }
        addChild(e) {
            if (this.structureDidChange = !0,
            e.parentRenderGroup = this,
            e.updateTick = -1,
            e.parent === this.root ? e.relativeRenderGroupDepth = 1 : e.relativeRenderGroupDepth = e.parent.relativeRenderGroupDepth + 1,
            e.didChange = !0,
            this.onChildUpdate(e),
            e.renderGroup) {
                this.addRenderGroupChild(e.renderGroup);
                return
            }
            e._onRender && this.addOnRender(e);
            let t = e.children;
            for (let r = 0; r < t.length; r++)
                this.addChild(t[r])
        }
        removeChild(e) {
            if (this.structureDidChange = !0,
            e._onRender && (e.renderGroup || this.removeOnRender(e)),
            e.parentRenderGroup = null,
            e.renderGroup) {
                this._removeRenderGroupChild(e.renderGroup);
                return
            }
            let t = e.children;
            for (let r = 0; r < t.length; r++)
                this.removeChild(t[r])
        }
        removeChildren(e) {
            for (let t = 0; t < e.length; t++)
                this.removeChild(e[t])
        }
        onChildUpdate(e) {
            let t = this.childrenToUpdate[e.relativeRenderGroupDepth];
            t || (t = this.childrenToUpdate[e.relativeRenderGroupDepth] = {
                index: 0,
                list: []
            }),
            t.list[t.index++] = e
        }
        updateRenderable(e) {
            e.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[e.renderPipeId].updateRenderable(e),
            e.didViewUpdate = !1)
        }
        onChildViewUpdate(e) {
            this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = e
        }
        get isRenderable() {
            return this.root.localDisplayStatus === 7 && this.worldAlpha > 0
        }
        addOnRender(e) {
            this._onRenderContainers.push(e)
        }
        removeOnRender(e) {
            this._onRenderContainers.splice(this._onRenderContainers.indexOf(e), 1)
        }
        runOnRender(e) {
            for (let t = 0; t < this._onRenderContainers.length; t++)
                this._onRenderContainers[t]._onRender(e)
        }
        destroy() {
            this.disableCacheAsTexture(),
            this.renderGroupParent = null,
            this.root = null,
            this.childrenRenderablesToUpdate = null,
            this.childrenToUpdate = null,
            this.renderGroupChildren = null,
            this._onRenderContainers = null,
            this.instructionSet = null
        }
        getChildren(e=[]) {
            let t = this.root.children;
            for (let r = 0; r < t.length; r++)
                this._getChildren(t[r], e);
            return e
        }
        _getChildren(e, t=[]) {
            if (t.push(e),
            e.renderGroup)
                return t;
            let r = e.children;
            for (let s = 0; s < r.length; s++)
                this._getChildren(r[s], t);
            return t
        }
        invalidateMatrices() {
            this._matrixDirty = 7
        }
        get inverseWorldTransform() {
            return this._matrixDirty & 1 ? (this._matrixDirty &= -2,
            this._inverseWorldTransform || (this._inverseWorldTransform = new ce),
            this._inverseWorldTransform.copyFrom(this.worldTransform).invert()) : this._inverseWorldTransform
        }
        get textureOffsetInverseTransform() {
            return this._matrixDirty & 2 ? (this._matrixDirty &= -3,
            this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new ce),
            this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x, -this._textureBounds.y)) : this._textureOffsetInverseTransform
        }
        get inverseParentTextureTransform() {
            if (!(this._matrixDirty & 4))
                return this._inverseParentTextureTransform;
            this._matrixDirty &= -5;
            let e = this._parentCacheAsTextureRenderGroup;
            return e ? (this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new ce),
            this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(e.inverseWorldTransform).translate(-e._textureBounds.x, -e._textureBounds.y)) : this.worldTransform
        }
        get cacheToLocalTransform() {
            return this.isCachedAsTexture ? this.textureOffsetInverseTransform : this._parentCacheAsTextureRenderGroup ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform : null
        }
    }
    ;
    function Dc(i, e, t={}) {
        for (let r in e)
            !t[r] && e[r] !== void 0 && (i[r] = e[r])
    }
    var Co = new We(null)
      , Oo = new We(null)
      , Io = new We(null,1,1)
      , Go = new We(null)
      , gn = 1
      , Ah = 2
      , is = 4;
    var _e = class i extends Ft {
        constructor(e={}) {
            var t, r;
            super(),
            this.uid = Xe("renderable"),
            this._updateFlags = 15,
            this.renderGroup = null,
            this.parentRenderGroup = null,
            this.parentRenderGroupIndex = 0,
            this.didChange = !1,
            this.didViewUpdate = !1,
            this.relativeRenderGroupDepth = 0,
            this.children = [],
            this.parent = null,
            this.includeInBuild = !0,
            this.measurable = !0,
            this.isSimple = !0,
            this.updateTick = -1,
            this.localTransform = new ce,
            this.relativeGroupTransform = new ce,
            this.groupTransform = this.relativeGroupTransform,
            this.destroyed = !1,
            this._position = new We(this,0,0),
            this._scale = Io,
            this._pivot = Oo,
            this._origin = Go,
            this._skew = Co,
            this._cx = 1,
            this._sx = 0,
            this._cy = 0,
            this._sy = 1,
            this._rotation = 0,
            this.localColor = 16777215,
            this.localAlpha = 1,
            this.groupAlpha = 1,
            this.groupColor = 16777215,
            this.groupColorAlpha = 4294967295,
            this.localBlendMode = "inherit",
            this.groupBlendMode = "normal",
            this.localDisplayStatus = 7,
            this.globalDisplayStatus = 7,
            this._didContainerChangeTick = 0,
            this._didViewChangeTick = 0,
            this._didLocalTransformChangeId = -1,
            this.effects = [],
            Dc(this, e, {
                children: !0,
                parent: !0,
                effects: !0
            }),
            (t = e.children) == null || t.forEach(s => this.addChild(s)),
            (r = e.parent) == null || r.addChild(this)
        }
        static mixin(e) {
            be.mixin(i, e)
        }
        set _didChangeId(e) {
            this._didViewChangeTick = e >> 12 & 4095,
            this._didContainerChangeTick = e & 4095
        }
        get _didChangeId() {
            return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12
        }
        addChild(...e) {
            if (e.length > 1) {
                for (let s = 0; s < e.length; s++)
                    this.addChild(e[s]);
                return e[0]
            }
            let t = e[0]
              , r = this.renderGroup || this.parentRenderGroup;
            return t.parent === this ? (this.children.splice(this.children.indexOf(t), 1),
            this.children.push(t),
            r && (r.structureDidChange = !0),
            t) : (t.parent && t.parent.removeChild(t),
            this.children.push(t),
            this.sortableChildren && (this.sortDirty = !0),
            t.parent = this,
            t.didChange = !0,
            t._updateFlags = 15,
            r && r.addChild(t),
            this.emit("childAdded", t, this, this.children.length - 1),
            t.emit("added", this),
            this._didViewChangeTick++,
            t._zIndex !== 0 && t.depthOfChildModified(),
            t)
        }
        removeChild(...e) {
            if (e.length > 1) {
                for (let s = 0; s < e.length; s++)
                    this.removeChild(e[s]);
                return e[0]
            }
            let t = e[0]
              , r = this.children.indexOf(t);
            return r > -1 && (this._didViewChangeTick++,
            this.children.splice(r, 1),
            this.renderGroup ? this.renderGroup.removeChild(t) : this.parentRenderGroup && this.parentRenderGroup.removeChild(t),
            t.parentRenderLayer && t.parentRenderLayer.detach(t),
            t.parent = null,
            this.emit("childRemoved", t, this, r),
            t.emit("removed", this)),
            t
        }
        _onUpdate(e) {
            e && e === this._skew && this._updateSkew(),
            this._didContainerChangeTick++,
            !this.didChange && (this.didChange = !0,
            this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this))
        }
        set isRenderGroup(e) {
            !!this.renderGroup !== e && (e ? this.enableRenderGroup() : this.disableRenderGroup())
        }
        get isRenderGroup() {
            return !!this.renderGroup
        }
        enableRenderGroup() {
            if (this.renderGroup)
                return;
            let e = this.parentRenderGroup;
            e?.removeChild(this),
            this.renderGroup = et.get(ds, this),
            this.groupTransform = ce.IDENTITY,
            e?.addChild(this),
            this._updateIsSimple()
        }
        disableRenderGroup() {
            if (!this.renderGroup)
                return;
            let e = this.parentRenderGroup;
            e?.removeChild(this),
            et.return(this.renderGroup),
            this.renderGroup = null,
            this.groupTransform = this.relativeGroupTransform,
            e?.addChild(this),
            this._updateIsSimple()
        }
        _updateIsSimple() {
            this.isSimple = !this.renderGroup && this.effects.length === 0
        }
        get worldTransform() {
            return this._worldTransform || (this._worldTransform = new ce),
            this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform),
            this._worldTransform
        }
        get x() {
            return this._position.x
        }
        set x(e) {
            this._position.x = e
        }
        get y() {
            return this._position.y
        }
        set y(e) {
            this._position.y = e
        }
        get position() {
            return this._position
        }
        set position(e) {
            this._position.copyFrom(e)
        }
        get rotation() {
            return this._rotation
        }
        set rotation(e) {
            this._rotation !== e && (this._rotation = e,
            this._onUpdate(this._skew))
        }
        get angle() {
            return this.rotation * I1
        }
        set angle(e) {
            this.rotation = e * G1
        }
        get pivot() {
            return this._pivot === Oo && (this._pivot = new We(this,0,0)),
            this._pivot
        }
        set pivot(e) {
            this._pivot === Oo && (this._pivot = new We(this,0,0)),
            typeof e == "number" ? this._pivot.set(e) : this._pivot.copyFrom(e)
        }
        get skew() {
            return this._skew === Co && (this._skew = new We(this,0,0)),
            this._skew
        }
        set skew(e) {
            this._skew === Co && (this._skew = new We(this,0,0)),
            this._skew.copyFrom(e)
        }
        get scale() {
            return this._scale === Io && (this._scale = new We(this,1,1)),
            this._scale
        }
        set scale(e) {
            this._scale === Io && (this._scale = new We(this,0,0)),
            typeof e == "string" && (e = parseFloat(e)),
            typeof e == "number" ? this._scale.set(e) : this._scale.copyFrom(e)
        }
        get origin() {
            return this._origin === Go && (this._origin = new We(this,0,0)),
            this._origin
        }
        set origin(e) {
            this._origin === Go && (this._origin = new We(this,0,0)),
            typeof e == "number" ? this._origin.set(e) : this._origin.copyFrom(e)
        }
        get width() {
            return Math.abs(this.scale.x * this.getLocalBounds().width)
        }
        set width(e) {
            let t = this.getLocalBounds().width;
            this._setWidth(e, t)
        }
        get height() {
            return Math.abs(this.scale.y * this.getLocalBounds().height)
        }
        set height(e) {
            let t = this.getLocalBounds().height;
            this._setHeight(e, t)
        }
        getSize(e) {
            e || (e = {});
            let t = this.getLocalBounds();
            return e.width = Math.abs(this.scale.x * t.width),
            e.height = Math.abs(this.scale.y * t.height),
            e
        }
        setSize(e, t) {
            var r;
            let s = this.getLocalBounds();
            typeof e == "object" ? (t = (r = e.height) != null ? r : e.width,
            e = e.width) : t != null || (t = e),
            e !== void 0 && this._setWidth(e, s.width),
            t !== void 0 && this._setHeight(t, s.height)
        }
        _updateSkew() {
            let e = this._rotation
              , t = this._skew;
            this._cx = Math.cos(e + t._y),
            this._sx = Math.sin(e + t._y),
            this._cy = -Math.sin(e - t._x),
            this._sy = Math.cos(e - t._x)
        }
        updateTransform(e) {
            return this.position.set(typeof e.x == "number" ? e.x : this.position.x, typeof e.y == "number" ? e.y : this.position.y),
            this.scale.set(typeof e.scaleX == "number" ? e.scaleX || 1 : this.scale.x, typeof e.scaleY == "number" ? e.scaleY || 1 : this.scale.y),
            this.rotation = typeof e.rotation == "number" ? e.rotation : this.rotation,
            this.skew.set(typeof e.skewX == "number" ? e.skewX : this.skew.x, typeof e.skewY == "number" ? e.skewY : this.skew.y),
            this.pivot.set(typeof e.pivotX == "number" ? e.pivotX : this.pivot.x, typeof e.pivotY == "number" ? e.pivotY : this.pivot.y),
            this.origin.set(typeof e.originX == "number" ? e.originX : this.origin.x, typeof e.originY == "number" ? e.originY : this.origin.y),
            this
        }
        setFromMatrix(e) {
            e.decompose(this)
        }
        updateLocalTransform() {
            let e = this._didContainerChangeTick;
            if (this._didLocalTransformChangeId === e)
                return;
            this._didLocalTransformChangeId = e;
            let t = this.localTransform
              , r = this._scale
              , s = this._pivot
              , n = this._origin
              , a = this._position
              , c = r._x
              , l = r._y
              , u = s._x
              , d = s._y
              , f = -n._x
              , b = -n._y;
            t.a = this._cx * c,
            t.b = this._sx * c,
            t.c = this._cy * l,
            t.d = this._sy * l,
            t.tx = a._x - (u * t.a + d * t.c) + (f * t.a + b * t.c) - f,
            t.ty = a._y - (u * t.b + d * t.d) + (f * t.b + b * t.d) - b
        }
        set alpha(e) {
            e !== this.localAlpha && (this.localAlpha = e,
            this._updateFlags |= gn,
            this._onUpdate())
        }
        get alpha() {
            return this.localAlpha
        }
        set tint(e) {
            let t = Ie.shared.setValue(e ?? 16777215).toBgrNumber();
            t !== this.localColor && (this.localColor = t,
            this._updateFlags |= gn,
            this._onUpdate())
        }
        get tint() {
            return ts(this.localColor)
        }
        set blendMode(e) {
            this.localBlendMode !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
            this._updateFlags |= Ah,
            this.localBlendMode = e,
            this._onUpdate())
        }
        get blendMode() {
            return this.localBlendMode
        }
        get visible() {
            return !!(this.localDisplayStatus & 2)
        }
        set visible(e) {
            let t = e ? 2 : 0;
            (this.localDisplayStatus & 2) !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
            this._updateFlags |= is,
            this.localDisplayStatus ^= 2,
            this._onUpdate())
        }
        get culled() {
            return !(this.localDisplayStatus & 4)
        }
        set culled(e) {
            let t = e ? 0 : 4;
            (this.localDisplayStatus & 4) !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
            this._updateFlags |= is,
            this.localDisplayStatus ^= 4,
            this._onUpdate())
        }
        get renderable() {
            return !!(this.localDisplayStatus & 1)
        }
        set renderable(e) {
            let t = e ? 1 : 0;
            (this.localDisplayStatus & 1) !== t && (this._updateFlags |= is,
            this.localDisplayStatus ^= 1,
            this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
            this._onUpdate())
        }
        get isRenderable() {
            return this.localDisplayStatus === 7 && this.groupAlpha > 0
        }
        destroy(e=!1) {
            var t;
            if (this.destroyed)
                return;
            this.destroyed = !0;
            let r;
            if (this.children.length && (r = this.removeChildren(0, this.children.length)),
            this.removeFromParent(),
            this.parent = null,
            this._maskEffect = null,
            this._filterEffect = null,
            this.effects = null,
            this._position = null,
            this._scale = null,
            this._pivot = null,
            this._origin = null,
            this._skew = null,
            this.emit("destroyed", this),
            this.removeAllListeners(),
            (typeof e == "boolean" ? e : e?.children) && r)
                for (let s = 0; s < r.length; ++s)
                    r[s].destroy(e);
            (t = this.renderGroup) == null || t.destroy(),
            this.renderGroup = null
        }
    }
    ;
    be.mixin(_e, k1, V1, Q1, K1, $1, j1, H1, q1, C1, D1, W1, U1);
    var gi = (i => (i[i.INTERACTION = 50] = "INTERACTION",
    i[i.HIGH = 25] = "HIGH",
    i[i.NORMAL = 0] = "NORMAL",
    i[i.LOW = -25] = "LOW",
    i[i.UTILITY = -50] = "UTILITY",
    i))(gi || {})
      , rs = class {
        constructor(e, t=null, r=0, s=!1) {
            this.next = null,
            this.previous = null,
            this._destroyed = !1,
            this._fn = e,
            this._context = t,
            this.priority = r,
            this._once = s
        }
        match(e, t=null) {
            return this._fn === e && this._context === t
        }
        emit(e) {
            this._fn && (this._context ? this._fn.call(this._context, e) : this._fn(e));
            let t = this.next;
            return this._once && this.destroy(!0),
            this._destroyed && (this.next = null),
            t
        }
        connect(e) {
            this.previous = e,
            e.next && (e.next.previous = this),
            this.next = e.next,
            e.next = this
        }
        destroy(e=!1) {
            this._destroyed = !0,
            this._fn = null,
            this._context = null,
            this.previous && (this.previous.next = this.next),
            this.next && (this.next.previous = this.previous);
            let t = this.next;
            return this.next = e ? null : t,
            this.previous = null,
            t
        }
    }
      , Jb = class Pt {
        constructor() {
            this.autoStart = !1,
            this.deltaTime = 1,
            this.lastTime = -1,
            this.speed = 1,
            this.started = !1,
            this._requestId = null,
            this._maxElapsedMS = 100,
            this._minElapsedMS = 0,
            this._protected = !1,
            this._lastFrame = -1,
            this._head = new rs(null,null,1 / 0),
            this.deltaMS = 1 / Pt.targetFPMS,
            this.elapsedMS = 1 / Pt.targetFPMS,
            this._tick = e => {
                this._requestId = null,
                this.started && (this.update(e),
                this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)))
            }
        }
        _requestIfNeeded() {
            this._requestId === null && this._head.next && (this.lastTime = performance.now(),
            this._lastFrame = this.lastTime,
            this._requestId = requestAnimationFrame(this._tick))
        }
        _cancelIfNeeded() {
            this._requestId !== null && (cancelAnimationFrame(this._requestId),
            this._requestId = null)
        }
        _startIfPossible() {
            this.started ? this._requestIfNeeded() : this.autoStart && this.start()
        }
        add(e, t, r=gi.NORMAL) {
            return this._addListener(new rs(e,t,r))
        }
        addOnce(e, t, r=gi.NORMAL) {
            return this._addListener(new rs(e,t,r,!0))
        }
        _addListener(e) {
            let t = this._head.next
              , r = this._head;
            if (!t)
                e.connect(r);
            else {
                for (; t; ) {
                    if (e.priority > t.priority) {
                        e.connect(r);
                        break
                    }
                    r = t,
                    t = t.next
                }
                e.previous || e.connect(r)
            }
            return this._startIfPossible(),
            this
        }
        remove(e, t) {
            let r = this._head.next;
            for (; r; )
                r.match(e, t) ? r = r.destroy() : r = r.next;
            return this._head.next || this._cancelIfNeeded(),
            this
        }
        get count() {
            if (!this._head)
                return 0;
            let e = 0
              , t = this._head;
            for (; t = t.next; )
                e++;
            return e
        }
        start() {
            this.started || (this.started = !0,
            this._requestIfNeeded())
        }
        stop() {
            this.started && (this.started = !1,
            this._cancelIfNeeded())
        }
        destroy() {
            if (!this._protected) {
                this.stop();
                let e = this._head.next;
                for (; e; )
                    e = e.destroy(!0);
                this._head.destroy(),
                this._head = null
            }
        }
        update(e=performance.now()) {
            let t;
            if (e > this.lastTime) {
                if (t = this.elapsedMS = e - this.lastTime,
                t > this._maxElapsedMS && (t = this._maxElapsedMS),
                t *= this.speed,
                this._minElapsedMS) {
                    let n = e - this._lastFrame | 0;
                    if (n < this._minElapsedMS)
                        return;
                    this._lastFrame = e - n % this._minElapsedMS
                }
                this.deltaMS = t,
                this.deltaTime = this.deltaMS * Pt.targetFPMS;
                let r = this._head
                  , s = r.next;
                for (; s; )
                    s = s.emit(this);
                r.next || this._cancelIfNeeded()
            } else
                this.deltaTime = this.deltaMS = this.elapsedMS = 0;
            this.lastTime = e
        }
        get FPS() {
            return 1e3 / this.elapsedMS
        }
        get minFPS() {
            return 1e3 / this._maxElapsedMS
        }
        set minFPS(e) {
            let t = Math.min(this.maxFPS, e)
              , r = Math.min(Math.max(0, t) / 1e3, Pt.targetFPMS);
            this._maxElapsedMS = 1 / r
        }
        get maxFPS() {
            return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
        }
        set maxFPS(e) {
            if (e === 0)
                this._minElapsedMS = 0;
            else {
                let t = Math.max(this.minFPS, e);
                this._minElapsedMS = 1 / (t / 1e3)
            }
        }
        static get shared() {
            if (!Pt._shared) {
                let e = Pt._shared = new Pt;
                e.autoStart = !0,
                e._protected = !0
            }
            return Pt._shared
        }
        static get system() {
            if (!Pt._system) {
                let e = Pt._system = new Pt;
                e.autoStart = !0,
                e._protected = !0
            }
            return Pt._system
        }
    }
    ;
    Jb.targetFPMS = .06;
    var nt = Jb
      , _n = class {
        constructor(e) {
            this._lastTransform = "",
            this._observer = null,
            this._tickerAttached = !1,
            this.updateTranslation = () => {
                if (!this._canvas)
                    return;
                let t = this._canvas.getBoundingClientRect()
                  , r = this._canvas.width
                  , s = this._canvas.height
                  , n = t.width / r * this._renderer.resolution
                  , a = t.height / s * this._renderer.resolution
                  , c = t.left
                  , l = t.top
                  , u = `translate(${c}px, ${l}px) scale(${n}, ${a})`;
                u !== this._lastTransform && (this._domElement.style.transform = u,
                this._lastTransform = u)
            }
            ,
            this._domElement = e.domElement,
            this._renderer = e.renderer,
            !(globalThis.OffscreenCanvas && this._renderer.canvas instanceof OffscreenCanvas) && (this._canvas = this._renderer.canvas,
            this._attachObserver())
        }
        get canvas() {
            return this._canvas
        }
        ensureAttached() {
            !this._domElement.parentNode && this._canvas.parentNode && (this._canvas.parentNode.appendChild(this._domElement),
            this.updateTranslation())
        }
        _attachObserver() {
            "ResizeObserver"in globalThis ? (this._observer && (this._observer.disconnect(),
            this._observer = null),
            this._observer = new ResizeObserver(e => {
                for (let t of e) {
                    if (t.target !== this._canvas)
                        continue;
                    let r = this.canvas.width
                      , s = this.canvas.height
                      , n = t.contentRect.width / r * this._renderer.resolution
                      , a = t.contentRect.height / s * this._renderer.resolution;
                    (this._lastScaleX !== n || this._lastScaleY !== a) && (this.updateTranslation(),
                    this._lastScaleX = n,
                    this._lastScaleY = a)
                }
            }
            ),
            this._observer.observe(this._canvas)) : this._tickerAttached || nt.shared.add(this.updateTranslation, this, gi.HIGH)
        }
        destroy() {
            this._observer ? (this._observer.disconnect(),
            this._observer = null) : this._tickerAttached && nt.shared.remove(this.updateTranslation),
            this._domElement = null,
            this._renderer = null,
            this._canvas = null,
            this._tickerAttached = !1,
            this._lastTransform = "",
            this._lastScaleX = null,
            this._lastScaleY = null
        }
    }
      , fs = class i {
        constructor(e) {
            this.bubbles = !0,
            this.cancelBubble = !0,
            this.cancelable = !1,
            this.composed = !1,
            this.defaultPrevented = !1,
            this.eventPhase = i.prototype.NONE,
            this.propagationStopped = !1,
            this.propagationImmediatelyStopped = !1,
            this.layer = new Ne,
            this.page = new Ne,
            this.NONE = 0,
            this.CAPTURING_PHASE = 1,
            this.AT_TARGET = 2,
            this.BUBBLING_PHASE = 3,
            this.manager = e
        }
        get layerX() {
            return this.layer.x
        }
        get layerY() {
            return this.layer.y
        }
        get pageX() {
            return this.page.x
        }
        get pageY() {
            return this.page.y
        }
        get data() {
            return this
        }
        composedPath() {
            return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []),
            this.path
        }
        initEvent(e, t, r) {
            throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
        }
        initUIEvent(e, t, r, s, n) {
            throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
        }
        preventDefault() {
            this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(),
            this.defaultPrevented = !0
        }
        stopImmediatePropagation() {
            this.propagationImmediatelyStopped = !0
        }
        stopPropagation() {
            this.propagationStopped = !0
        }
    }
      , Bo = /iPhone/i
      , wu = /iPod/i
      , Au = /iPad/i
      , Eu = /\biOS-universal(?:.+)Mac\b/i
      , Fo = /\bAndroid(?:.+)Mobile\b/i
      , Pu = /Android/i
      , or = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i
      , js = /Silk/i
      , di = /Windows Phone/i
      , Ru = /\bWindows(?:.+)ARM\b/i
      , Mu = /BlackBerry/i
      , Cu = /BB10/i
      , Ou = /Opera Mini/i
      , Iu = /\b(CriOS|Chrome)(?:.+)Mobile/i
      , Gu = /Mobile(?:.+)Firefox\b/i
      , Bu = function(i) {
        return typeof i < "u" && i.platform === "MacIntel" && typeof i.maxTouchPoints == "number" && i.maxTouchPoints > 1 && typeof MSStream > "u"
    };
    function T_(i) {
        return function(e) {
            return e.test(i)
        }
    }
    function Fu(i) {
        var e = {
            userAgent: "",
            platform: "",
            maxTouchPoints: 0
        };
        !i && typeof navigator < "u" ? e = {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            maxTouchPoints: navigator.maxTouchPoints || 0
        } : typeof i == "string" ? e.userAgent = i : i && i.userAgent && (e = {
            userAgent: i.userAgent,
            platform: i.platform,
            maxTouchPoints: i.maxTouchPoints || 0
        });
        var t = e.userAgent
          , r = t.split("[FBAN");
        typeof r[1] < "u" && (t = r[0]),
        r = t.split("Twitter"),
        typeof r[1] < "u" && (t = r[0]);
        var s = T_(t)
          , n = {
            apple: {
                phone: s(Bo) && !s(di),
                ipod: s(wu),
                tablet: !s(Bo) && (s(Au) || Bu(e)) && !s(di),
                universal: s(Eu),
                device: (s(Bo) || s(wu) || s(Au) || s(Eu) || Bu(e)) && !s(di)
            },
            amazon: {
                phone: s(or),
                tablet: !s(or) && s(js),
                device: s(or) || s(js)
            },
            android: {
                phone: !s(di) && s(or) || !s(di) && s(Fo),
                tablet: !s(di) && !s(or) && !s(Fo) && (s(js) || s(Pu)),
                device: !s(di) && (s(or) || s(js) || s(Fo) || s(Pu)) || s(/\bokhttp\b/i)
            },
            windows: {
                phone: s(di),
                tablet: s(Ru),
                device: s(di) || s(Ru)
            },
            other: {
                blackberry: s(Mu),
                blackberry10: s(Cu),
                opera: s(Ou),
                firefox: s(Gu),
                chrome: s(Iu),
                device: s(Mu) || s(Cu) || s(Ou) || s(Gu) || s(Iu)
            },
            any: !1,
            phone: !1,
            tablet: !1
        };
        return n.any = n.apple.device || n.android.device || n.windows.device || n.other.device,
        n.phone = n.apple.phone || n.android.phone || n.windows.phone,
        n.tablet = n.apple.tablet || n.android.tablet || n.windows.tablet,
        n
    }
    var Du, S_ = (Du = Fu.default) != null ? Du : Fu, Eh = S_(globalThis.navigator), w_ = Object.defineProperty, ku = Object.getOwnPropertySymbols, A_ = Object.prototype.hasOwnProperty, E_ = Object.prototype.propertyIsEnumerable, Uu = (i, e, t) => e in i ? w_(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t, Lu = (i, e) => {
        for (var t in e || (e = {}))
            A_.call(e, t) && Uu(i, t, e[t]);
        if (ku)
            for (var t of ku(e))
                E_.call(e, t) && Uu(i, t, e[t]);
        return i
    }
    , P_ = 9, Nu = 100, R_ = 0, M_ = 0, Xu = 2, ju = 1, C_ = -1e3, O_ = -1e3, I_ = 2, kc = class e0 {
        constructor(e, t=Eh) {
            this._mobileInfo = t,
            this.debug = !1,
            this._activateOnTab = !0,
            this._deactivateOnMouseMove = !0,
            this._isActive = !1,
            this._isMobileAccessibility = !1,
            this._div = null,
            this._pool = [],
            this._renderId = 0,
            this._children = [],
            this._androidUpdateCount = 0,
            this._androidUpdateFrequency = 500,
            this._hookDiv = null,
            (t.tablet || t.phone) && this._createTouchHook(),
            this._renderer = e
        }
        get isActive() {
            return this._isActive
        }
        get isMobileAccessibility() {
            return this._isMobileAccessibility
        }
        get hookDiv() {
            return this._hookDiv
        }
        _createTouchHook() {
            let e = document.createElement("button");
            e.style.width = `${ju}px`,
            e.style.height = `${ju}px`,
            e.style.position = "absolute",
            e.style.top = `${C_}px`,
            e.style.left = `${O_}px`,
            e.style.zIndex = I_.toString(),
            e.style.backgroundColor = "#FF0000",
            e.title = "select to enable accessibility for this content",
            e.addEventListener("focus", () => {
                this._isMobileAccessibility = !0,
                this._activate(),
                this._destroyTouchHook()
            }
            ),
            document.body.appendChild(e),
            this._hookDiv = e
        }
        _destroyTouchHook() {
            this._hookDiv && (document.body.removeChild(this._hookDiv),
            this._hookDiv = null)
        }
        _activate() {
            if (this._isActive)
                return;
            this._isActive = !0,
            this._div || (this._div = document.createElement("div"),
            this._div.style.position = "absolute",
            this._div.style.top = `${R_}px`,
            this._div.style.left = `${M_}px`,
            this._div.style.pointerEvents = "none",
            this._div.style.zIndex = Xu.toString(),
            this._canvasObserver = new _n({
                domElement: this._div,
                renderer: this._renderer
            })),
            this._activateOnTab && (this._onKeyDown = this._onKeyDown.bind(this),
            globalThis.addEventListener("keydown", this._onKeyDown, !1)),
            this._deactivateOnMouseMove && (this._onMouseMove = this._onMouseMove.bind(this),
            globalThis.document.addEventListener("mousemove", this._onMouseMove, !0));
            let e = this._renderer.view.canvas;
            if (e.parentNode)
                this._canvasObserver.ensureAttached(),
                this._initAccessibilitySetup();
            else {
                let t = new MutationObserver( () => {
                    e.parentNode && (t.disconnect(),
                    this._canvasObserver.ensureAttached(),
                    this._initAccessibilitySetup())
                }
                );
                t.observe(document.body, {
                    childList: !0,
                    subtree: !0
                })
            }
        }
        _initAccessibilitySetup() {
            this._renderer.runners.postrender.add(this),
            this._renderer.lastObjectRendered && this._updateAccessibleObjects(this._renderer.lastObjectRendered)
        }
        _deactivate() {
            if (!(!this._isActive || this._isMobileAccessibility)) {
                this._isActive = !1,
                globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0),
                this._activateOnTab && globalThis.addEventListener("keydown", this._onKeyDown, !1),
                this._renderer.runners.postrender.remove(this);
                for (let e of this._children)
                    e._accessibleDiv && e._accessibleDiv.parentNode && (e._accessibleDiv.parentNode.removeChild(e._accessibleDiv),
                    e._accessibleDiv = null),
                    e._accessibleActive = !1;
                this._pool.forEach(e => {
                    e.parentNode && e.parentNode.removeChild(e)
                }
                ),
                this._div && this._div.parentNode && this._div.parentNode.removeChild(this._div),
                this._pool = [],
                this._children = []
            }
        }
        _updateAccessibleObjects(e) {
            if (!e.visible || !e.accessibleChildren)
                return;
            e.accessible && (e._accessibleActive || this._addChild(e),
            e._renderId = this._renderId);
            let t = e.children;
            if (t)
                for (let r = 0; r < t.length; r++)
                    this._updateAccessibleObjects(t[r])
        }
        init(e) {
            let t = e0.defaultOptions
              , r = {
                accessibilityOptions: Lu(Lu({}, t), e?.accessibilityOptions || {})
            };
            this.debug = r.accessibilityOptions.debug,
            this._activateOnTab = r.accessibilityOptions.activateOnTab,
            this._deactivateOnMouseMove = r.accessibilityOptions.deactivateOnMouseMove,
            r.accessibilityOptions.enabledByDefault ? this._activate() : this._activateOnTab && (this._onKeyDown = this._onKeyDown.bind(this),
            globalThis.addEventListener("keydown", this._onKeyDown, !1)),
            this._renderer.runners.postrender.remove(this)
        }
        postrender() {
            let e = performance.now();
            if (this._mobileInfo.android.device && e < this._androidUpdateCount || (this._androidUpdateCount = e + this._androidUpdateFrequency,
            !this._renderer.renderingToScreen || !this._renderer.view.canvas))
                return;
            let t = new Set;
            if (this._renderer.lastObjectRendered) {
                this._updateAccessibleObjects(this._renderer.lastObjectRendered);
                for (let r of this._children)
                    r._renderId === this._renderId && t.add(this._children.indexOf(r))
            }
            for (let r = this._children.length - 1; r >= 0; r--) {
                let s = this._children[r];
                t.has(r) || (s._accessibleDiv && s._accessibleDiv.parentNode && (s._accessibleDiv.parentNode.removeChild(s._accessibleDiv),
                this._pool.push(s._accessibleDiv),
                s._accessibleDiv = null),
                s._accessibleActive = !1,
                Hb(this._children, r, 1))
            }
            this._renderer.renderingToScreen && this._canvasObserver.ensureAttached();
            for (let r = 0; r < this._children.length; r++) {
                let s = this._children[r];
                if (!s._accessibleActive || !s._accessibleDiv)
                    continue;
                let n = s._accessibleDiv
                  , a = s.hitArea || s.getBounds().rectangle;
                if (s.hitArea) {
                    let c = s.worldTransform;
                    n.style.left = `${c.tx + a.x * c.a}px`,
                    n.style.top = `${c.ty + a.y * c.d}px`,
                    n.style.width = `${a.width * c.a}px`,
                    n.style.height = `${a.height * c.d}px`
                } else
                    this._capHitArea(a),
                    n.style.left = `${a.x}px`,
                    n.style.top = `${a.y}px`,
                    n.style.width = `${a.width}px`,
                    n.style.height = `${a.height}px`
            }
            this._renderId++
        }
        _updateDebugHTML(e) {
            e.innerHTML = `type: ${e.type}</br> title : ${e.title}</br> tabIndex: ${e.tabIndex}`
        }
        _capHitArea(e) {
            e.x < 0 && (e.width += e.x,
            e.x = 0),
            e.y < 0 && (e.height += e.y,
            e.y = 0);
            let {width: t, height: r} = this._renderer;
            e.x + e.width > t && (e.width = t - e.x),
            e.y + e.height > r && (e.height = r - e.y)
        }
        _addChild(e) {
            let t = this._pool.pop();
            t || (e.accessibleType === "button" ? t = document.createElement("button") : (t = document.createElement(e.accessibleType),
            t.style.cssText = `
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `,
            e.accessibleText && (t.innerText = e.accessibleText)),
            t.style.width = `${Nu}px`,
            t.style.height = `${Nu}px`,
            t.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent",
            t.style.position = "absolute",
            t.style.zIndex = Xu.toString(),
            t.style.borderStyle = "none",
            navigator.userAgent.toLowerCase().includes("chrome") ? t.setAttribute("aria-live", "off") : t.setAttribute("aria-live", "polite"),
            navigator.userAgent.match(/rv:.*Gecko\//) ? t.setAttribute("aria-relevant", "additions") : t.setAttribute("aria-relevant", "text"),
            t.addEventListener("click", this._onClick.bind(this)),
            t.addEventListener("focus", this._onFocus.bind(this)),
            t.addEventListener("focusout", this._onFocusOut.bind(this))),
            t.style.pointerEvents = e.accessiblePointerEvents,
            t.type = e.accessibleType,
            e.accessibleTitle && e.accessibleTitle !== null ? t.title = e.accessibleTitle : (!e.accessibleHint || e.accessibleHint === null) && (t.title = `container ${e.tabIndex}`),
            e.accessibleHint && e.accessibleHint !== null && t.setAttribute("aria-label", e.accessibleHint),
            e.interactive ? t.tabIndex = e.tabIndex : t.tabIndex = 0,
            this.debug && this._updateDebugHTML(t),
            e._accessibleActive = !0,
            e._accessibleDiv = t,
            t.container = e,
            this._children.push(e),
            this._div.appendChild(e._accessibleDiv)
        }
        _dispatchEvent(e, t) {
            let {container: r} = e.target
              , s = this._renderer.events.rootBoundary
              , n = Object.assign(new fs(s), {
                target: r
            });
            s.rootTarget = this._renderer.lastObjectRendered,
            t.forEach(a => s.dispatchEvent(n, a))
        }
        _onClick(e) {
            this._dispatchEvent(e, ["click", "pointertap", "tap"])
        }
        _onFocus(e) {
            e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "assertive"),
            this._dispatchEvent(e, ["mouseover"])
        }
        _onFocusOut(e) {
            e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "polite"),
            this._dispatchEvent(e, ["mouseout"])
        }
        _onKeyDown(e) {
            e.keyCode !== P_ || !this._activateOnTab || this._activate()
        }
        _onMouseMove(e) {
            e.movementX === 0 && e.movementY === 0 || this._deactivate()
        }
        destroy() {
            var e;
            this._deactivate(),
            this._destroyTouchHook(),
            (e = this._canvasObserver) == null || e.destroy(),
            this._canvasObserver = null,
            this._div = null,
            this._pool = null,
            this._children = null,
            this._renderer = null,
            this._activateOnTab && globalThis.removeEventListener("keydown", this._onKeyDown)
        }
        setAccessibilityEnabled(e) {
            e ? this._activate() : this._deactivate()
        }
    }
    ;
    kc.extension = {
        type: [B.WebGLSystem, B.WebGPUSystem],
        name: "accessibility"
    },
    kc.defaultOptions = {
        enabledByDefault: !1,
        debug: !1,
        activateOnTab: !0,
        deactivateOnMouseMove: !0
    };
    var G_ = kc
      , B_ = {
        accessible: !1,
        accessibleTitle: null,
        accessibleHint: null,
        tabIndex: 0,
        accessibleType: "button",
        accessibleText: null,
        accessiblePointerEvents: "auto",
        accessibleChildren: !0,
        _accessibleActive: !1,
        _accessibleDiv: null,
        _renderId: -1
    };
    be.add(G_),
    be.mixin(_e, B_);
    var xn = class {
        static init(e) {
            Object.defineProperty(this, "resizeTo", {
                set(t) {
                    globalThis.removeEventListener("resize", this.queueResize),
                    this._resizeTo = t,
                    t && (globalThis.addEventListener("resize", this.queueResize),
                    this.resize())
                },
                get() {
                    return this._resizeTo
                }
            }),
            this.queueResize = () => {
                this._resizeTo && (this._cancelResize(),
                this._resizeId = requestAnimationFrame( () => this.resize()))
            }
            ,
            this._cancelResize = () => {
                this._resizeId && (cancelAnimationFrame(this._resizeId),
                this._resizeId = null)
            }
            ,
            this.resize = () => {
                if (!this._resizeTo)
                    return;
                this._cancelResize();
                let t, r;
                if (this._resizeTo === globalThis.window)
                    t = globalThis.innerWidth,
                    r = globalThis.innerHeight;
                else {
                    let {clientWidth: s, clientHeight: n} = this._resizeTo;
                    t = s,
                    r = n
                }
                this.renderer.resize(t, r),
                this.render()
            }
            ,
            this._resizeId = null,
            this._resizeTo = null,
            this.resizeTo = e.resizeTo || null
        }
        static destroy() {
            globalThis.removeEventListener("resize", this.queueResize),
            this._cancelResize(),
            this._cancelResize = null,
            this.queueResize = null,
            this.resizeTo = null,
            this.resize = null
        }
    }
    ;
    xn.extension = B.Application;
    var yn = class {
        static init(e) {
            e = Object.assign({
                autoStart: !0,
                sharedTicker: !1
            }, e),
            Object.defineProperty(this, "ticker", {
                set(t) {
                    this._ticker && this._ticker.remove(this.render, this),
                    this._ticker = t,
                    t && t.add(this.render, this, gi.LOW)
                },
                get() {
                    return this._ticker
                }
            }),
            this.stop = () => {
                this._ticker.stop()
            }
            ,
            this.start = () => {
                this._ticker.start()
            }
            ,
            this._ticker = null,
            this.ticker = e.sharedTicker ? nt.shared : new nt,
            e.autoStart && this.start()
        }
        static destroy() {
            if (this._ticker) {
                let e = this._ticker;
                this.ticker = null,
                e.destroy()
            }
        }
    }
    ;
    yn.extension = B.Application,
    be.add(xn),
    be.add(yn);
    var F_ = class {
        constructor() {
            this.interactionFrequency = 10,
            this._deltaTime = 0,
            this._didMove = !1,
            this._tickerAdded = !1,
            this._pauseUpdate = !0
        }
        init(i) {
            this.removeTickerListener(),
            this.events = i,
            this.interactionFrequency = 10,
            this._deltaTime = 0,
            this._didMove = !1,
            this._tickerAdded = !1,
            this._pauseUpdate = !0
        }
        get pauseUpdate() {
            return this._pauseUpdate
        }
        set pauseUpdate(i) {
            this._pauseUpdate = i
        }
        addTickerListener() {
            this._tickerAdded || !this.domElement || (nt.system.add(this._tickerUpdate, this, gi.INTERACTION),
            this._tickerAdded = !0)
        }
        removeTickerListener() {
            this._tickerAdded && (nt.system.remove(this._tickerUpdate, this),
            this._tickerAdded = !1)
        }
        pointerMoved() {
            this._didMove = !0
        }
        _update() {
            if (!this.domElement || this._pauseUpdate)
                return;
            if (this._didMove) {
                this._didMove = !1;
                return
            }
            let i = this.events._rootPointerEvent;
            this.events.supportsTouchEvents && i.pointerType === "touch" || globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent("pointermove",{
                clientX: i.clientX,
                clientY: i.clientY,
                pointerType: i.pointerType,
                pointerId: i.pointerId
            }) : new MouseEvent("mousemove",{
                clientX: i.clientX,
                clientY: i.clientY
            }))
        }
        _tickerUpdate(i) {
            this._deltaTime += i.deltaTime,
            !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0,
            this._update())
        }
        destroy() {
            this.removeTickerListener(),
            this.events = null,
            this.domElement = null,
            this._deltaTime = 0,
            this._didMove = !1,
            this._tickerAdded = !1,
            this._pauseUpdate = !0
        }
    }
      , fi = new F_
      , Ar = class extends fs {
        constructor() {
            super(...arguments),
            this.client = new Ne,
            this.movement = new Ne,
            this.offset = new Ne,
            this.global = new Ne,
            this.screen = new Ne
        }
        get clientX() {
            return this.client.x
        }
        get clientY() {
            return this.client.y
        }
        get x() {
            return this.clientX
        }
        get y() {
            return this.clientY
        }
        get movementX() {
            return this.movement.x
        }
        get movementY() {
            return this.movement.y
        }
        get offsetX() {
            return this.offset.x
        }
        get offsetY() {
            return this.offset.y
        }
        get globalX() {
            return this.global.x
        }
        get globalY() {
            return this.global.y
        }
        get screenX() {
            return this.screen.x
        }
        get screenY() {
            return this.screen.y
        }
        getLocalPosition(e, t, r) {
            return e.worldTransform.applyInverse(r || this.global, t)
        }
        getModifierState(e) {
            return "getModifierState"in this.nativeEvent && this.nativeEvent.getModifierState(e)
        }
        initMouseEvent(e, t, r, s, n, a, c, l, u, d, f, b, m, x, y) {
            throw new Error("Method not implemented.")
        }
    }
      , Ot = class extends Ar {
        constructor() {
            super(...arguments),
            this.width = 0,
            this.height = 0,
            this.isPrimary = !1
        }
        getCoalescedEvents() {
            return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : []
        }
        getPredictedEvents() {
            throw new Error("getPredictedEvents is not supported!")
        }
    }
      , Ii = class extends Ar {
        constructor() {
            super(...arguments),
            this.DOM_DELTA_PIXEL = 0,
            this.DOM_DELTA_LINE = 1,
            this.DOM_DELTA_PAGE = 2
        }
    }
    ;
    Ii.DOM_DELTA_PIXEL = 0,
    Ii.DOM_DELTA_LINE = 1,
    Ii.DOM_DELTA_PAGE = 2;
    var D_ = 2048
      , k_ = new Ne
      , Fr = new Ne
      , Uc = class {
        constructor(e) {
            this.dispatch = new Ft,
            this.moveOnAll = !1,
            this.enableGlobalMoveEvents = !0,
            this.mappingState = {
                trackingData: {}
            },
            this.eventPool = new Map,
            this._allInteractiveElements = [],
            this._hitElements = [],
            this._isPointerMoveEvent = !1,
            this.rootTarget = e,
            this.hitPruneFn = this.hitPruneFn.bind(this),
            this.hitTestFn = this.hitTestFn.bind(this),
            this.mapPointerDown = this.mapPointerDown.bind(this),
            this.mapPointerMove = this.mapPointerMove.bind(this),
            this.mapPointerOut = this.mapPointerOut.bind(this),
            this.mapPointerOver = this.mapPointerOver.bind(this),
            this.mapPointerUp = this.mapPointerUp.bind(this),
            this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this),
            this.mapWheel = this.mapWheel.bind(this),
            this.mappingTable = {},
            this.addEventMapping("pointerdown", this.mapPointerDown),
            this.addEventMapping("pointermove", this.mapPointerMove),
            this.addEventMapping("pointerout", this.mapPointerOut),
            this.addEventMapping("pointerleave", this.mapPointerOut),
            this.addEventMapping("pointerover", this.mapPointerOver),
            this.addEventMapping("pointerup", this.mapPointerUp),
            this.addEventMapping("pointerupoutside", this.mapPointerUpOutside),
            this.addEventMapping("wheel", this.mapWheel)
        }
        addEventMapping(e, t) {
            this.mappingTable[e] || (this.mappingTable[e] = []),
            this.mappingTable[e].push({
                fn: t,
                priority: 0
            }),
            this.mappingTable[e].sort( (r, s) => r.priority - s.priority)
        }
        dispatchEvent(e, t) {
            e.propagationStopped = !1,
            e.propagationImmediatelyStopped = !1,
            this.propagate(e, t),
            this.dispatch.emit(t || e.type, e)
        }
        mapEvent(e) {
            if (!this.rootTarget)
                return;
            let t = this.mappingTable[e.type];
            if (t)
                for (let r = 0, s = t.length; r < s; r++)
                    t[r].fn(e)
        }
        hitTest(e, t) {
            fi.pauseUpdate = !0;
            let r = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive"
              , s = this[r](this.rootTarget, this.rootTarget.eventMode, k_.set(e, t), this.hitTestFn, this.hitPruneFn);
            return s && s[0]
        }
        propagate(e, t) {
            if (!e.target)
                return;
            let r = e.composedPath();
            e.eventPhase = e.CAPTURING_PHASE;
            for (let s = 0, n = r.length - 1; s < n; s++)
                if (e.currentTarget = r[s],
                this.notifyTarget(e, t),
                e.propagationStopped || e.propagationImmediatelyStopped)
                    return;
            if (e.eventPhase = e.AT_TARGET,
            e.currentTarget = e.target,
            this.notifyTarget(e, t),
            !(e.propagationStopped || e.propagationImmediatelyStopped)) {
                e.eventPhase = e.BUBBLING_PHASE;
                for (let s = r.length - 2; s >= 0; s--)
                    if (e.currentTarget = r[s],
                    this.notifyTarget(e, t),
                    e.propagationStopped || e.propagationImmediatelyStopped)
                        return
            }
        }
        all(e, t, r=this._allInteractiveElements) {
            if (r.length === 0)
                return;
            e.eventPhase = e.BUBBLING_PHASE;
            let s = Array.isArray(t) ? t : [t];
            for (let n = r.length - 1; n >= 0; n--)
                s.forEach(a => {
                    e.currentTarget = r[n],
                    this.notifyTarget(e, a)
                }
                )
        }
        propagationPath(e) {
            let t = [e];
            for (let r = 0; r < D_ && e !== this.rootTarget && e.parent; r++) {
                if (!e.parent)
                    throw new Error("Cannot find propagation path to disconnected target");
                t.push(e.parent),
                e = e.parent
            }
            return t.reverse(),
            t
        }
        hitTestMoveRecursive(e, t, r, s, n, a=!1) {
            let c = !1;
            if (this._interactivePrune(e))
                return null;
            if ((e.eventMode === "dynamic" || t === "dynamic") && (fi.pauseUpdate = !1),
            e.interactiveChildren && e.children) {
                let d = e.children;
                for (let f = d.length - 1; f >= 0; f--) {
                    let b = d[f]
                      , m = this.hitTestMoveRecursive(b, this._isInteractive(t) ? t : b.eventMode, r, s, n, a || n(e, r));
                    if (m) {
                        if (m.length > 0 && !m[m.length - 1].parent)
                            continue;
                        let x = e.isInteractive();
                        (m.length > 0 || x) && (x && this._allInteractiveElements.push(e),
                        m.push(e)),
                        this._hitElements.length === 0 && (this._hitElements = m),
                        c = !0
                    }
                }
            }
            let l = this._isInteractive(t)
              , u = e.isInteractive();
            return u && u && this._allInteractiveElements.push(e),
            a || this._hitElements.length > 0 ? null : c ? this._hitElements : l && !n(e, r) && s(e, r) ? u ? [e] : [] : null
        }
        hitTestRecursive(e, t, r, s, n) {
            if (this._interactivePrune(e) || n(e, r))
                return null;
            if ((e.eventMode === "dynamic" || t === "dynamic") && (fi.pauseUpdate = !1),
            e.interactiveChildren && e.children) {
                let l = e.children
                  , u = r;
                for (let d = l.length - 1; d >= 0; d--) {
                    let f = l[d]
                      , b = this.hitTestRecursive(f, this._isInteractive(t) ? t : f.eventMode, u, s, n);
                    if (b) {
                        if (b.length > 0 && !b[b.length - 1].parent)
                            continue;
                        let m = e.isInteractive();
                        return (b.length > 0 || m) && b.push(e),
                        b
                    }
                }
            }
            let a = this._isInteractive(t)
              , c = e.isInteractive();
            return a && s(e, r) ? c ? [e] : [] : null
        }
        _isInteractive(e) {
            return e === "static" || e === "dynamic"
        }
        _interactivePrune(e) {
            return !e || !e.visible || !e.renderable || !e.measurable || e.eventMode === "none" || e.eventMode === "passive" && !e.interactiveChildren
        }
        hitPruneFn(e, t) {
            if (e.hitArea && (e.worldTransform.applyInverse(t, Fr),
            !e.hitArea.contains(Fr.x, Fr.y)))
                return !0;
            if (e.effects && e.effects.length)
                for (let r = 0; r < e.effects.length; r++) {
                    let s = e.effects[r];
                    if (s.containsPoint && !s.containsPoint(t, this.hitTestFn))
                        return !0
                }
            return !1
        }
        hitTestFn(e, t) {
            return e.hitArea ? !0 : e != null && e.containsPoint ? (e.worldTransform.applyInverse(t, Fr),
            e.containsPoint(Fr)) : !1
        }
        notifyTarget(e, t) {
            var r, s;
            if (!e.currentTarget.isInteractive())
                return;
            t != null || (t = e.type);
            let n = `on${t}`;
            (s = (r = e.currentTarget)[n]) == null || s.call(r, e);
            let a = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${t}capture` : t;
            this._notifyListeners(e, a),
            e.eventPhase === e.AT_TARGET && this._notifyListeners(e, t)
        }
        mapPointerDown(e) {
            if (!(e instanceof Ot))
                return;
            let t = this.createPointerEvent(e);
            if (this.dispatchEvent(t, "pointerdown"),
            t.pointerType === "touch")
                this.dispatchEvent(t, "touchstart");
            else if (t.pointerType === "mouse" || t.pointerType === "pen") {
                let s = t.button === 2;
                this.dispatchEvent(t, s ? "rightdown" : "mousedown")
            }
            let r = this.trackingData(e.pointerId);
            r.pressTargetsByButton[e.button] = t.composedPath(),
            this.freeEvent(t)
        }
        mapPointerMove(e) {
            var t, r, s;
            if (!(e instanceof Ot))
                return;
            this._allInteractiveElements.length = 0,
            this._hitElements.length = 0,
            this._isPointerMoveEvent = !0;
            let n = this.createPointerEvent(e);
            this._isPointerMoveEvent = !1;
            let a = n.pointerType === "mouse" || n.pointerType === "pen"
              , c = this.trackingData(e.pointerId)
              , l = this.findMountedTarget(c.overTargets);
            if (((t = c.overTargets) == null ? void 0 : t.length) > 0 && l !== n.target) {
                let f = e.type === "mousemove" ? "mouseout" : "pointerout"
                  , b = this.createPointerEvent(e, f, l);
                if (this.dispatchEvent(b, "pointerout"),
                a && this.dispatchEvent(b, "mouseout"),
                !n.composedPath().includes(l)) {
                    let m = this.createPointerEvent(e, "pointerleave", l);
                    for (m.eventPhase = m.AT_TARGET; m.target && !n.composedPath().includes(m.target); )
                        m.currentTarget = m.target,
                        this.notifyTarget(m),
                        a && this.notifyTarget(m, "mouseleave"),
                        m.target = m.target.parent;
                    this.freeEvent(m)
                }
                this.freeEvent(b)
            }
            if (l !== n.target) {
                let f = e.type === "mousemove" ? "mouseover" : "pointerover"
                  , b = this.clonePointerEvent(n, f);
                this.dispatchEvent(b, "pointerover"),
                a && this.dispatchEvent(b, "mouseover");
                let m = l?.parent;
                for (; m && m !== this.rootTarget.parent && m !== n.target; )
                    m = m.parent;
                if (!m || m === this.rootTarget.parent) {
                    let x = this.clonePointerEvent(n, "pointerenter");
                    for (x.eventPhase = x.AT_TARGET; x.target && x.target !== l && x.target !== this.rootTarget.parent; )
                        x.currentTarget = x.target,
                        this.notifyTarget(x),
                        a && this.notifyTarget(x, "mouseenter"),
                        x.target = x.target.parent;
                    this.freeEvent(x)
                }
                this.freeEvent(b)
            }
            let u = []
              , d = (r = this.enableGlobalMoveEvents) != null ? r : !0;
            this.moveOnAll ? u.push("pointermove") : this.dispatchEvent(n, "pointermove"),
            d && u.push("globalpointermove"),
            n.pointerType === "touch" && (this.moveOnAll ? u.splice(1, 0, "touchmove") : this.dispatchEvent(n, "touchmove"),
            d && u.push("globaltouchmove")),
            a && (this.moveOnAll ? u.splice(1, 0, "mousemove") : this.dispatchEvent(n, "mousemove"),
            d && u.push("globalmousemove"),
            this.cursor = (s = n.target) == null ? void 0 : s.cursor),
            u.length > 0 && this.all(n, u),
            this._allInteractiveElements.length = 0,
            this._hitElements.length = 0,
            c.overTargets = n.composedPath(),
            this.freeEvent(n)
        }
        mapPointerOver(e) {
            var t;
            if (!(e instanceof Ot))
                return;
            let r = this.trackingData(e.pointerId)
              , s = this.createPointerEvent(e)
              , n = s.pointerType === "mouse" || s.pointerType === "pen";
            this.dispatchEvent(s, "pointerover"),
            n && this.dispatchEvent(s, "mouseover"),
            s.pointerType === "mouse" && (this.cursor = (t = s.target) == null ? void 0 : t.cursor);
            let a = this.clonePointerEvent(s, "pointerenter");
            for (a.eventPhase = a.AT_TARGET; a.target && a.target !== this.rootTarget.parent; )
                a.currentTarget = a.target,
                this.notifyTarget(a),
                n && this.notifyTarget(a, "mouseenter"),
                a.target = a.target.parent;
            r.overTargets = s.composedPath(),
            this.freeEvent(s),
            this.freeEvent(a)
        }
        mapPointerOut(e) {
            if (!(e instanceof Ot))
                return;
            let t = this.trackingData(e.pointerId);
            if (t.overTargets) {
                let r = e.pointerType === "mouse" || e.pointerType === "pen"
                  , s = this.findMountedTarget(t.overTargets)
                  , n = this.createPointerEvent(e, "pointerout", s);
                this.dispatchEvent(n),
                r && this.dispatchEvent(n, "mouseout");
                let a = this.createPointerEvent(e, "pointerleave", s);
                for (a.eventPhase = a.AT_TARGET; a.target && a.target !== this.rootTarget.parent; )
                    a.currentTarget = a.target,
                    this.notifyTarget(a),
                    r && this.notifyTarget(a, "mouseleave"),
                    a.target = a.target.parent;
                t.overTargets = null,
                this.freeEvent(n),
                this.freeEvent(a)
            }
            this.cursor = null
        }
        mapPointerUp(e) {
            if (!(e instanceof Ot))
                return;
            let t = performance.now()
              , r = this.createPointerEvent(e);
            if (this.dispatchEvent(r, "pointerup"),
            r.pointerType === "touch")
                this.dispatchEvent(r, "touchend");
            else if (r.pointerType === "mouse" || r.pointerType === "pen") {
                let c = r.button === 2;
                this.dispatchEvent(r, c ? "rightup" : "mouseup")
            }
            let s = this.trackingData(e.pointerId)
              , n = this.findMountedTarget(s.pressTargetsByButton[e.button])
              , a = n;
            if (n && !r.composedPath().includes(n)) {
                let c = n;
                for (; c && !r.composedPath().includes(c); ) {
                    if (r.currentTarget = c,
                    this.notifyTarget(r, "pointerupoutside"),
                    r.pointerType === "touch")
                        this.notifyTarget(r, "touchendoutside");
                    else if (r.pointerType === "mouse" || r.pointerType === "pen") {
                        let l = r.button === 2;
                        this.notifyTarget(r, l ? "rightupoutside" : "mouseupoutside")
                    }
                    c = c.parent
                }
                delete s.pressTargetsByButton[e.button],
                a = c
            }
            if (a) {
                let c = this.clonePointerEvent(r, "click");
                c.target = a,
                c.path = null,
                s.clicksByButton[e.button] || (s.clicksByButton[e.button] = {
                    clickCount: 0,
                    target: c.target,
                    timeStamp: t
                });
                let l = s.clicksByButton[e.button];
                if (l.target === c.target && t - l.timeStamp < 200 ? ++l.clickCount : l.clickCount = 1,
                l.target = c.target,
                l.timeStamp = t,
                c.detail = l.clickCount,
                c.pointerType === "mouse") {
                    let u = c.button === 2;
                    this.dispatchEvent(c, u ? "rightclick" : "click")
                } else
                    c.pointerType === "touch" && this.dispatchEvent(c, "tap");
                this.dispatchEvent(c, "pointertap"),
                this.freeEvent(c)
            }
            this.freeEvent(r)
        }
        mapPointerUpOutside(e) {
            if (!(e instanceof Ot))
                return;
            let t = this.trackingData(e.pointerId)
              , r = this.findMountedTarget(t.pressTargetsByButton[e.button])
              , s = this.createPointerEvent(e);
            if (r) {
                let n = r;
                for (; n; )
                    s.currentTarget = n,
                    this.notifyTarget(s, "pointerupoutside"),
                    s.pointerType === "touch" ? this.notifyTarget(s, "touchendoutside") : (s.pointerType === "mouse" || s.pointerType === "pen") && this.notifyTarget(s, s.button === 2 ? "rightupoutside" : "mouseupoutside"),
                    n = n.parent;
                delete t.pressTargetsByButton[e.button]
            }
            this.freeEvent(s)
        }
        mapWheel(e) {
            if (!(e instanceof Ii))
                return;
            let t = this.createWheelEvent(e);
            this.dispatchEvent(t),
            this.freeEvent(t)
        }
        findMountedTarget(e) {
            if (!e)
                return null;
            let t = e[0];
            for (let r = 1; r < e.length && e[r].parent === t; r++)
                t = e[r];
            return t
        }
        createPointerEvent(e, t, r) {
            var s;
            let n = this.allocateEvent(Ot);
            return this.copyPointerData(e, n),
            this.copyMouseData(e, n),
            this.copyData(e, n),
            n.nativeEvent = e.nativeEvent,
            n.originalEvent = e,
            n.target = (s = r ?? this.hitTest(n.global.x, n.global.y)) != null ? s : this._hitElements[0],
            typeof t == "string" && (n.type = t),
            n
        }
        createWheelEvent(e) {
            let t = this.allocateEvent(Ii);
            return this.copyWheelData(e, t),
            this.copyMouseData(e, t),
            this.copyData(e, t),
            t.nativeEvent = e.nativeEvent,
            t.originalEvent = e,
            t.target = this.hitTest(t.global.x, t.global.y),
            t
        }
        clonePointerEvent(e, t) {
            let r = this.allocateEvent(Ot);
            return r.nativeEvent = e.nativeEvent,
            r.originalEvent = e.originalEvent,
            this.copyPointerData(e, r),
            this.copyMouseData(e, r),
            this.copyData(e, r),
            r.target = e.target,
            r.path = e.composedPath().slice(),
            r.type = t ?? r.type,
            r
        }
        copyWheelData(e, t) {
            t.deltaMode = e.deltaMode,
            t.deltaX = e.deltaX,
            t.deltaY = e.deltaY,
            t.deltaZ = e.deltaZ
        }
        copyPointerData(e, t) {
            e instanceof Ot && t instanceof Ot && (t.pointerId = e.pointerId,
            t.width = e.width,
            t.height = e.height,
            t.isPrimary = e.isPrimary,
            t.pointerType = e.pointerType,
            t.pressure = e.pressure,
            t.tangentialPressure = e.tangentialPressure,
            t.tiltX = e.tiltX,
            t.tiltY = e.tiltY,
            t.twist = e.twist)
        }
        copyMouseData(e, t) {
            e instanceof Ar && t instanceof Ar && (t.altKey = e.altKey,
            t.button = e.button,
            t.buttons = e.buttons,
            t.client.copyFrom(e.client),
            t.ctrlKey = e.ctrlKey,
            t.metaKey = e.metaKey,
            t.movement.copyFrom(e.movement),
            t.screen.copyFrom(e.screen),
            t.shiftKey = e.shiftKey,
            t.global.copyFrom(e.global))
        }
        copyData(e, t) {
            t.isTrusted = e.isTrusted,
            t.srcElement = e.srcElement,
            t.timeStamp = performance.now(),
            t.type = e.type,
            t.detail = e.detail,
            t.view = e.view,
            t.which = e.which,
            t.layer.copyFrom(e.layer),
            t.page.copyFrom(e.page)
        }
        trackingData(e) {
            return this.mappingState.trackingData[e] || (this.mappingState.trackingData[e] = {
                pressTargetsByButton: {},
                clicksByButton: {},
                overTarget: null
            }),
            this.mappingState.trackingData[e]
        }
        allocateEvent(e) {
            this.eventPool.has(e) || this.eventPool.set(e, []);
            let t = this.eventPool.get(e).pop() || new e(this);
            return t.eventPhase = t.NONE,
            t.currentTarget = null,
            t.defaultPrevented = !1,
            t.path = null,
            t.target = null,
            t
        }
        freeEvent(e) {
            if (e.manager !== this)
                throw new Error("It is illegal to free an event not managed by this EventBoundary!");
            let t = e.constructor;
            this.eventPool.has(t) || this.eventPool.set(t, []),
            this.eventPool.get(t).push(e)
        }
        _notifyListeners(e, t) {
            let r = e.currentTarget._events[t];
            if (r)
                if ("fn"in r)
                    r.once && e.currentTarget.removeListener(t, r.fn, void 0, !0),
                    r.fn.call(r.context, e);
                else
                    for (let s = 0, n = r.length; s < n && !e.propagationImmediatelyStopped; s++)
                        r[s].once && e.currentTarget.removeListener(t, r[s].fn, void 0, !0),
                        r[s].fn.call(r[s].context, e)
        }
    }
      , U_ = Object.defineProperty
      , Hu = Object.getOwnPropertySymbols
      , L_ = Object.prototype.hasOwnProperty
      , N_ = Object.prototype.propertyIsEnumerable
      , zu = (i, e, t) => e in i ? U_(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , X_ = (i, e) => {
        for (var t in e || (e = {}))
            L_.call(e, t) && zu(i, t, e[t]);
        if (Hu)
            for (var t of Hu(e))
                N_.call(e, t) && zu(i, t, e[t]);
        return i
    }
      , j_ = 1
      , H_ = {
        touchstart: "pointerdown",
        touchend: "pointerup",
        touchendoutside: "pointerupoutside",
        touchmove: "pointermove",
        touchcancel: "pointercancel"
    }
      , Lc = class Nc {
        constructor(e) {
            this.supportsTouchEvents = "ontouchstart"in globalThis,
            this.supportsPointerEvents = !!globalThis.PointerEvent,
            this.domElement = null,
            this.resolution = 1,
            this.renderer = e,
            this.rootBoundary = new Uc(null),
            fi.init(this),
            this.autoPreventDefault = !0,
            this._eventsAdded = !1,
            this._rootPointerEvent = new Ot(null),
            this._rootWheelEvent = new Ii(null),
            this.cursorStyles = {
                default: "inherit",
                pointer: "pointer"
            },
            this.features = new Proxy(X_({}, Nc.defaultEventFeatures),{
                set: (t, r, s) => (r === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = s),
                t[r] = s,
                !0)
            }),
            this._onPointerDown = this._onPointerDown.bind(this),
            this._onPointerMove = this._onPointerMove.bind(this),
            this._onPointerUp = this._onPointerUp.bind(this),
            this._onPointerOverOut = this._onPointerOverOut.bind(this),
            this.onWheel = this.onWheel.bind(this)
        }
        static get defaultEventMode() {
            return this._defaultEventMode
        }
        init(e) {
            var t, r;
            let {canvas: s, resolution: n} = this.renderer;
            this.setTargetElement(s),
            this.resolution = n,
            Nc._defaultEventMode = (t = e.eventMode) != null ? t : "passive",
            Object.assign(this.features, (r = e.eventFeatures) != null ? r : {}),
            this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove
        }
        resolutionChange(e) {
            this.resolution = e
        }
        destroy() {
            fi.destroy(),
            this.setTargetElement(null),
            this.renderer = null,
            this._currentCursor = null
        }
        setCursor(e) {
            e || (e = "default");
            let t = !0;
            if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (t = !1),
            this._currentCursor === e)
                return;
            this._currentCursor = e;
            let r = this.cursorStyles[e];
            if (r)
                switch (typeof r) {
                case "string":
                    t && (this.domElement.style.cursor = r);
                    break;
                case "function":
                    r(e);
                    break;
                case "object":
                    t && Object.assign(this.domElement.style, r);
                    break
                }
            else
                t && typeof e == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.domElement.style.cursor = e)
        }
        get pointer() {
            return this._rootPointerEvent
        }
        _onPointerDown(e) {
            if (!this.features.click)
                return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
            let t = this._normalizeToPointerData(e);
            this.autoPreventDefault && t[0].isNormalized && (e.cancelable || !("cancelable"in e)) && e.preventDefault();
            for (let r = 0, s = t.length; r < s; r++) {
                let n = t[r]
                  , a = this._bootstrapEvent(this._rootPointerEvent, n);
                this.rootBoundary.mapEvent(a)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        _onPointerMove(e) {
            if (!this.features.move)
                return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
            fi.pointerMoved();
            let t = this._normalizeToPointerData(e);
            for (let r = 0, s = t.length; r < s; r++) {
                let n = this._bootstrapEvent(this._rootPointerEvent, t[r]);
                this.rootBoundary.mapEvent(n)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        _onPointerUp(e) {
            if (!this.features.click)
                return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
            let t = e.target;
            e.composedPath && e.composedPath().length > 0 && (t = e.composedPath()[0]);
            let r = t !== this.domElement ? "outside" : ""
              , s = this._normalizeToPointerData(e);
            for (let n = 0, a = s.length; n < a; n++) {
                let c = this._bootstrapEvent(this._rootPointerEvent, s[n]);
                c.type += r,
                this.rootBoundary.mapEvent(c)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        _onPointerOverOut(e) {
            if (!this.features.click)
                return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
            let t = this._normalizeToPointerData(e);
            for (let r = 0, s = t.length; r < s; r++) {
                let n = this._bootstrapEvent(this._rootPointerEvent, t[r]);
                this.rootBoundary.mapEvent(n)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onWheel(e) {
            if (!this.features.wheel)
                return;
            let t = this.normalizeWheelEvent(e);
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
            this.rootBoundary.mapEvent(t)
        }
        setTargetElement(e) {
            this._removeEvents(),
            this.domElement = e,
            fi.domElement = e,
            this._addEvents()
        }
        _addEvents() {
            if (this._eventsAdded || !this.domElement)
                return;
            fi.addTickerListener();
            let e = this.domElement.style;
            e && (globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "none",
            e.msTouchAction = "none") : this.supportsPointerEvents && (e.touchAction = "none")),
            this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this._onPointerMove, !0),
            this.domElement.addEventListener("pointerdown", this._onPointerDown, !0),
            this.domElement.addEventListener("pointerleave", this._onPointerOverOut, !0),
            this.domElement.addEventListener("pointerover", this._onPointerOverOut, !0),
            globalThis.addEventListener("pointerup", this._onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this._onPointerMove, !0),
            this.domElement.addEventListener("mousedown", this._onPointerDown, !0),
            this.domElement.addEventListener("mouseout", this._onPointerOverOut, !0),
            this.domElement.addEventListener("mouseover", this._onPointerOverOut, !0),
            globalThis.addEventListener("mouseup", this._onPointerUp, !0),
            this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this._onPointerDown, !0),
            this.domElement.addEventListener("touchend", this._onPointerUp, !0),
            this.domElement.addEventListener("touchmove", this._onPointerMove, !0))),
            this.domElement.addEventListener("wheel", this.onWheel, {
                passive: !0,
                capture: !0
            }),
            this._eventsAdded = !0
        }
        _removeEvents() {
            if (!this._eventsAdded || !this.domElement)
                return;
            fi.removeTickerListener();
            let e = this.domElement.style;
            e && (globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "",
            e.msTouchAction = "") : this.supportsPointerEvents && (e.touchAction = "")),
            this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this._onPointerMove, !0),
            this.domElement.removeEventListener("pointerdown", this._onPointerDown, !0),
            this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, !0),
            this.domElement.removeEventListener("pointerover", this._onPointerOverOut, !0),
            globalThis.removeEventListener("pointerup", this._onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this._onPointerMove, !0),
            this.domElement.removeEventListener("mousedown", this._onPointerDown, !0),
            this.domElement.removeEventListener("mouseout", this._onPointerOverOut, !0),
            this.domElement.removeEventListener("mouseover", this._onPointerOverOut, !0),
            globalThis.removeEventListener("mouseup", this._onPointerUp, !0),
            this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this._onPointerDown, !0),
            this.domElement.removeEventListener("touchend", this._onPointerUp, !0),
            this.domElement.removeEventListener("touchmove", this._onPointerMove, !0))),
            this.domElement.removeEventListener("wheel", this.onWheel, !0),
            this.domElement = null,
            this._eventsAdded = !1
        }
        mapPositionToPoint(e, t, r) {
            let s = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
                x: 0,
                y: 0,
                width: this.domElement.width,
                height: this.domElement.height,
                left: 0,
                top: 0
            }
              , n = 1 / this.resolution;
            e.x = (t - s.left) * (this.domElement.width / s.width) * n,
            e.y = (r - s.top) * (this.domElement.height / s.height) * n
        }
        _normalizeToPointerData(e) {
            let t = [];
            if (this.supportsTouchEvents && e instanceof TouchEvent)
                for (let r = 0, s = e.changedTouches.length; r < s; r++) {
                    let n = e.changedTouches[r];
                    typeof n.button > "u" && (n.button = 0),
                    typeof n.buttons > "u" && (n.buttons = 1),
                    typeof n.isPrimary > "u" && (n.isPrimary = e.touches.length === 1 && e.type === "touchstart"),
                    typeof n.width > "u" && (n.width = n.radiusX || 1),
                    typeof n.height > "u" && (n.height = n.radiusY || 1),
                    typeof n.tiltX > "u" && (n.tiltX = 0),
                    typeof n.tiltY > "u" && (n.tiltY = 0),
                    typeof n.pointerType > "u" && (n.pointerType = "touch"),
                    typeof n.pointerId > "u" && (n.pointerId = n.identifier || 0),
                    typeof n.pressure > "u" && (n.pressure = n.force || .5),
                    typeof n.twist > "u" && (n.twist = 0),
                    typeof n.tangentialPressure > "u" && (n.tangentialPressure = 0),
                    typeof n.layerX > "u" && (n.layerX = n.offsetX = n.clientX),
                    typeof n.layerY > "u" && (n.layerY = n.offsetY = n.clientY),
                    n.isNormalized = !0,
                    n.type = e.type,
                    t.push(n)
                }
            else if (!globalThis.MouseEvent || e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent))) {
                let r = e;
                typeof r.isPrimary > "u" && (r.isPrimary = !0),
                typeof r.width > "u" && (r.width = 1),
                typeof r.height > "u" && (r.height = 1),
                typeof r.tiltX > "u" && (r.tiltX = 0),
                typeof r.tiltY > "u" && (r.tiltY = 0),
                typeof r.pointerType > "u" && (r.pointerType = "mouse"),
                typeof r.pointerId > "u" && (r.pointerId = j_),
                typeof r.pressure > "u" && (r.pressure = .5),
                typeof r.twist > "u" && (r.twist = 0),
                typeof r.tangentialPressure > "u" && (r.tangentialPressure = 0),
                r.isNormalized = !0,
                t.push(r)
            } else
                t.push(e);
            return t
        }
        normalizeWheelEvent(e) {
            let t = this._rootWheelEvent;
            return this._transferMouseData(t, e),
            t.deltaX = e.deltaX,
            t.deltaY = e.deltaY,
            t.deltaZ = e.deltaZ,
            t.deltaMode = e.deltaMode,
            this.mapPositionToPoint(t.screen, e.clientX, e.clientY),
            t.global.copyFrom(t.screen),
            t.offset.copyFrom(t.screen),
            t.nativeEvent = e,
            t.type = e.type,
            t
        }
        _bootstrapEvent(e, t) {
            return e.originalEvent = null,
            e.nativeEvent = t,
            e.pointerId = t.pointerId,
            e.width = t.width,
            e.height = t.height,
            e.isPrimary = t.isPrimary,
            e.pointerType = t.pointerType,
            e.pressure = t.pressure,
            e.tangentialPressure = t.tangentialPressure,
            e.tiltX = t.tiltX,
            e.tiltY = t.tiltY,
            e.twist = t.twist,
            this._transferMouseData(e, t),
            this.mapPositionToPoint(e.screen, t.clientX, t.clientY),
            e.global.copyFrom(e.screen),
            e.offset.copyFrom(e.screen),
            e.isTrusted = t.isTrusted,
            e.type === "pointerleave" && (e.type = "pointerout"),
            e.type.startsWith("mouse") && (e.type = e.type.replace("mouse", "pointer")),
            e.type.startsWith("touch") && (e.type = H_[e.type] || e.type),
            e
        }
        _transferMouseData(e, t) {
            e.isTrusted = t.isTrusted,
            e.srcElement = t.srcElement,
            e.timeStamp = performance.now(),
            e.type = t.type,
            e.altKey = t.altKey,
            e.button = t.button,
            e.buttons = t.buttons,
            e.client.x = t.clientX,
            e.client.y = t.clientY,
            e.ctrlKey = t.ctrlKey,
            e.metaKey = t.metaKey,
            e.movement.x = t.movementX,
            e.movement.y = t.movementY,
            e.page.x = t.pageX,
            e.page.y = t.pageY,
            e.relatedTarget = null,
            e.shiftKey = t.shiftKey
        }
    }
    ;
    Lc.extension = {
        name: "events",
        type: [B.WebGLSystem, B.CanvasSystem, B.WebGPUSystem],
        priority: -1
    },
    Lc.defaultEventFeatures = {
        move: !0,
        globalMove: !0,
        click: !0,
        wheel: !0
    };
    var t0 = Lc
      , z_ = {
        onclick: null,
        onmousedown: null,
        onmouseenter: null,
        onmouseleave: null,
        onmousemove: null,
        onglobalmousemove: null,
        onmouseout: null,
        onmouseover: null,
        onmouseup: null,
        onmouseupoutside: null,
        onpointercancel: null,
        onpointerdown: null,
        onpointerenter: null,
        onpointerleave: null,
        onpointermove: null,
        onglobalpointermove: null,
        onpointerout: null,
        onpointerover: null,
        onpointertap: null,
        onpointerup: null,
        onpointerupoutside: null,
        onrightclick: null,
        onrightdown: null,
        onrightup: null,
        onrightupoutside: null,
        ontap: null,
        ontouchcancel: null,
        ontouchend: null,
        ontouchendoutside: null,
        ontouchmove: null,
        onglobaltouchmove: null,
        ontouchstart: null,
        onwheel: null,
        get interactive() {
            return this.eventMode === "dynamic" || this.eventMode === "static"
        },
        set interactive(i) {
            this.eventMode = i ? "static" : "passive"
        },
        _internalEventMode: void 0,
        get eventMode() {
            var i;
            return (i = this._internalEventMode) != null ? i : t0.defaultEventMode
        },
        set eventMode(i) {
            this._internalEventMode = i
        },
        isInteractive() {
            return this.eventMode === "static" || this.eventMode === "dynamic"
        },
        interactiveChildren: !0,
        hitArea: null,
        addEventListener(i, e, t) {
            let r = typeof t == "boolean" && t || typeof t == "object" && t.capture
              , s = typeof t == "object" ? t.signal : void 0
              , n = typeof t == "object" ? t.once === !0 : !1
              , a = typeof e == "function" ? void 0 : e;
            i = r ? `${i}capture` : i;
            let c = typeof e == "function" ? e : e.handleEvent
              , l = this;
            s && s.addEventListener("abort", () => {
                l.off(i, c, a)
            }
            ),
            n ? l.once(i, c, a) : l.on(i, c, a)
        },
        removeEventListener(i, e, t) {
            let r = typeof t == "boolean" && t || typeof t == "object" && t.capture
              , s = typeof e == "function" ? void 0 : e;
            i = r ? `${i}capture` : i,
            e = typeof e == "function" ? e : e.handleEvent,
            this.off(i, e, s)
        },
        dispatchEvent(i) {
            if (!(i instanceof fs))
                throw new Error("Container cannot propagate events outside of the Federated Events API");
            return i.defaultPrevented = !1,
            i.path = null,
            i.target = this,
            i.manager.dispatchEvent(i),
            !i.defaultPrevented
        }
    };
    be.add(t0),
    be.mixin(_e, z_);
    var vn = class {
        constructor(e) {
            this._attachedDomElements = [],
            this._renderer = e,
            this._renderer.runners.postrender.add(this),
            this._renderer.runners.init.add(this),
            this._domElement = document.createElement("div"),
            this._domElement.style.position = "absolute",
            this._domElement.style.top = "0",
            this._domElement.style.left = "0",
            this._domElement.style.pointerEvents = "none",
            this._domElement.style.zIndex = "1000"
        }
        init() {
            this._canvasObserver = new _n({
                domElement: this._domElement,
                renderer: this._renderer
            })
        }
        addRenderable(e, t) {
            this._attachedDomElements.includes(e) || this._attachedDomElements.push(e)
        }
        updateRenderable(e) {}
        validateRenderable(e) {
            return !0
        }
        postrender() {
            let e = this._attachedDomElements;
            if (e.length === 0) {
                this._domElement.remove();
                return
            }
            this._canvasObserver.ensureAttached();
            for (let t = 0; t < e.length; t++) {
                let r = e[t]
                  , s = r.element;
                if (!r.parent || r.globalDisplayStatus < 7)
                    s?.remove(),
                    e.splice(t, 1),
                    t--;
                else {
                    this._domElement.contains(s) || (s.style.position = "absolute",
                    s.style.pointerEvents = "auto",
                    this._domElement.appendChild(s));
                    let n = r.worldTransform
                      , a = r._anchor
                      , c = r.width * a.x
                      , l = r.height * a.y;
                    s.style.transformOrigin = `${c}px ${l}px`,
                    s.style.transform = `matrix(${n.a}, ${n.b}, ${n.c}, ${n.d}, ${n.tx - c}, ${n.ty - l})`,
                    s.style.opacity = r.groupAlpha.toString()
                }
            }
        }
        destroy() {
            var e;
            this._renderer.runners.postrender.remove(this);
            for (let t = 0; t < this._attachedDomElements.length; t++)
                (e = this._attachedDomElements[t].element) == null || e.remove();
            this._attachedDomElements.length = 0,
            this._domElement.remove(),
            this._canvasObserver.destroy(),
            this._renderer = null
        }
    }
    ;
    vn.extension = {
        type: [B.WebGLPipes, B.WebGPUPipes, B.CanvasPipes],
        name: "dom"
    };
    var _i = class extends _e {
        constructor(e) {
            super(e),
            this.canBundle = !0,
            this.allowChildren = !1,
            this._roundPixels = 0,
            this._lastUsed = -1,
            this._gpuData = Object.create(null),
            this._bounds = new at(0,1,0,0),
            this._boundsDirty = !0
        }
        get bounds() {
            return this._boundsDirty ? (this.updateBounds(),
            this._boundsDirty = !1,
            this._bounds) : this._bounds
        }
        get roundPixels() {
            return !!this._roundPixels
        }
        set roundPixels(e) {
            this._roundPixels = e ? 1 : 0
        }
        containsPoint(e) {
            let t = this.bounds
              , {x: r, y: s} = e;
            return r >= t.minX && r <= t.maxX && s >= t.minY && s <= t.maxY
        }
        onViewUpdate() {
            if (this._didViewChangeTick++,
            this._boundsDirty = !0,
            this.didViewUpdate)
                return;
            this.didViewUpdate = !0;
            let e = this.renderGroup || this.parentRenderGroup;
            e && e.onChildViewUpdate(this)
        }
        destroy(e) {
            var t, r;
            super.destroy(e),
            this._bounds = null;
            for (let s in this._gpuData)
                (r = (t = this._gpuData[s]).destroy) == null || r.call(t);
            this._gpuData = null
        }
        collectRenderablesSimple(e, t, r) {
            let {renderPipes: s} = t;
            s.blendMode.pushBlendMode(this, this.groupBlendMode, e),
            s[this.renderPipeId].addRenderable(this, e),
            this.didViewUpdate = !1;
            let n = this.children
              , a = n.length;
            for (let c = 0; c < a; c++)
                n[c].collectRenderables(e, t, r);
            s.blendMode.popBlendMode(e)
        }
    }
    ;
    be.add(vn);
    var jt = (i => (i[i.Low = 0] = "Low",
    i[i.Normal = 1] = "Normal",
    i[i.High = 2] = "High",
    i))(jt || {})
      , V_ = {
        createCanvas: (i, e) => {
            let t = document.createElement("canvas");
            return t.width = i,
            t.height = e,
            t
        }
        ,
        createImage: () => new Image,
        getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
        getWebGLRenderingContext: () => WebGLRenderingContext,
        getNavigator: () => navigator,
        getBaseUrl: () => {
            var i;
            return (i = document.baseURI) != null ? i : window.location.href
        }
        ,
        getFontFaceSet: () => document.fonts,
        fetch: (i, e) => fetch(i, e),
        parseXML: i => new DOMParser().parseFromString(i, "text/xml")
    }
      , Vu = V_
      , xe = {
        get() {
            return Vu
        },
        set(i) {
            Vu = i
        }
    };
    function $t(i) {
        if (typeof i != "string")
            throw new TypeError(`Path must be a string. Received ${JSON.stringify(i)}`)
    }
    function Dr(i) {
        return i.split("?")[0].split("#")[0]
    }
    function W_(i) {
        return i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
    }
    function Y_(i, e, t) {
        return i.replace(new RegExp(W_(e),"g"), t)
    }
    function $_(i, e) {
        let t = ""
          , r = 0
          , s = -1
          , n = 0
          , a = -1;
        for (let c = 0; c <= i.length; ++c) {
            if (c < i.length)
                a = i.charCodeAt(c);
            else {
                if (a === 47)
                    break;
                a = 47
            }
            if (a === 47) {
                if (!(s === c - 1 || n === 1))
                    if (s !== c - 1 && n === 2) {
                        if (t.length < 2 || r !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {
                            if (t.length > 2) {
                                let l = t.lastIndexOf("/");
                                if (l !== t.length - 1) {
                                    l === -1 ? (t = "",
                                    r = 0) : (t = t.slice(0, l),
                                    r = t.length - 1 - t.lastIndexOf("/")),
                                    s = c,
                                    n = 0;
                                    continue
                                }
                            } else if (t.length === 2 || t.length === 1) {
                                t = "",
                                r = 0,
                                s = c,
                                n = 0;
                                continue
                            }
                        }
                        e && (t.length > 0 ? t += "/.." : t = "..",
                        r = 2)
                    } else
                        t.length > 0 ? t += `/${i.slice(s + 1, c)}` : t = i.slice(s + 1, c),
                        r = c - s - 1;
                s = c,
                n = 0
            } else
                a === 46 && n !== -1 ? ++n : n = -1
        }
        return t
    }
    var Gt = {
        toPosix(i) {
            return Y_(i, "\\", "/")
        },
        isUrl(i) {
            return /^https?:/.test(this.toPosix(i))
        },
        isDataUrl(i) {
            return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(i)
        },
        isBlobUrl(i) {
            return i.startsWith("blob:")
        },
        hasProtocol(i) {
            return /^[^/:]+:/.test(this.toPosix(i))
        },
        getProtocol(i) {
            $t(i),
            i = this.toPosix(i);
            let e = /^file:\/\/\//.exec(i);
            if (e)
                return e[0];
            let t = /^[^/:]+:\/{0,2}/.exec(i);
            return t ? t[0] : ""
        },
        toAbsolute(i, e, t) {
            if ($t(i),
            this.isDataUrl(i) || this.isBlobUrl(i))
                return i;
            let r = Dr(this.toPosix(e ?? xe.get().getBaseUrl()))
              , s = Dr(this.toPosix(t ?? this.rootname(r)));
            return i = this.toPosix(i),
            i.startsWith("/") ? Gt.join(s, i.slice(1)) : this.isAbsolute(i) ? i : this.join(r, i)
        },
        normalize(i) {
            if ($t(i),
            i.length === 0)
                return ".";
            if (this.isDataUrl(i) || this.isBlobUrl(i))
                return i;
            i = this.toPosix(i);
            let e = ""
              , t = i.startsWith("/");
            this.hasProtocol(i) && (e = this.rootname(i),
            i = i.slice(e.length));
            let r = i.endsWith("/");
            return i = $_(i, !1),
            i.length > 0 && r && (i += "/"),
            t ? `/${i}` : e + i
        },
        isAbsolute(i) {
            return $t(i),
            i = this.toPosix(i),
            this.hasProtocol(i) ? !0 : i.startsWith("/")
        },
        join(...i) {
            var e;
            if (i.length === 0)
                return ".";
            let t;
            for (let r = 0; r < i.length; ++r) {
                let s = i[r];
                if ($t(s),
                s.length > 0)
                    if (t === void 0)
                        t = s;
                    else {
                        let n = (e = i[r - 1]) != null ? e : "";
                        this.joinExtensions.includes(this.extname(n).toLowerCase()) ? t += `/../${s}` : t += `/${s}`
                    }
            }
            return t === void 0 ? "." : this.normalize(t)
        },
        dirname(i) {
            if ($t(i),
            i.length === 0)
                return ".";
            i = this.toPosix(i);
            let e = i.charCodeAt(0)
              , t = e === 47
              , r = -1
              , s = !0
              , n = this.getProtocol(i)
              , a = i;
            i = i.slice(n.length);
            for (let c = i.length - 1; c >= 1; --c)
                if (e = i.charCodeAt(c),
                e === 47) {
                    if (!s) {
                        r = c;
                        break
                    }
                } else
                    s = !1;
            return r === -1 ? t ? "/" : this.isUrl(a) ? n + i : n : t && r === 1 ? "//" : n + i.slice(0, r)
        },
        rootname(i) {
            $t(i),
            i = this.toPosix(i);
            let e = "";
            if (i.startsWith("/") ? e = "/" : e = this.getProtocol(i),
            this.isUrl(i)) {
                let t = i.indexOf("/", e.length);
                t !== -1 ? e = i.slice(0, t) : e = i,
                e.endsWith("/") || (e += "/")
            }
            return e
        },
        basename(i, e) {
            $t(i),
            e && $t(e),
            i = Dr(this.toPosix(i));
            let t = 0, r = -1, s = !0, n;
            if (e !== void 0 && e.length > 0 && e.length <= i.length) {
                if (e.length === i.length && e === i)
                    return "";
                let a = e.length - 1
                  , c = -1;
                for (n = i.length - 1; n >= 0; --n) {
                    let l = i.charCodeAt(n);
                    if (l === 47) {
                        if (!s) {
                            t = n + 1;
                            break
                        }
                    } else
                        c === -1 && (s = !1,
                        c = n + 1),
                        a >= 0 && (l === e.charCodeAt(a) ? --a === -1 && (r = n) : (a = -1,
                        r = c))
                }
                return t === r ? r = c : r === -1 && (r = i.length),
                i.slice(t, r)
            }
            for (n = i.length - 1; n >= 0; --n)
                if (i.charCodeAt(n) === 47) {
                    if (!s) {
                        t = n + 1;
                        break
                    }
                } else
                    r === -1 && (s = !1,
                    r = n + 1);
            return r === -1 ? "" : i.slice(t, r)
        },
        extname(i) {
            $t(i),
            i = Dr(this.toPosix(i));
            let e = -1
              , t = 0
              , r = -1
              , s = !0
              , n = 0;
            for (let a = i.length - 1; a >= 0; --a) {
                let c = i.charCodeAt(a);
                if (c === 47) {
                    if (!s) {
                        t = a + 1;
                        break
                    }
                    continue
                }
                r === -1 && (s = !1,
                r = a + 1),
                c === 46 ? e === -1 ? e = a : n !== 1 && (n = 1) : e !== -1 && (n = -1)
            }
            return e === -1 || r === -1 || n === 0 || n === 1 && e === r - 1 && e === t + 1 ? "" : i.slice(e, r)
        },
        parse(i) {
            $t(i);
            let e = {
                root: "",
                dir: "",
                base: "",
                ext: "",
                name: ""
            };
            if (i.length === 0)
                return e;
            i = Dr(this.toPosix(i));
            let t = i.charCodeAt(0), r = this.isAbsolute(i), s, n = "";
            e.root = this.rootname(i),
            r || this.hasProtocol(i) ? s = 1 : s = 0;
            let a = -1
              , c = 0
              , l = -1
              , u = !0
              , d = i.length - 1
              , f = 0;
            for (; d >= s; --d) {
                if (t = i.charCodeAt(d),
                t === 47) {
                    if (!u) {
                        c = d + 1;
                        break
                    }
                    continue
                }
                l === -1 && (u = !1,
                l = d + 1),
                t === 46 ? a === -1 ? a = d : f !== 1 && (f = 1) : a !== -1 && (f = -1)
            }
            return a === -1 || l === -1 || f === 0 || f === 1 && a === l - 1 && a === c + 1 ? l !== -1 && (c === 0 && r ? e.base = e.name = i.slice(1, l) : e.base = e.name = i.slice(c, l)) : (c === 0 && r ? (e.name = i.slice(1, a),
            e.base = i.slice(1, l)) : (e.name = i.slice(c, a),
            e.base = i.slice(c, l)),
            e.ext = i.slice(a, l)),
            e.dir = this.dirname(i),
            n && (e.dir = n + e.dir),
            e
        },
        sep: "/",
        delimiter: ":",
        joinExtensions: [".html"]
    }
      , qt = (i, e, t=!1) => (Array.isArray(i) || (i = [i]),
    e ? i.map(r => typeof r == "string" || t ? e(r) : r) : i);
    function i0(i, e, t, r, s) {
        let n = e[t];
        for (let a = 0; a < n.length; a++) {
            let c = n[a];
            t < e.length - 1 ? i0(i.replace(r[t], c), e, t + 1, r, s) : s.push(i.replace(r[t], c))
        }
    }
    function K_(i) {
        let e = /\{(.*?)\}/g
          , t = i.match(e)
          , r = [];
        if (t) {
            let s = [];
            t.forEach(n => {
                let a = n.substring(1, n.length - 1).split(",");
                s.push(a)
            }
            ),
            i0(i, s, 0, t, r)
        } else
            r.push(i);
        return r
    }
    var Tn = i => !Array.isArray(i)
      , q_ = Object.defineProperty
      , Z_ = Object.defineProperties
      , Q_ = Object.getOwnPropertyDescriptors
      , Wu = Object.getOwnPropertySymbols
      , J_ = Object.prototype.hasOwnProperty
      , e2 = Object.prototype.propertyIsEnumerable
      , Yu = (i, e, t) => e in i ? q_(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , cr = (i, e) => {
        for (var t in e || (e = {}))
            J_.call(e, t) && Yu(i, t, e[t]);
        if (Wu)
            for (var t of Wu(e))
                e2.call(e, t) && Yu(i, t, e[t]);
        return i
    }
      , t2 = (i, e) => Z_(i, Q_(e))
      , xi = class {
        constructor() {
            this._defaultBundleIdentifierOptions = {
                connector: "-",
                createBundleAssetId: (e, t) => `${e}${this._bundleIdConnector}${t}`,
                extractAssetIdFromBundle: (e, t) => t.replace(`${e}${this._bundleIdConnector}`, "")
            },
            this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector,
            this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId,
            this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle,
            this._assetMap = {},
            this._preferredOrder = [],
            this._parsers = [],
            this._resolverHash = {},
            this._bundles = {}
        }
        setBundleIdentifier(e) {
            var t, r, s;
            if (this._bundleIdConnector = (t = e.connector) != null ? t : this._bundleIdConnector,
            this._createBundleAssetId = (r = e.createBundleAssetId) != null ? r : this._createBundleAssetId,
            this._extractAssetIdFromBundle = (s = e.extractAssetIdFromBundle) != null ? s : this._extractAssetIdFromBundle,
            this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar")
                throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")
        }
        prefer(...e) {
            e.forEach(t => {
                this._preferredOrder.push(t),
                t.priority || (t.priority = Object.keys(t.params))
            }
            ),
            this._resolverHash = {}
        }
        set basePath(e) {
            this._basePath = e
        }
        get basePath() {
            return this._basePath
        }
        set rootPath(e) {
            this._rootPath = e
        }
        get rootPath() {
            return this._rootPath
        }
        get parsers() {
            return this._parsers
        }
        reset() {
            this.setBundleIdentifier(this._defaultBundleIdentifierOptions),
            this._assetMap = {},
            this._preferredOrder = [],
            this._resolverHash = {},
            this._rootPath = null,
            this._basePath = null,
            this._manifest = null,
            this._bundles = {},
            this._defaultSearchParams = null
        }
        setDefaultSearchParams(e) {
            if (typeof e == "string")
                this._defaultSearchParams = e;
            else {
                let t = e;
                this._defaultSearchParams = Object.keys(t).map(r => `${encodeURIComponent(r)}=${encodeURIComponent(t[r])}`).join("&")
            }
        }
        getAlias(e) {
            let {alias: t, src: r} = e;
            return qt(t || r, s => typeof s == "string" ? s : Array.isArray(s) ? s.map(n => {
                var a;
                return (a = n?.src) != null ? a : n
            }
            ) : s != null && s.src ? s.src : s, !0)
        }
        addManifest(e) {
            this._manifest,
            this._manifest = e,
            e.bundles.forEach(t => {
                this.addBundle(t.name, t.assets)
            }
            )
        }
        addBundle(e, t) {
            let r = []
              , s = t;
            Array.isArray(t) || (s = Object.entries(t).map( ([n,a]) => typeof a == "string" || Array.isArray(a) ? {
                alias: n,
                src: a
            } : cr({
                alias: n
            }, a))),
            s.forEach(n => {
                let a = n.src, c = n.alias, l;
                if (typeof c == "string") {
                    let u = this._createBundleAssetId(e, c);
                    r.push(u),
                    l = [c, u]
                } else {
                    let u = c.map(d => this._createBundleAssetId(e, d));
                    r.push(...u),
                    l = [...c, ...u]
                }
                this.add(t2(cr({}, n), {
                    alias: l,
                    src: a
                }))
            }
            ),
            this._bundles[e] = r
        }
        add(e) {
            let t = [];
            Array.isArray(e) ? t.push(...e) : t.push(e);
            let r;
            qt(t).forEach(s => {
                let {src: n} = s
                  , {data: a, format: c, loadParser: l, parser: u} = s
                  , d = qt(n).map(m => typeof m == "string" ? K_(m) : Array.isArray(m) ? m : [m])
                  , f = this.getAlias(s)
                  , b = [];
                d.forEach(m => {
                    m.forEach(x => {
                        var y, S, A, E;
                        let O = {};
                        if (typeof x != "object") {
                            O.src = x;
                            for (let M = 0; M < this._parsers.length; M++) {
                                let j = this._parsers[M];
                                if (j.test(x)) {
                                    O = j.parse(x);
                                    break
                                }
                            }
                        } else
                            a = (y = x.data) != null ? y : a,
                            c = (S = x.format) != null ? S : c,
                            (x.loadParser || x.parser) && (l = (A = x.loadParser) != null ? A : l,
                            u = (E = x.parser) != null ? E : u),
                            O = cr(cr({}, O), x);
                        if (!f)
                            throw new Error(`[Resolver] alias is undefined for this asset: ${O.src}`);
                        O = this._buildResolvedAsset(O, {
                            aliases: f,
                            data: a,
                            format: c,
                            loadParser: l,
                            parser: u
                        }),
                        b.push(O)
                    }
                    )
                }
                ),
                f.forEach(m => {
                    this._assetMap[m] = b
                }
                )
            }
            )
        }
        resolveBundle(e) {
            let t = Tn(e);
            e = qt(e);
            let r = {};
            return e.forEach(s => {
                let n = this._bundles[s];
                if (n) {
                    let a = this.resolve(n)
                      , c = {};
                    for (let l in a) {
                        let u = a[l];
                        c[this._extractAssetIdFromBundle(s, l)] = u
                    }
                    r[s] = c
                }
            }
            ),
            t ? r[e[0]] : r
        }
        resolveUrl(e) {
            let t = this.resolve(e);
            if (typeof e != "string") {
                let r = {};
                for (let s in t)
                    r[s] = t[s].src;
                return r
            }
            return t.src
        }
        resolve(e) {
            let t = Tn(e);
            e = qt(e);
            let r = {};
            return e.forEach(s => {
                if (!this._resolverHash[s])
                    if (this._assetMap[s]) {
                        let n = this._assetMap[s]
                          , a = this._getPreferredOrder(n);
                        a?.priority.forEach(c => {
                            a.params[c].forEach(l => {
                                let u = n.filter(d => d[c] ? d[c] === l : !1);
                                u.length && (n = u)
                            }
                            )
                        }
                        ),
                        this._resolverHash[s] = n[0]
                    } else
                        this._resolverHash[s] = this._buildResolvedAsset({
                            alias: [s],
                            src: s
                        }, {});
                r[s] = this._resolverHash[s]
            }
            ),
            t ? r[e[0]] : r
        }
        hasKey(e) {
            return !!this._assetMap[e]
        }
        hasBundle(e) {
            return !!this._bundles[e]
        }
        _getPreferredOrder(e) {
            for (let t = 0; t < e.length; t++) {
                let r = e[t]
                  , s = this._preferredOrder.find(n => n.params.format.includes(r.format));
                if (s)
                    return s
            }
            return this._preferredOrder[0]
        }
        _appendDefaultSearchParams(e) {
            if (!this._defaultSearchParams)
                return e;
            let t = /\?/.test(e) ? "&" : "?";
            return `${e}${t}${this._defaultSearchParams}`
        }
        _buildResolvedAsset(e, t) {
            var r, s;
            let {aliases: n, data: a, loadParser: c, parser: l, format: u} = t;
            return (this._basePath || this._rootPath) && (e.src = Gt.toAbsolute(e.src, this._basePath, this._rootPath)),
            e.alias = (r = n ?? e.alias) != null ? r : [e.src],
            e.src = this._appendDefaultSearchParams(e.src),
            e.data = cr(cr({}, a || {}), e.data),
            e.loadParser = c ?? e.loadParser,
            e.parser = l ?? e.parser,
            e.format = (s = u ?? e.format) != null ? s : i2(e.src),
            e
        }
    }
    ;
    xi.RETINA_PREFIX = /@([0-9\.]+)x/;
    function i2(i) {
        return i.split(".").pop().split("?").shift().split("#").shift()
    }
    var Xc = (i, e) => {
        let t = e.split("?")[1];
        return t && (i += `?${t}`),
        i
    }
      , r0 = class Zr {
        constructor(e, t) {
            this.linkedSheets = [];
            let r = e;
            e?.source instanceof He && (r = {
                texture: e,
                data: t
            });
            let {texture: s, data: n, cachePrefix: a=""} = r;
            this.cachePrefix = a,
            this._texture = s instanceof Z ? s : null,
            this.textureSource = s.source,
            this.textures = {},
            this.animations = {},
            this.data = n;
            let c = parseFloat(n.meta.scale);
            c ? (this.resolution = c,
            s.source.resolution = this.resolution) : this.resolution = s.source._resolution,
            this._frames = this.data.frames,
            this._frameKeys = Object.keys(this._frames),
            this._batchIndex = 0,
            this._callback = null
        }
        parse() {
            return new Promise(e => {
                this._callback = e,
                this._batchIndex = 0,
                this._frameKeys.length <= Zr.BATCH_SIZE ? (this._processFrames(0),
                this._processAnimations(),
                this._parseComplete()) : this._nextBatch()
            }
            )
        }
        _processFrames(e) {
            let t = e
              , r = Zr.BATCH_SIZE;
            for (; t - e < r && t < this._frameKeys.length; ) {
                let s = this._frameKeys[t]
                  , n = this._frames[s]
                  , a = n.frame;
                if (a) {
                    let c = null
                      , l = null
                      , u = n.trimmed !== !1 && n.sourceSize ? n.sourceSize : n.frame
                      , d = new Re(0,0,Math.floor(u.w) / this.resolution,Math.floor(u.h) / this.resolution);
                    n.rotated ? c = new Re(Math.floor(a.x) / this.resolution,Math.floor(a.y) / this.resolution,Math.floor(a.h) / this.resolution,Math.floor(a.w) / this.resolution) : c = new Re(Math.floor(a.x) / this.resolution,Math.floor(a.y) / this.resolution,Math.floor(a.w) / this.resolution,Math.floor(a.h) / this.resolution),
                    n.trimmed !== !1 && n.spriteSourceSize && (l = new Re(Math.floor(n.spriteSourceSize.x) / this.resolution,Math.floor(n.spriteSourceSize.y) / this.resolution,Math.floor(a.w) / this.resolution,Math.floor(a.h) / this.resolution)),
                    this.textures[s] = new Z({
                        source: this.textureSource,
                        frame: c,
                        orig: d,
                        trim: l,
                        rotate: n.rotated ? 2 : 0,
                        defaultAnchor: n.anchor,
                        defaultBorders: n.borders,
                        label: s.toString()
                    })
                }
                t++
            }
        }
        _processAnimations() {
            let e = this.data.animations || {};
            for (let t in e) {
                this.animations[t] = [];
                for (let r = 0; r < e[t].length; r++) {
                    let s = e[t][r];
                    this.animations[t].push(this.textures[s])
                }
            }
        }
        _parseComplete() {
            let e = this._callback;
            this._callback = null,
            this._batchIndex = 0,
            e.call(this, this.textures)
        }
        _nextBatch() {
            this._processFrames(this._batchIndex * Zr.BATCH_SIZE),
            this._batchIndex++,
            setTimeout( () => {
                this._batchIndex * Zr.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(),
                this._parseComplete())
            }
            , 0)
        }
        destroy(e=!1) {
            var t;
            for (let r in this.textures)
                this.textures[r].destroy();
            this._frames = null,
            this._frameKeys = null,
            this.data = null,
            this.textures = null,
            e && ((t = this._texture) == null || t.destroy(),
            this.textureSource.destroy()),
            this._texture = null,
            this.textureSource = null,
            this.linkedSheets = []
        }
    }
    ;
    r0.BATCH_SIZE = 1e3;
    var $u = r0
      , r2 = ["jpg", "png", "jpeg", "avif", "webp", "basis", "etc2", "bc7", "bc6h", "bc5", "bc4", "bc3", "bc2", "bc1", "eac", "astc"];
    function s0(i, e, t) {
        let r = {};
        if (i.forEach(s => {
            r[s] = e
        }
        ),
        Object.keys(e.textures).forEach(s => {
            r[`${e.cachePrefix}${s}`] = e.textures[s]
        }
        ),
        !t) {
            let s = Gt.dirname(i[0]);
            e.linkedSheets.forEach( (n, a) => {
                let c = s0([`${s}/${e.data.meta.related_multi_packs[a]}`], n, !0);
                Object.assign(r, c)
            }
            )
        }
        return r
    }
    var s2 = {
        extension: B.Asset,
        cache: {
            test: i => i instanceof $u,
            getCacheableAssets: (i, e) => s0(i, e, !1)
        },
        resolver: {
            extension: {
                type: B.ResolveParser,
                name: "resolveSpritesheet"
            },
            test: i => {
                let e = i.split("?")[0].split(".")
                  , t = e.pop()
                  , r = e.pop();
                return t === "json" && r2.includes(r)
            }
            ,
            parse: i => {
                var e, t;
                let r = i.split(".");
                return {
                    resolution: parseFloat((t = (e = xi.RETINA_PREFIX.exec(i)) == null ? void 0 : e[1]) != null ? t : "1"),
                    format: r[r.length - 2],
                    src: i
                }
            }
        },
        loader: {
            name: "spritesheetLoader",
            id: "spritesheet",
            extension: {
                type: B.LoadParser,
                priority: jt.Normal,
                name: "spritesheetLoader"
            },
            async testParse(i, e) {
                return Gt.extname(e.src).toLowerCase() === ".json" && !!i.frames
            },
            async parse(i, e, t) {
                var r, s, n;
                let {texture: a, imageFilename: c, textureOptions: l, cachePrefix: u} = (r = e?.data) != null ? r : {}
                  , d = Gt.dirname(e.src);
                d && d.lastIndexOf("/") !== d.length - 1 && (d += "/");
                let f;
                if (a instanceof Z)
                    f = a;
                else {
                    let x = Xc(d + (c ?? i.meta.image), e.src);
                    f = (await t.load([{
                        src: x,
                        data: l
                    }]))[x]
                }
                let b = new $u({
                    texture: f.source,
                    data: i,
                    cachePrefix: u
                });
                await b.parse();
                let m = (s = i?.meta) == null ? void 0 : s.related_multi_packs;
                if (Array.isArray(m)) {
                    let x = [];
                    for (let S of m) {
                        if (typeof S != "string")
                            continue;
                        let A = d + S;
                        (n = e.data) != null && n.ignoreMultiPack || (A = Xc(A, e.src),
                        x.push(t.load({
                            src: A,
                            data: {
                                textureOptions: l,
                                ignoreMultiPack: !0
                            }
                        })))
                    }
                    let y = await Promise.all(x);
                    b.linkedSheets = y,
                    y.forEach(S => {
                        S.linkedSheets = [b].concat(b.linkedSheets.filter(A => A !== S))
                    }
                    )
                }
                return b
            },
            async unload(i, e, t) {
                await t.unload(i.textureSource._sourceOrigin),
                i.destroy(!1)
            }
        }
    };
    be.add(s2);
    function n0(i, e, t) {
        let {width: r, height: s} = t.orig
          , n = t.trim;
        if (n) {
            let a = n.width
              , c = n.height;
            i.minX = n.x - e._x * r,
            i.maxX = i.minX + a,
            i.minY = n.y - e._y * s,
            i.maxY = i.minY + c
        } else
            i.minX = -e._x * r,
            i.maxX = i.minX + r,
            i.minY = -e._y * s,
            i.maxY = i.minY + s
    }
    var n2 = Object.defineProperty
      , Sn = Object.getOwnPropertySymbols
      , a0 = Object.prototype.hasOwnProperty
      , o0 = Object.prototype.propertyIsEnumerable
      , Ku = (i, e, t) => e in i ? n2(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , a2 = (i, e) => {
        for (var t in e || (e = {}))
            a0.call(e, t) && Ku(i, t, e[t]);
        if (Sn)
            for (var t of Sn(e))
                o0.call(e, t) && Ku(i, t, e[t]);
        return i
    }
      , o2 = (i, e) => {
        var t = {};
        for (var r in i)
            a0.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && Sn)
            for (var r of Sn(i))
                e.indexOf(r) < 0 && o0.call(i, r) && (t[r] = i[r]);
        return t
    }
      , Ge = class i extends _i {
        constructor(e=Z.EMPTY) {
            e instanceof Z && (e = {
                texture: e
            });
            let t = e
              , {texture: r=Z.EMPTY, anchor: s, roundPixels: n, width: a, height: c} = t
              , l = o2(t, ["texture", "anchor", "roundPixels", "width", "height"]);
            super(a2({
                label: "Sprite"
            }, l)),
            this.renderPipeId = "sprite",
            this.batched = !0,
            this._visualBounds = {
                minX: 0,
                maxX: 1,
                minY: 0,
                maxY: 0
            },
            this._anchor = new We({
                _onUpdate: () => {
                    this.onViewUpdate()
                }
            }),
            s ? this.anchor = s : r.defaultAnchor && (this.anchor = r.defaultAnchor),
            this.texture = r,
            this.allowChildren = !1,
            this.roundPixels = n ?? !1,
            a !== void 0 && (this.width = a),
            c !== void 0 && (this.height = c)
        }
        static from(e, t=!1) {
            return e instanceof Z ? new i(e) : new i(Z.from(e, t))
        }
        set texture(e) {
            e || (e = Z.EMPTY);
            let t = this._texture;
            t !== e && (t && t.dynamic && t.off("update", this.onViewUpdate, this),
            e.dynamic && e.on("update", this.onViewUpdate, this),
            this._texture = e,
            this._width && this._setWidth(this._width, this._texture.orig.width),
            this._height && this._setHeight(this._height, this._texture.orig.height),
            this.onViewUpdate())
        }
        get texture() {
            return this._texture
        }
        get visualBounds() {
            return n0(this._visualBounds, this._anchor, this._texture),
            this._visualBounds
        }
        get sourceBounds() {
            return this.visualBounds
        }
        updateBounds() {
            let e = this._anchor
              , t = this._texture
              , r = this._bounds
              , {width: s, height: n} = t.orig;
            r.minX = -e._x * s,
            r.maxX = r.minX + s,
            r.minY = -e._y * n,
            r.maxY = r.minY + n
        }
        destroy(e=!1) {
            if (super.destroy(e),
            typeof e == "boolean" ? e : e?.texture) {
                let t = typeof e == "boolean" ? e : e?.textureSource;
                this._texture.destroy(t)
            }
            this._texture = null,
            this._visualBounds = null,
            this._bounds = null,
            this._anchor = null,
            this._gpuData = null
        }
        get anchor() {
            return this._anchor
        }
        set anchor(e) {
            typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
        }
        get width() {
            return Math.abs(this.scale.x) * this._texture.orig.width
        }
        set width(e) {
            this._setWidth(e, this._texture.orig.width),
            this._width = e
        }
        get height() {
            return Math.abs(this.scale.y) * this._texture.orig.height
        }
        set height(e) {
            this._setHeight(e, this._texture.orig.height),
            this._height = e
        }
        getSize(e) {
            return e || (e = {}),
            e.width = Math.abs(this.scale.x) * this._texture.orig.width,
            e.height = Math.abs(this.scale.y) * this._texture.orig.height,
            e
        }
        setSize(e, t) {
            var r;
            typeof e == "object" ? (t = (r = e.height) != null ? r : e.width,
            e = e.width) : t != null || (t = e),
            e !== void 0 && this._setWidth(e, this._texture.orig.width),
            t !== void 0 && this._setHeight(t, this._texture.orig.height)
        }
    }
      , c2 = new at;
    function c0(i, e, t) {
        let r = c2;
        i.measurable = !0,
        uo(i, t, r),
        e.addBoundsMask(r),
        i.measurable = !1
    }
    function l0(i, e, t) {
        let r = bi.get();
        i.measurable = !0;
        let s = mt.get().identity()
          , n = h0(i, t, s);
        wh(i, r, n),
        i.measurable = !1,
        e.addBoundsMask(r),
        mt.return(s),
        bi.return(r)
    }
    function h0(i, e, t) {
        return i && i !== e && (h0(i.parent, e, t),
        i.updateLocalTransform(),
        t.append(i.localTransform)),
        t
    }
    var wn = class {
        constructor(e) {
            this.priority = 0,
            this.inverse = !1,
            this.pipe = "alphaMask",
            e != null && e.mask && this.init(e.mask)
        }
        init(e) {
            this.mask = e,
            this.renderMaskToTexture = !(e instanceof Ge),
            this.mask.renderable = this.renderMaskToTexture,
            this.mask.includeInBuild = !this.renderMaskToTexture,
            this.mask.measurable = !1
        }
        reset() {
            this.mask.measurable = !0,
            this.mask = null
        }
        addBounds(e, t) {
            this.inverse || c0(this.mask, e, t)
        }
        addLocalBounds(e, t) {
            l0(this.mask, e, t)
        }
        containsPoint(e, t) {
            let r = this.mask;
            return t(r, e)
        }
        destroy() {
            this.reset()
        }
        static test(e) {
            return e instanceof Ge
        }
    }
    ;
    wn.extension = B.MaskEffect;
    var An = class {
        constructor(e) {
            this.priority = 0,
            this.pipe = "colorMask",
            e != null && e.mask && this.init(e.mask)
        }
        init(e) {
            this.mask = e
        }
        destroy() {}
        static test(e) {
            return typeof e == "number"
        }
    }
    ;
    An.extension = B.MaskEffect;
    var En = class {
        constructor(e) {
            this.priority = 0,
            this.pipe = "stencilMask",
            e != null && e.mask && this.init(e.mask)
        }
        init(e) {
            this.mask = e,
            this.mask.includeInBuild = !1,
            this.mask.measurable = !1
        }
        reset() {
            this.mask.measurable = !0,
            this.mask.includeInBuild = !0,
            this.mask = null
        }
        addBounds(e, t) {
            c0(this.mask, e, t)
        }
        addLocalBounds(e, t) {
            l0(this.mask, e, t)
        }
        containsPoint(e, t) {
            let r = this.mask;
            return t(r, e)
        }
        destroy() {
            this.reset()
        }
        static test(e) {
            return e instanceof _e
        }
    }
    ;
    En.extension = B.MaskEffect;
    var Zt = class extends He {
        constructor(e) {
            e.resource || (e.resource = xe.get().createCanvas()),
            e.width || (e.width = e.resource.width,
            e.autoDensity || (e.width /= e.resolution)),
            e.height || (e.height = e.resource.height,
            e.autoDensity || (e.height /= e.resolution)),
            super(e),
            this.uploadMethodId = "image",
            this.autoDensity = e.autoDensity,
            this.resizeCanvas(),
            this.transparent = !!e.transparent
        }
        resizeCanvas() {
            this.autoDensity && "style"in this.resource && (this.resource.style.width = `${this.width}px`,
            this.resource.style.height = `${this.height}px`),
            (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth,
            this.resource.height = this.pixelHeight)
        }
        resize(e=this.width, t=this.height, r=this._resolution) {
            let s = super.resize(e, t, r);
            return s && this.resizeCanvas(),
            s
        }
        static test(e) {
            return globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && e instanceof OffscreenCanvas
        }
        get context2D() {
            return this._context2D || (this._context2D = this.resource.getContext("2d"))
        }
    }
    ;
    Zt.extension = B.TextureSource;
    var yi = class extends He {
        constructor(e) {
            super(e),
            this.uploadMethodId = "image",
            this.autoGarbageCollect = !0
        }
        static test(e) {
            return globalThis.HTMLImageElement && e instanceof HTMLImageElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap || globalThis.VideoFrame && e instanceof VideoFrame
        }
    }
    ;
    yi.extension = B.TextureSource;
    var Do;
    async function u0() {
        return Do != null || (Do = (async () => {
            var i;
            let e = xe.get().createCanvas(1, 1).getContext("webgl");
            if (!e)
                return "premultiply-alpha-on-upload";
            let t = await new Promise(a => {
                let c = document.createElement("video");
                c.onloadeddata = () => a(c),
                c.onerror = () => a(null),
                c.autoplay = !1,
                c.crossOrigin = "anonymous",
                c.preload = "auto",
                c.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=",
                c.load()
            }
            );
            if (!t)
                return "premultiply-alpha-on-upload";
            let r = e.createTexture();
            e.bindTexture(e.TEXTURE_2D, r);
            let s = e.createFramebuffer();
            e.bindFramebuffer(e.FRAMEBUFFER, s),
            e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, r, 0),
            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
            e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE),
            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t);
            let n = new Uint8Array(4);
            return e.readPixels(0, 0, 1, 1, e.RGBA, e.UNSIGNED_BYTE, n),
            e.deleteFramebuffer(s),
            e.deleteTexture(r),
            (i = e.getExtension("WEBGL_lose_context")) == null || i.loseContext(),
            n[0] <= n[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload"
        }
        )()),
        Do
    }
    var l2 = Object.defineProperty
      , h2 = Object.defineProperties
      , u2 = Object.getOwnPropertyDescriptors
      , qu = Object.getOwnPropertySymbols
      , d2 = Object.prototype.hasOwnProperty
      , f2 = Object.prototype.propertyIsEnumerable
      , Zu = (i, e, t) => e in i ? l2(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , jc = (i, e) => {
        for (var t in e || (e = {}))
            d2.call(e, t) && Zu(i, t, e[t]);
        if (qu)
            for (var t of qu(e))
                f2.call(e, t) && Zu(i, t, e[t]);
        return i
    }
      , p2 = (i, e) => h2(i, u2(e))
      , on = class d0 extends He {
        constructor(e) {
            var t;
            super(e),
            this.isReady = !1,
            this.uploadMethodId = "video",
            e = jc(jc({}, d0.defaultOptions), e),
            this._autoUpdate = !0,
            this._isConnectedToTicker = !1,
            this._updateFPS = e.updateFPS || 0,
            this._msToNextUpdate = 0,
            this.autoPlay = e.autoPlay !== !1,
            this.alphaMode = (t = e.alphaMode) != null ? t : "premultiply-alpha-on-upload",
            this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this),
            this._videoFrameRequestCallbackHandle = null,
            this._load = null,
            this._resolve = null,
            this._reject = null,
            this._onCanPlay = this._onCanPlay.bind(this),
            this._onCanPlayThrough = this._onCanPlayThrough.bind(this),
            this._onError = this._onError.bind(this),
            this._onPlayStart = this._onPlayStart.bind(this),
            this._onPlayStop = this._onPlayStop.bind(this),
            this._onSeeked = this._onSeeked.bind(this),
            e.autoLoad !== !1 && this.load()
        }
        updateFrame() {
            if (!this.destroyed) {
                if (this._updateFPS) {
                    let e = nt.shared.elapsedMS * this.resource.playbackRate;
                    this._msToNextUpdate = Math.floor(this._msToNextUpdate - e)
                }
                (!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0),
                this.isValid && this.update()
            }
        }
        _videoFrameRequestCallback() {
            this.updateFrame(),
            this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback)
        }
        get isValid() {
            return !!this.resource.videoWidth && !!this.resource.videoHeight
        }
        async load() {
            if (this._load)
                return this._load;
            let e = this.resource
              , t = this.options;
            return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0),
            e.addEventListener("play", this._onPlayStart),
            e.addEventListener("pause", this._onPlayStop),
            e.addEventListener("seeked", this._onSeeked),
            this._isSourceReady() ? this._mediaReady() : (t.preload || e.addEventListener("canplay", this._onCanPlay),
            e.addEventListener("canplaythrough", this._onCanPlayThrough),
            e.addEventListener("error", this._onError, !0)),
            this.alphaMode = await u0(),
            this._load = new Promise( (r, s) => {
                this.isValid ? r(this) : (this._resolve = r,
                this._reject = s,
                t.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout( () => {
                    this._onError(new ErrorEvent(`Preload exceeded timeout of ${t.preloadTimeoutMs}ms`))
                }
                )),
                e.load())
            }
            ),
            this._load
        }
        _onError(e) {
            this.resource.removeEventListener("error", this._onError, !0),
            this.emit("error", e),
            this._reject && (this._reject(e),
            this._reject = null,
            this._resolve = null)
        }
        _isSourcePlaying() {
            let e = this.resource;
            return !e.paused && !e.ended
        }
        _isSourceReady() {
            return this.resource.readyState > 2
        }
        _onPlayStart() {
            this.isValid || this._mediaReady(),
            this._configureAutoUpdate()
        }
        _onPlayStop() {
            this._configureAutoUpdate()
        }
        _onSeeked() {
            this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0,
            this.updateFrame(),
            this._msToNextUpdate = 0)
        }
        _onCanPlay() {
            this.resource.removeEventListener("canplay", this._onCanPlay),
            this._mediaReady()
        }
        _onCanPlayThrough() {
            this.resource.removeEventListener("canplaythrough", this._onCanPlay),
            this._preloadTimeout && (clearTimeout(this._preloadTimeout),
            this._preloadTimeout = void 0),
            this._mediaReady()
        }
        _mediaReady() {
            let e = this.resource;
            this.isValid && (this.isReady = !0,
            this.resize(e.videoWidth, e.videoHeight)),
            this._msToNextUpdate = 0,
            this.updateFrame(),
            this._msToNextUpdate = 0,
            this._resolve && (this._resolve(this),
            this._resolve = null,
            this._reject = null),
            this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play()
        }
        destroy() {
            this._configureAutoUpdate();
            let e = this.resource;
            e && (e.removeEventListener("play", this._onPlayStart),
            e.removeEventListener("pause", this._onPlayStop),
            e.removeEventListener("seeked", this._onSeeked),
            e.removeEventListener("canplay", this._onCanPlay),
            e.removeEventListener("canplaythrough", this._onCanPlayThrough),
            e.removeEventListener("error", this._onError, !0),
            e.pause(),
            e.src = "",
            e.load()),
            super.destroy()
        }
        get autoUpdate() {
            return this._autoUpdate
        }
        set autoUpdate(e) {
            e !== this._autoUpdate && (this._autoUpdate = e,
            this._configureAutoUpdate())
        }
        get updateFPS() {
            return this._updateFPS
        }
        set updateFPS(e) {
            e !== this._updateFPS && (this._updateFPS = e,
            this._configureAutoUpdate())
        }
        _configureAutoUpdate() {
            this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (nt.shared.remove(this.updateFrame, this),
            this._isConnectedToTicker = !1,
            this._msToNextUpdate = 0),
            this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),
            this._videoFrameRequestCallbackHandle = null),
            this._isConnectedToTicker || (nt.shared.add(this.updateFrame, this),
            this._isConnectedToTicker = !0,
            this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),
            this._videoFrameRequestCallbackHandle = null),
            this._isConnectedToTicker && (nt.shared.remove(this.updateFrame, this),
            this._isConnectedToTicker = !1,
            this._msToNextUpdate = 0))
        }
        static test(e) {
            return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement
        }
    }
    ;
    on.extension = B.TextureSource,
    on.defaultOptions = p2(jc({}, He.defaultOptions), {
        autoLoad: !0,
        autoPlay: !0,
        updateFPS: 0,
        crossorigin: !0,
        loop: !1,
        muted: !0,
        playsinline: !0,
        preload: !1
    }),
    on.MIME_TYPES = {
        ogv: "video/ogg",
        mov: "video/quicktime",
        m4v: "video/mp4"
    };
    var ss = on
      , b2 = class {
        constructor() {
            this._parsers = [],
            this._cache = new Map,
            this._cacheMap = new Map
        }
        reset() {
            this._cacheMap.clear(),
            this._cache.clear()
        }
        has(i) {
            return this._cache.has(i)
        }
        get(i) {
            return this._cache.get(i)
        }
        set(i, e) {
            let t = qt(i), r;
            for (let c = 0; c < this.parsers.length; c++) {
                let l = this.parsers[c];
                if (l.test(e)) {
                    r = l.getCacheableAssets(t, e);
                    break
                }
            }
            let s = new Map(Object.entries(r || {}));
            r || t.forEach(c => {
                s.set(c, e)
            }
            );
            let n = [...s.keys()]
              , a = {
                cacheKeys: n,
                keys: t
            };
            t.forEach(c => {
                this._cacheMap.set(c, a)
            }
            ),
            n.forEach(c => {
                let l = r ? r[c] : e;
                this._cache.has(c) && this._cache.get(c),
                this._cache.set(c, s.get(c))
            }
            )
        }
        remove(i) {
            if (!this._cacheMap.has(i))
                return;
            let e = this._cacheMap.get(i);
            e.cacheKeys.forEach(t => {
                this._cache.delete(t)
            }
            ),
            e.keys.forEach(t => {
                this._cacheMap.delete(t)
            }
            )
        }
        get parsers() {
            return this._parsers
        }
    }
      , Oe = new b2
      , Hc = [];
    be.handleByList(B.TextureSource, Hc);
    function f0(i={}) {
        let e = i && i.resource
          , t = e ? i.resource : i
          , r = e ? i : {
            resource: i
        };
        for (let s = 0; s < Hc.length; s++) {
            let n = Hc[s];
            if (n.test(t))
                return new n(r)
        }
        throw new Error(`Could not find a source type for resource: ${r.resource}`)
    }
    function m2(i={}, e=!1) {
        let t = i && i.resource
          , r = t ? i.resource : i
          , s = t ? i : {
            resource: i
        };
        if (!e && Oe.has(r))
            return Oe.get(r);
        let n = new Z({
            source: f0(s)
        });
        return n.on("destroy", () => {
            Oe.has(r) && Oe.remove(r)
        }
        ),
        e || Oe.set(r, n),
        n
    }
    function g2(i, e=!1) {
        return typeof i == "string" ? Oe.get(i) : i instanceof He ? new Z({
            source: i
        }) : m2(i, e)
    }
    Z.from = g2,
    He.from = f0,
    be.add(wn, An, En, ss, yi, Zt, us);
    var Qt = class {
        constructor(e) {
            this.resources = Object.create(null),
            this._dirty = !0;
            let t = 0;
            for (let r in e) {
                let s = e[r];
                this.setResource(s, t++)
            }
            this._updateKey()
        }
        _updateKey() {
            if (!this._dirty)
                return;
            this._dirty = !1;
            let e = []
              , t = 0;
            for (let r in this.resources)
                e[t++] = this.resources[r]._resourceId;
            this._key = e.join("|")
        }
        setResource(e, t) {
            var r, s;
            let n = this.resources[t];
            e !== n && (n && ((r = e.off) == null || r.call(e, "change", this.onResourceChange, this)),
            (s = e.on) == null || s.call(e, "change", this.onResourceChange, this),
            this.resources[t] = e,
            this._dirty = !0)
        }
        getResource(e) {
            return this.resources[e]
        }
        _touch(e) {
            let t = this.resources;
            for (let r in t)
                t[r]._touched = e
        }
        destroy() {
            var e;
            let t = this.resources;
            for (let r in t) {
                let s = t[r];
                (e = s.off) == null || e.call(s, "change", this.onResourceChange, this)
            }
            this.resources = null
        }
        onResourceChange(e) {
            if (this._dirty = !0,
            e.destroyed) {
                let t = this.resources;
                for (let r in t)
                    t[r] === e && (t[r] = null)
            } else
                this._updateKey()
        }
    }
      , p0 = {};
    function Ph(i, e, t) {
        let r = 2166136261;
        for (let s = 0; s < e; s++)
            r ^= i[s].uid,
            r = Math.imul(r, 16777619),
            r >>>= 0;
        return p0[r] || _2(i, e, r, t)
    }
    function _2(i, e, t, r) {
        let s = {}
          , n = 0;
        for (let c = 0; c < r; c++) {
            let l = c < e ? i[c] : Z.EMPTY.source;
            s[n++] = l.source,
            s[n++] = l.style
        }
        let a = new Qt(s);
        return p0[t] = a,
        a
    }
    var Oi = class {
        constructor(e) {
            typeof e == "number" ? this.rawBinaryData = new ArrayBuffer(e) : e instanceof Uint8Array ? this.rawBinaryData = e.buffer : this.rawBinaryData = e,
            this.uint32View = new Uint32Array(this.rawBinaryData),
            this.float32View = new Float32Array(this.rawBinaryData),
            this.size = this.rawBinaryData.byteLength
        }
        get int8View() {
            return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)),
            this._int8View
        }
        get uint8View() {
            return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)),
            this._uint8View
        }
        get int16View() {
            return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)),
            this._int16View
        }
        get int32View() {
            return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)),
            this._int32View
        }
        get float64View() {
            return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)),
            this._float64Array
        }
        get bigUint64View() {
            return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)),
            this._bigUint64Array
        }
        view(e) {
            return this[`${e}View`]
        }
        destroy() {
            this.rawBinaryData = null,
            this._int8View = null,
            this._uint8View = null,
            this._int16View = null,
            this.uint16View = null,
            this._int32View = null,
            this.uint32View = null,
            this.float32View = null
        }
        static sizeOf(e) {
            switch (e) {
            case "int8":
            case "uint8":
                return 1;
            case "int16":
            case "uint16":
                return 2;
            case "int32":
            case "uint32":
            case "float32":
                return 4;
            default:
                throw new Error(`${e} isn't a valid view type`)
            }
        }
    }
      , Qu = new Set
      , Ju = "8.0.0";
    var gr = {
        quiet: !1,
        noColor: !1
    }
      , Pn = (i, e, t=3) => {
        if (gr.quiet || Qu.has(e))
            return;
        let r = new Error().stack
          , s = `${e}
Deprecated since v${i}`
          , n = typeof console.groupCollapsed == "function" && !gr.noColor;
        typeof r > "u" || (r = r.split(`
`).splice(t).join(`
`)),
        Qu.add(e)
    }
    ;
    Object.defineProperties(Pn, {
        quiet: {
            get: () => gr.quiet,
            set: i => {
                gr.quiet = i
            }
            ,
            enumerable: !0,
            configurable: !1
        },
        noColor: {
            get: () => gr.noColor,
            set: i => {
                gr.noColor = i
            }
            ,
            enumerable: !0,
            configurable: !1
        }
    });
    function zc(i, e) {
        let t = i.byteLength / 8 | 0
          , r = new Float64Array(i,0,t);
        new Float64Array(e,0,t).set(r);
        let s = i.byteLength - t * 8;
        if (s > 0) {
            let n = new Uint8Array(i,t * 8,s);
            new Uint8Array(e,t * 8,s).set(n)
        }
    }
    var x2 = {
        normal: "normal-npm",
        add: "add-npm",
        screen: "screen-npm"
    }
      , Je = (i => (i[i.DISABLED = 0] = "DISABLED",
    i[i.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD",
    i[i.MASK_ACTIVE = 2] = "MASK_ACTIVE",
    i[i.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE",
    i[i.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE",
    i[i.NONE = 5] = "NONE",
    i))(Je || {});
    function ps(i, e) {
        return e.alphaMode === "no-premultiply-alpha" && x2[i] || i
    }
    var kr;
    function b0() {
        return (!kr || kr != null && kr.isContextLost()) && (kr = xe.get().createCanvas().getContext("webgl", {})),
        kr
    }
    var y2 = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join(`
`);
    function v2(i) {
        let e = "";
        for (let t = 0; t < i; ++t)
            t > 0 && (e += `
else `),
            t < i - 1 && (e += `if(test == ${t}.0){}`);
        return e
    }
    function m0(i, e) {
        if (i === 0)
            throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
        let t = e.createShader(e.FRAGMENT_SHADER);
        try {
            for (; ; ) {
                let r = y2.replace(/%forloop%/gi, v2(i));
                if (e.shaderSource(t, r),
                e.compileShader(t),
                !e.getShaderParameter(t, e.COMPILE_STATUS))
                    i = i / 2 | 0;
                else
                    break
            }
        } finally {
            e.deleteShader(t)
        }
        return i
    }
    var lr = null;
    function T2() {
        var i;
        if (lr)
            return lr;
        let e = b0();
        return lr = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
        lr = m0(lr, e),
        (i = e.getExtension("WEBGL_lose_context")) == null || i.loseContext(),
        lr
    }
    var Vc = class {
        constructor() {
            this.ids = Object.create(null),
            this.textures = [],
            this.count = 0
        }
        clear() {
            for (let e = 0; e < this.count; e++) {
                let t = this.textures[e];
                this.textures[e] = null,
                this.ids[t.uid] = null
            }
            this.count = 0
        }
    }
      , S2 = Object.defineProperty
      , ed = Object.getOwnPropertySymbols
      , w2 = Object.prototype.hasOwnProperty
      , A2 = Object.prototype.propertyIsEnumerable
      , td = (i, e, t) => e in i ? S2(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , id = (i, e) => {
        for (var t in e || (e = {}))
            w2.call(e, t) && td(i, t, e[t]);
        if (ed)
            for (var t of ed(e))
                A2.call(e, t) && td(i, t, e[t]);
        return i
    }
      , Wc = class {
        constructor() {
            this.renderPipeId = "batch",
            this.action = "startBatch",
            this.start = 0,
            this.size = 0,
            this.textures = new Vc,
            this.blendMode = "normal",
            this.topology = "triangle-strip",
            this.canBundle = !0
        }
        destroy() {
            this.textures = null,
            this.gpuBindGroup = null,
            this.bindGroup = null,
            this.batcher = null
        }
    }
      , ns = []
      , Rn = 0;
    Cr.register({
        clear: () => {
            if (ns.length > 0)
                for (let i of ns)
                    i && i.destroy();
            ns.length = 0,
            Rn = 0
        }
    });
    function rd() {
        return Rn > 0 ? ns[--Rn] : new Wc
    }
    function sd(i) {
        ns[Rn++] = i
    }
    var Ur = 0
      , g0 = class _0 {
        constructor(e) {
            this.uid = Xe("batcher"),
            this.dirty = !0,
            this.batchIndex = 0,
            this.batches = [],
            this._elements = [],
            e = id(id({}, _0.defaultOptions), e),
            e.maxTextures || (Pn("v8.8.0", "maxTextures is a required option for Batcher now, please pass it in the options"),
            e.maxTextures = T2());
            let {maxTextures: t, attributesInitialSize: r, indicesInitialSize: s} = e;
            this.attributeBuffer = new Oi(r * 4),
            this.indexBuffer = new Uint16Array(s),
            this.maxTextures = t
        }
        begin() {
            this.elementSize = 0,
            this.elementStart = 0,
            this.indexSize = 0,
            this.attributeSize = 0;
            for (let e = 0; e < this.batchIndex; e++)
                sd(this.batches[e]);
            this.batchIndex = 0,
            this._batchIndexStart = 0,
            this._batchIndexSize = 0,
            this.dirty = !0
        }
        add(e) {
            this._elements[this.elementSize++] = e,
            e._indexStart = this.indexSize,
            e._attributeStart = this.attributeSize,
            e._batcher = this,
            this.indexSize += e.indexSize,
            this.attributeSize += e.attributeSize * this.vertexSize
        }
        checkAndUpdateTexture(e, t) {
            let r = e._batch.textures.ids[t._source.uid];
            return !r && r !== 0 ? !1 : (e._textureId = r,
            e.texture = t,
            !0)
        }
        updateElement(e) {
            this.dirty = !0;
            let t = this.attributeBuffer;
            e.packAsQuad ? this.packQuadAttributes(e, t.float32View, t.uint32View, e._attributeStart, e._textureId) : this.packAttributes(e, t.float32View, t.uint32View, e._attributeStart, e._textureId)
        }
        break(e) {
            let t = this._elements;
            if (!t[this.elementStart])
                return;
            let r = rd()
              , s = r.textures;
            s.clear();
            let n = t[this.elementStart]
              , a = ps(n.blendMode, n.texture._source)
              , c = n.topology;
            this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4),
            this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
            let l = this.attributeBuffer.float32View
              , u = this.attributeBuffer.uint32View
              , d = this.indexBuffer
              , f = this._batchIndexSize
              , b = this._batchIndexStart
              , m = "startBatch"
              , x = this.maxTextures;
            for (let y = this.elementStart; y < this.elementSize; ++y) {
                let S = t[y];
                t[y] = null;
                let A = S.texture._source
                  , E = ps(S.blendMode, A)
                  , O = a !== E || c !== S.topology;
                if (A._batchTick === Ur && !O) {
                    S._textureId = A._textureBindLocation,
                    f += S.indexSize,
                    S.packAsQuad ? (this.packQuadAttributes(S, l, u, S._attributeStart, S._textureId),
                    this.packQuadIndex(d, S._indexStart, S._attributeStart / this.vertexSize)) : (this.packAttributes(S, l, u, S._attributeStart, S._textureId),
                    this.packIndex(S, d, S._indexStart, S._attributeStart / this.vertexSize)),
                    S._batch = r;
                    continue
                }
                A._batchTick = Ur,
                (s.count >= x || O) && (this._finishBatch(r, b, f - b, s, a, c, e, m),
                m = "renderBatch",
                b = f,
                a = E,
                c = S.topology,
                r = rd(),
                s = r.textures,
                s.clear(),
                ++Ur),
                S._textureId = A._textureBindLocation = s.count,
                s.ids[A.uid] = s.count,
                s.textures[s.count++] = A,
                S._batch = r,
                f += S.indexSize,
                S.packAsQuad ? (this.packQuadAttributes(S, l, u, S._attributeStart, S._textureId),
                this.packQuadIndex(d, S._indexStart, S._attributeStart / this.vertexSize)) : (this.packAttributes(S, l, u, S._attributeStart, S._textureId),
                this.packIndex(S, d, S._indexStart, S._attributeStart / this.vertexSize))
            }
            s.count > 0 && (this._finishBatch(r, b, f - b, s, a, c, e, m),
            b = f,
            ++Ur),
            this.elementStart = this.elementSize,
            this._batchIndexStart = b,
            this._batchIndexSize = f
        }
        _finishBatch(e, t, r, s, n, a, c, l) {
            e.gpuBindGroup = null,
            e.bindGroup = null,
            e.action = l,
            e.batcher = this,
            e.textures = s,
            e.blendMode = n,
            e.topology = a,
            e.start = t,
            e.size = r,
            ++Ur,
            this.batches[this.batchIndex++] = e,
            c.add(e)
        }
        finish(e) {
            this.break(e)
        }
        ensureAttributeBuffer(e) {
            e * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(e * 4)
        }
        ensureIndexBuffer(e) {
            e <= this.indexBuffer.length || this._resizeIndexBuffer(e)
        }
        _resizeAttributeBuffer(e) {
            let t = Math.max(e, this.attributeBuffer.size * 2)
              , r = new Oi(t);
            zc(this.attributeBuffer.rawBinaryData, r.rawBinaryData),
            this.attributeBuffer = r
        }
        _resizeIndexBuffer(e) {
            let t = this.indexBuffer
              , r = Math.max(e, t.length * 1.5);
            r += r % 2;
            let s = r > 65535 ? new Uint32Array(r) : new Uint16Array(r);
            if (s.BYTES_PER_ELEMENT !== t.BYTES_PER_ELEMENT)
                for (let n = 0; n < t.length; n++)
                    s[n] = t[n];
            else
                zc(t.buffer, s.buffer);
            this.indexBuffer = s
        }
        packQuadIndex(e, t, r) {
            e[t] = r + 0,
            e[t + 1] = r + 1,
            e[t + 2] = r + 2,
            e[t + 3] = r + 0,
            e[t + 4] = r + 2,
            e[t + 5] = r + 3
        }
        packIndex(e, t, r, s) {
            let n = e.indices
              , a = e.indexSize
              , c = e.indexOffset
              , l = e.attributeOffset;
            for (let u = 0; u < a; u++)
                t[r++] = s + n[u + c] - l
        }
        destroy() {
            if (this.batches !== null) {
                for (let e = 0; e < this.batches.length; e++)
                    sd(this.batches[e]);
                this.batches = null;
                for (let e = 0; e < this._elements.length; e++)
                    this._elements[e] && (this._elements[e]._batch = null);
                this._elements = null,
                this.indexBuffer = null,
                this.attributeBuffer.destroy(),
                this.attributeBuffer = null
            }
        }
    }
    ;
    g0.defaultOptions = {
        maxTextures: null,
        attributesInitialSize: 4,
        indicesInitialSize: 6
    };
    var E2 = g0
      , Ae = (i => (i[i.MAP_READ = 1] = "MAP_READ",
    i[i.MAP_WRITE = 2] = "MAP_WRITE",
    i[i.COPY_SRC = 4] = "COPY_SRC",
    i[i.COPY_DST = 8] = "COPY_DST",
    i[i.INDEX = 16] = "INDEX",
    i[i.VERTEX = 32] = "VERTEX",
    i[i.UNIFORM = 64] = "UNIFORM",
    i[i.STORAGE = 128] = "STORAGE",
    i[i.INDIRECT = 256] = "INDIRECT",
    i[i.QUERY_RESOLVE = 512] = "QUERY_RESOLVE",
    i[i.STATIC = 1024] = "STATIC",
    i))(Ae || {})
      , gt = class extends Ft {
        constructor(e) {
            let {data: t, size: r} = e
              , {usage: s, label: n, shrinkToFit: a} = e;
            super(),
            this.uid = Xe("buffer"),
            this._resourceType = "buffer",
            this._resourceId = Xe("resource"),
            this._touched = 0,
            this._updateID = 1,
            this._dataInt32 = null,
            this.shrinkToFit = !0,
            this.destroyed = !1,
            t instanceof Array && (t = new Float32Array(t)),
            this._data = t,
            r != null || (r = t?.byteLength);
            let c = !!t;
            this.descriptor = {
                size: r,
                usage: s,
                mappedAtCreation: c,
                label: n
            },
            this.shrinkToFit = a ?? !0
        }
        get data() {
            return this._data
        }
        set data(e) {
            this.setDataWithSize(e, e.length, !0)
        }
        get dataInt32() {
            return this._dataInt32 || (this._dataInt32 = new Int32Array(this.data.buffer)),
            this._dataInt32
        }
        get static() {
            return !!(this.descriptor.usage & Ae.STATIC)
        }
        set static(e) {
            e ? this.descriptor.usage |= Ae.STATIC : this.descriptor.usage &= ~Ae.STATIC
        }
        setDataWithSize(e, t, r) {
            if (this._updateID++,
            this._updateSize = t * e.BYTES_PER_ELEMENT,
            this._data === e) {
                r && this.emit("update", this);
                return
            }
            let s = this._data;
            if (this._data = e,
            this._dataInt32 = null,
            !s || s.length !== e.length) {
                !this.shrinkToFit && s && e.byteLength < s.byteLength ? r && this.emit("update", this) : (this.descriptor.size = e.byteLength,
                this._resourceId = Xe("resource"),
                this.emit("change", this));
                return
            }
            r && this.emit("update", this)
        }
        update(e) {
            this._updateSize = e ?? this._updateSize,
            this._updateID++,
            this.emit("update", this)
        }
        destroy() {
            this.destroyed = !0,
            this.emit("destroy", this),
            this.emit("change", this),
            this._data = null,
            this.descriptor = null,
            this.removeAllListeners()
        }
    }
    ;
    function x0(i, e) {
        if (!(i instanceof gt)) {
            let t = e ? Ae.INDEX : Ae.VERTEX;
            i instanceof Array && (e ? (i = new Uint32Array(i),
            t = Ae.INDEX | Ae.COPY_DST) : (i = new Float32Array(i),
            t = Ae.VERTEX | Ae.COPY_DST)),
            i = new gt({
                data: i,
                label: e ? "index-mesh-buffer" : "vertex-mesh-buffer",
                usage: t
            })
        }
        return i
    }
    function P2(i, e, t) {
        let r = i.getAttribute(e);
        if (!r)
            return t.minX = 0,
            t.minY = 0,
            t.maxX = 0,
            t.maxY = 0,
            t;
        let s = r.buffer.data
          , n = 1 / 0
          , a = 1 / 0
          , c = -1 / 0
          , l = -1 / 0
          , u = s.BYTES_PER_ELEMENT
          , d = (r.offset || 0) / u
          , f = (r.stride || 8) / u;
        for (let b = d; b < s.length; b += f) {
            let m = s[b]
              , x = s[b + 1];
            m > c && (c = m),
            x > l && (l = x),
            m < n && (n = m),
            x < a && (a = x)
        }
        return t.minX = n,
        t.minY = a,
        t.maxX = c,
        t.maxY = l,
        t
    }
    function R2(i) {
        return (i instanceof gt || Array.isArray(i) || i.BYTES_PER_ELEMENT) && (i = {
            buffer: i
        }),
        i.buffer = x0(i.buffer, !1),
        i
    }
    var oi = class extends Ft {
        constructor(e={}) {
            var t;
            super(),
            this.uid = Xe("geometry"),
            this._layoutKey = 0,
            this.instanceCount = 1,
            this._bounds = new at,
            this._boundsDirty = !0;
            let {attributes: r, indexBuffer: s, topology: n} = e;
            if (this.buffers = [],
            this.attributes = {},
            r)
                for (let a in r)
                    this.addAttribute(a, r[a]);
            this.instanceCount = (t = e.instanceCount) != null ? t : 1,
            s && this.addIndex(s),
            this.topology = n || "triangle-list"
        }
        onBufferUpdate() {
            this._boundsDirty = !0,
            this.emit("update", this)
        }
        getAttribute(e) {
            return this.attributes[e]
        }
        getIndex() {
            return this.indexBuffer
        }
        getBuffer(e) {
            return this.getAttribute(e).buffer
        }
        getSize() {
            for (let e in this.attributes) {
                let t = this.attributes[e];
                return t.buffer.data.length / (t.stride / 4 || t.size)
            }
            return 0
        }
        addAttribute(e, t) {
            let r = R2(t);
            this.buffers.indexOf(r.buffer) === -1 && (this.buffers.push(r.buffer),
            r.buffer.on("update", this.onBufferUpdate, this),
            r.buffer.on("change", this.onBufferUpdate, this)),
            this.attributes[e] = r
        }
        addIndex(e) {
            this.indexBuffer = x0(e, !0),
            this.buffers.push(this.indexBuffer)
        }
        get bounds() {
            return this._boundsDirty ? (this._boundsDirty = !1,
            P2(this, "aPosition", this._bounds)) : this._bounds
        }
        destroy(e=!1) {
            this.emit("destroy", this),
            this.removeAllListeners(),
            e && this.buffers.forEach(t => t.destroy()),
            this.attributes = null,
            this.buffers = null,
            this.indexBuffer = null,
            this._bounds = null
        }
    }
      , M2 = new Float32Array(1)
      , C2 = new Uint32Array(1)
      , Yc = class extends oi {
        constructor() {
            let e = new gt({
                data: M2,
                label: "attribute-batch-buffer",
                usage: Ae.VERTEX | Ae.COPY_DST,
                shrinkToFit: !1
            })
              , t = new gt({
                data: C2,
                label: "index-batch-buffer",
                usage: Ae.INDEX | Ae.COPY_DST,
                shrinkToFit: !1
            })
              , r = 24;
            super({
                attributes: {
                    aPosition: {
                        buffer: e,
                        format: "float32x2",
                        stride: r,
                        offset: 0
                    },
                    aUV: {
                        buffer: e,
                        format: "float32x2",
                        stride: r,
                        offset: 8
                    },
                    aColor: {
                        buffer: e,
                        format: "unorm8x4",
                        stride: r,
                        offset: 16
                    },
                    aTextureIdAndRound: {
                        buffer: e,
                        format: "uint16x2",
                        stride: r,
                        offset: 20
                    }
                },
                indexBuffer: t
            })
        }
    }
      , ko = Object.create(null)
      , nd = Object.create(null);
    function bs(i, e) {
        let t = nd[i];
        return t === void 0 && (ko[e] === void 0 && (ko[e] = 1),
        nd[i] = t = ko[e]++),
        t
    }
    var Hs;
    function O2() {
        if (!Hs) {
            Hs = "mediump";
            let i = b0();
            i && i.getShaderPrecisionFormat && (Hs = i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision ? "highp" : "mediump")
        }
        return Hs
    }
    function I2(i, e, t) {
        return e ? i : t ? (i = i.replace("out vec4 finalColor;", ""),
        `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${i}
        `) : `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${i}
        `
    }
    function G2(i, e, t) {
        let r = t ? e.maxSupportedFragmentPrecision : e.maxSupportedVertexPrecision;
        if (i.substring(0, 9) !== "precision") {
            let s = t ? e.requestedFragmentPrecision : e.requestedVertexPrecision;
            return s === "highp" && r !== "highp" && (s = "mediump"),
            `precision ${s} float;
${i}`
        } else if (r !== "highp" && i.substring(0, 15) === "precision highp")
            return i.replace("precision highp", "precision mediump");
        return i
    }
    function B2(i, e) {
        return e ? `#version 300 es
${i}` : i
    }
    var F2 = {}
      , D2 = {};
    function k2(i, {name: e="pixi-program"}, t=!0) {
        e = e.replace(/\s+/g, "-"),
        e += t ? "-fragment" : "-vertex";
        let r = t ? F2 : D2;
        return r[e] ? (r[e]++,
        e += `-${r[e]}`) : r[e] = 1,
        i.indexOf("#define SHADER_NAME") !== -1 ? i : `${`#define SHADER_NAME ${e}`}
${i}`
    }
    function U2(i, e) {
        return e ? i.replace("#version 300 es", "") : i
    }
    var L2 = Object.defineProperty
      , ad = Object.getOwnPropertySymbols
      , N2 = Object.prototype.hasOwnProperty
      , X2 = Object.prototype.propertyIsEnumerable
      , od = (i, e, t) => e in i ? L2(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , cd = (i, e) => {
        for (var t in e || (e = {}))
            N2.call(e, t) && od(i, t, e[t]);
        if (ad)
            for (var t of ad(e))
                X2.call(e, t) && od(i, t, e[t]);
        return i
    }
      , Uo = {
        stripVersion: U2,
        ensurePrecision: G2,
        addProgramDefines: I2,
        setProgramName: k2,
        insertVersion: B2
    }
      , Lr = Object.create(null)
      , y0 = class $c {
        constructor(e) {
            e = cd(cd({}, $c.defaultOptions), e);
            let t = e.fragment.indexOf("#version 300 es") !== -1
              , r = {
                stripVersion: t,
                ensurePrecision: {
                    requestedFragmentPrecision: e.preferredFragmentPrecision,
                    requestedVertexPrecision: e.preferredVertexPrecision,
                    maxSupportedVertexPrecision: "highp",
                    maxSupportedFragmentPrecision: O2()
                },
                setProgramName: {
                    name: e.name
                },
                addProgramDefines: t,
                insertVersion: t
            }
              , s = e.fragment
              , n = e.vertex;
            Object.keys(Uo).forEach(a => {
                let c = r[a];
                s = Uo[a](s, c, !0),
                n = Uo[a](n, c, !1)
            }
            ),
            this.fragment = s,
            this.vertex = n,
            this.transformFeedbackVaryings = e.transformFeedbackVaryings,
            this._key = bs(`${this.vertex}:${this.fragment}`, "gl-program")
        }
        destroy() {
            this.fragment = null,
            this.vertex = null,
            this._attributeData = null,
            this._uniformData = null,
            this._uniformBlockData = null,
            this.transformFeedbackVaryings = null,
            Lr[this._cacheKey] = null
        }
        static from(e) {
            let t = `${e.vertex}:${e.fragment}`;
            return Lr[t] || (Lr[t] = new $c(e),
            Lr[t]._cacheKey = t),
            Lr[t]
        }
    }
    ;
    y0.defaultOptions = {
        preferredVertexPrecision: "highp",
        preferredFragmentPrecision: "mediump"
    };
    var wi = y0
      , ld = {
        uint8x2: {
            size: 2,
            stride: 2,
            normalised: !1
        },
        uint8x4: {
            size: 4,
            stride: 4,
            normalised: !1
        },
        sint8x2: {
            size: 2,
            stride: 2,
            normalised: !1
        },
        sint8x4: {
            size: 4,
            stride: 4,
            normalised: !1
        },
        unorm8x2: {
            size: 2,
            stride: 2,
            normalised: !0
        },
        unorm8x4: {
            size: 4,
            stride: 4,
            normalised: !0
        },
        snorm8x2: {
            size: 2,
            stride: 2,
            normalised: !0
        },
        snorm8x4: {
            size: 4,
            stride: 4,
            normalised: !0
        },
        uint16x2: {
            size: 2,
            stride: 4,
            normalised: !1
        },
        uint16x4: {
            size: 4,
            stride: 8,
            normalised: !1
        },
        sint16x2: {
            size: 2,
            stride: 4,
            normalised: !1
        },
        sint16x4: {
            size: 4,
            stride: 8,
            normalised: !1
        },
        unorm16x2: {
            size: 2,
            stride: 4,
            normalised: !0
        },
        unorm16x4: {
            size: 4,
            stride: 8,
            normalised: !0
        },
        snorm16x2: {
            size: 2,
            stride: 4,
            normalised: !0
        },
        snorm16x4: {
            size: 4,
            stride: 8,
            normalised: !0
        },
        float16x2: {
            size: 2,
            stride: 4,
            normalised: !1
        },
        float16x4: {
            size: 4,
            stride: 8,
            normalised: !1
        },
        float32: {
            size: 1,
            stride: 4,
            normalised: !1
        },
        float32x2: {
            size: 2,
            stride: 8,
            normalised: !1
        },
        float32x3: {
            size: 3,
            stride: 12,
            normalised: !1
        },
        float32x4: {
            size: 4,
            stride: 16,
            normalised: !1
        },
        uint32: {
            size: 1,
            stride: 4,
            normalised: !1
        },
        uint32x2: {
            size: 2,
            stride: 8,
            normalised: !1
        },
        uint32x3: {
            size: 3,
            stride: 12,
            normalised: !1
        },
        uint32x4: {
            size: 4,
            stride: 16,
            normalised: !1
        },
        sint32: {
            size: 1,
            stride: 4,
            normalised: !1
        },
        sint32x2: {
            size: 2,
            stride: 8,
            normalised: !1
        },
        sint32x3: {
            size: 3,
            stride: 12,
            normalised: !1
        },
        sint32x4: {
            size: 4,
            stride: 16,
            normalised: !1
        }
    };
    function Gi(i) {
        var e;
        return (e = ld[i]) != null ? e : ld.float32
    }
    var j2 = {
        f32: "float32",
        "vec2<f32>": "float32x2",
        "vec3<f32>": "float32x3",
        "vec4<f32>": "float32x4",
        vec2f: "float32x2",
        vec3f: "float32x3",
        vec4f: "float32x4",
        i32: "sint32",
        "vec2<i32>": "sint32x2",
        "vec3<i32>": "sint32x3",
        "vec4<i32>": "sint32x4",
        u32: "uint32",
        "vec2<u32>": "uint32x2",
        "vec3<u32>": "uint32x3",
        "vec4<u32>": "uint32x4",
        bool: "uint32",
        "vec2<bool>": "uint32x2",
        "vec3<bool>": "uint32x3",
        "vec4<bool>": "uint32x4"
    };
    function H2({source: i, entryPoint: e}) {
        var t;
        let r = {}
          , s = i.indexOf(`fn ${e}`);
        if (s !== -1) {
            let n = i.indexOf("->", s);
            if (n !== -1) {
                let a = i.substring(s, n), c = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g, l;
                for (; (l = c.exec(a)) !== null; ) {
                    let u = (t = j2[l[3]]) != null ? t : "float32";
                    r[l[2]] = {
                        location: parseInt(l[1], 10),
                        format: u,
                        stride: Gi(u).stride,
                        offset: 0,
                        instance: !1,
                        start: 0
                    }
                }
            }
        }
        return r
    }
    function Lo(i) {
        var e, t, r;
        let s = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g
          , n = /@group\((\d+)\)/
          , a = /@binding\((\d+)\)/
          , c = /var(<[^>]+>)? (\w+)/
          , l = /:\s*(\w+)/
          , u = /struct\s+(\w+)\s*{([^}]+)}/g
          , d = /(\w+)\s*:\s*([\w\<\>]+)/g
          , f = /struct\s+(\w+)/
          , b = (e = i.match(s)) == null ? void 0 : e.map(x => ({
            group: parseInt(x.match(n)[1], 10),
            binding: parseInt(x.match(a)[1], 10),
            name: x.match(c)[2],
            isUniform: x.match(c)[1] === "<uniform>",
            type: x.match(l)[1]
        }));
        if (!b)
            return {
                groups: [],
                structs: []
            };
        let m = (r = (t = i.match(u)) == null ? void 0 : t.map(x => {
            let y = x.match(f)[1]
              , S = x.match(d).reduce( (A, E) => {
                let[O,M] = E.split(":");
                return A[O.trim()] = M.trim(),
                A
            }
            , {});
            return S ? {
                name: y,
                members: S
            } : null
        }
        ).filter( ({name: x}) => b.some(y => y.type === x))) != null ? r : [];
        return {
            groups: b,
            structs: m
        }
    }
    var Qr = (i => (i[i.VERTEX = 1] = "VERTEX",
    i[i.FRAGMENT = 2] = "FRAGMENT",
    i[i.COMPUTE = 4] = "COMPUTE",
    i))(Qr || {});
    function z2({groups: i}) {
        let e = [];
        for (let t = 0; t < i.length; t++) {
            let r = i[t];
            e[r.group] || (e[r.group] = []),
            r.isUniform ? e[r.group].push({
                binding: r.binding,
                visibility: Qr.VERTEX | Qr.FRAGMENT,
                buffer: {
                    type: "uniform"
                }
            }) : r.type === "sampler" ? e[r.group].push({
                binding: r.binding,
                visibility: Qr.FRAGMENT,
                sampler: {
                    type: "filtering"
                }
            }) : r.type === "texture_2d" && e[r.group].push({
                binding: r.binding,
                visibility: Qr.FRAGMENT,
                texture: {
                    sampleType: "float",
                    viewDimension: "2d",
                    multisampled: !1
                }
            })
        }
        return e
    }
    function V2({groups: i}) {
        let e = [];
        for (let t = 0; t < i.length; t++) {
            let r = i[t];
            e[r.group] || (e[r.group] = {}),
            e[r.group][r.name] = r.binding
        }
        return e
    }
    function W2(i, e) {
        let t = new Set
          , r = new Set
          , s = [...i.structs, ...e.structs].filter(a => t.has(a.name) ? !1 : (t.add(a.name),
        !0))
          , n = [...i.groups, ...e.groups].filter(a => {
            let c = `${a.name}-${a.binding}`;
            return r.has(c) ? !1 : (r.add(c),
            !0)
        }
        );
        return {
            structs: s,
            groups: n
        }
    }
    var Nr = Object.create(null)
      , ci = class i {
        constructor(e) {
            this._layoutKey = 0,
            this._attributeLocationsKey = 0;
            var t, r;
            let {fragment: s, vertex: n, layout: a, gpuLayout: c, name: l} = e;
            if (this.name = l,
            this.fragment = s,
            this.vertex = n,
            s.source === n.source) {
                let u = Lo(s.source);
                this.structsAndGroups = u
            } else {
                let u = Lo(n.source)
                  , d = Lo(s.source);
                this.structsAndGroups = W2(u, d)
            }
            this.layout = a ?? V2(this.structsAndGroups),
            this.gpuLayout = c ?? z2(this.structsAndGroups),
            this.autoAssignGlobalUniforms = ((t = this.layout[0]) == null ? void 0 : t.globalUniforms) !== void 0,
            this.autoAssignLocalUniforms = ((r = this.layout[1]) == null ? void 0 : r.localUniforms) !== void 0,
            this._generateProgramKey()
        }
        _generateProgramKey() {
            let {vertex: e, fragment: t} = this
              , r = e.source + t.source + e.entryPoint + t.entryPoint;
            this._layoutKey = bs(r, "program")
        }
        get attributeData() {
            var e;
            return (e = this._attributeData) != null || (this._attributeData = H2(this.vertex)),
            this._attributeData
        }
        destroy() {
            this.gpuLayout = null,
            this.layout = null,
            this.structsAndGroups = null,
            this.fragment = null,
            this.vertex = null,
            Nr[this._cacheKey] = null
        }
        static from(e) {
            let t = `${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;
            return Nr[t] || (Nr[t] = new i(e),
            Nr[t]._cacheKey = t),
            Nr[t]
        }
    }
    ;
    function hd(i, e, t) {
        if (i)
            for (let r in i) {
                let s = r.toLocaleLowerCase()
                  , n = e[s];
                if (n) {
                    let a = i[r];
                    r === "header" && (a = a.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")),
                    t && n.push(`//----${t}----//`),
                    n.push(a)
                }
            }
    }
    var Y2 = /\{\{(.*?)\}\}/g;
    function ud(i) {
        var e, t;
        let r = {};
        return ((t = (e = i.match(Y2)) == null ? void 0 : e.map(s => s.replace(/[{()}]/g, ""))) != null ? t : []).forEach(s => {
            r[s] = []
        }
        ),
        r
    }
    function dd(i, e) {
        let t, r = /@in\s+([^;]+);/g;
        for (; (t = r.exec(i)) !== null; )
            e.push(t[1])
    }
    function fd(i, e, t=!1) {
        let r = [];
        dd(e, r),
        i.forEach(c => {
            c.header && dd(c.header, r)
        }
        );
        let s = r;
        t && s.sort();
        let n = s.map( (c, l) => `       @location(${l}) ${c},`).join(`
`)
          , a = e.replace(/@in\s+[^;]+;\s*/g, "");
        return a = a.replace("{{in}}", `
${n}
`),
        a
    }
    function pd(i, e) {
        let t, r = /@out\s+([^;]+);/g;
        for (; (t = r.exec(i)) !== null; )
            e.push(t[1])
    }
    function $2(i) {
        let e = /\b(\w+)\s*:/g.exec(i);
        return e ? e[1] : ""
    }
    function K2(i) {
        let e = /@.*?\s+/g;
        return i.replace(e, "")
    }
    function q2(i, e) {
        let t = [];
        pd(e, t),
        i.forEach(l => {
            l.header && pd(l.header, t)
        }
        );
        let r = 0
          , s = t.sort().map(l => l.indexOf("builtin") > -1 ? l : `@location(${r++}) ${l}`).join(`,
`)
          , n = t.sort().map(l => `       var ${K2(l)};`).join(`
`)
          , a = `return VSOutput(
            ${t.sort().map(l => ` ${$2(l)}`).join(`,
`)});`
          , c = e.replace(/@out\s+[^;]+;\s*/g, "");
        return c = c.replace("{{struct}}", `
${s}
`),
        c = c.replace("{{start}}", `
${n}
`),
        c = c.replace("{{return}}", `
${a}
`),
        c
    }
    function bd(i, e) {
        let t = i;
        for (let r in e) {
            let s = e[r];
            s.join(`
`).length ? t = t.replace(`{{${r}}}`, `//-----${r} START-----//
${s.join(`
`)}
//----${r} FINISH----//`) : t = t.replace(`{{${r}}}`, "")
        }
        return t
    }
    var Zi = Object.create(null)
      , No = new Map
      , Z2 = 0;
    function Q2({template: i, bits: e}) {
        let t = v0(i, e);
        if (Zi[t])
            return Zi[t];
        let {vertex: r, fragment: s} = ex(i, e);
        return Zi[t] = T0(r, s, e),
        Zi[t]
    }
    function J2({template: i, bits: e}) {
        let t = v0(i, e);
        return Zi[t] || (Zi[t] = T0(i.vertex, i.fragment, e)),
        Zi[t]
    }
    function ex(i, e) {
        let t = e.map(a => a.vertex).filter(a => !!a)
          , r = e.map(a => a.fragment).filter(a => !!a)
          , s = fd(t, i.vertex, !0);
        s = q2(t, s);
        let n = fd(r, i.fragment, !0);
        return {
            vertex: s,
            fragment: n
        }
    }
    function v0(i, e) {
        return e.map(t => (No.has(t) || No.set(t, Z2++),
        No.get(t))).sort( (t, r) => t - r).join("-") + i.vertex + i.fragment
    }
    function T0(i, e, t) {
        let r = ud(i)
          , s = ud(e);
        return t.forEach(n => {
            hd(n.vertex, r, n.name),
            hd(n.fragment, s, n.name)
        }
        ),
        {
            vertex: bd(i, r),
            fragment: bd(e, s)
        }
    }
    var tx = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}

        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);

        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`
      , ix = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;

    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {

        {{start}}

        var outColor:vec4<f32>;

        {{main}}

        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`
      , rx = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;

        {{start}}

        vColor = vec4(1.);

        {{main}}

        vUV = uv;

        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`
      , sx = `

    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {

        {{start}}

        vec4 outColor;

        {{main}}

        finalColor = outColor * vColor;

        {{end}}
    }
`
      , nx = {
        name: "global-uniforms-bit",
        vertex: {
            header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
        }
    };
    var ax = {
        name: "global-uniforms-bit",
        vertex: {
            header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
        }
    }
      , ox = Object.defineProperty
      , md = Object.getOwnPropertySymbols
      , cx = Object.prototype.hasOwnProperty
      , lx = Object.prototype.propertyIsEnumerable
      , gd = (i, e, t) => e in i ? ox(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , hx = (i, e) => {
        for (var t in e || (e = {}))
            cx.call(e, t) && gd(i, t, e[t]);
        if (md)
            for (var t of md(e))
                lx.call(e, t) && gd(i, t, e[t]);
        return i
    }
    ;
    function Ps({bits: i, name: e}) {
        let t = Q2({
            template: {
                fragment: ix,
                vertex: tx
            },
            bits: [nx, ...i]
        });
        return ci.from({
            name: e,
            vertex: {
                source: t.vertex,
                entryPoint: "main"
            },
            fragment: {
                source: t.fragment,
                entryPoint: "main"
            }
        })
    }
    function Rs({bits: i, name: e}) {
        return new wi(hx({
            name: e
        }, J2({
            template: {
                vertex: rx,
                fragment: sx
            },
            bits: [ax, ...i]
        })))
    }
    var Rh = {
        name: "color-bit",
        vertex: {
            header: `
            @in aColor: vec4<f32>;
        `,
            main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
        }
    }
      , Mh = {
        name: "color-bit",
        vertex: {
            header: `
            in vec4 aColor;
        `,
            main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
        }
    }
      , Xo = {};
    function ux(i) {
        let e = [];
        if (i === 1)
            e.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),
            e.push("@group(1) @binding(1) var textureSampler1: sampler;");
        else {
            let t = 0;
            for (let r = 0; r < i; r++)
                e.push(`@group(1) @binding(${t++}) var textureSource${r + 1}: texture_2d<f32>;`),
                e.push(`@group(1) @binding(${t++}) var textureSampler${r + 1}: sampler;`)
        }
        return e.join(`
`)
    }
    function dx(i) {
        let e = [];
        if (i === 1)
            e.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
        else {
            e.push("switch vTextureId {");
            for (let t = 0; t < i; t++)
                t === i - 1 ? e.push("  default:{") : e.push(`  case ${t}:{`),
                e.push(`      outColor = textureSampleGrad(textureSource${t + 1}, textureSampler${t + 1}, vUV, uvDx, uvDy);`),
                e.push("      break;}");
            e.push("}")
        }
        return e.join(`
`)
    }
    function Ch(i) {
        return Xo[i] || (Xo[i] = {
            name: "texture-batch-bit",
            vertex: {
                header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
                main: `
                vTextureId = aTextureIdAndRound.y;
            `,
                end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
            },
            fragment: {
                header: `
                @in @interpolate(flat) vTextureId: u32;

                ${ux(i)}
            `,
                main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${dx(i)}
            `
            }
        }),
        Xo[i]
    }
    var jo = {};
    function fx(i) {
        let e = [];
        for (let t = 0; t < i; t++)
            t > 0 && e.push("else"),
            t < i - 1 && e.push(`if(vTextureId < ${t}.5)`),
            e.push("{"),
            e.push(`	outColor = texture(uTextures[${t}], vUV);`),
            e.push("}");
        return e.join(`
`)
    }
    function Oh(i) {
        return jo[i] || (jo[i] = {
            name: "texture-batch-bit",
            vertex: {
                header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
                main: `
                vTextureId = aTextureIdAndRound.y;
            `,
                end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
            },
            fragment: {
                header: `
                in float vTextureId;

                uniform sampler2D uTextures[${i}];

            `,
                main: `

                ${fx(i)}
            `
            }
        }),
        jo[i]
    }
    var Ms = {
        name: "round-pixels-bit",
        vertex: {
            header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        }
    }
      , Cs = {
        name: "round-pixels-bit",
        vertex: {
            header: `
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        }
    }
      , S0 = ["f32", "i32", "vec2<f32>", "vec3<f32>", "vec4<f32>", "mat2x2<f32>", "mat3x3<f32>", "mat4x4<f32>", "mat3x2<f32>", "mat4x2<f32>", "mat2x3<f32>", "mat4x3<f32>", "mat2x4<f32>", "mat3x4<f32>", "vec2<i32>", "vec3<i32>", "vec4<i32>"]
      , px = S0.reduce( (i, e) => (i[e] = !0,
    i), {});
    function bx(i, e) {
        switch (i) {
        case "f32":
            return 0;
        case "vec2<f32>":
            return new Float32Array(2 * e);
        case "vec3<f32>":
            return new Float32Array(3 * e);
        case "vec4<f32>":
            return new Float32Array(4 * e);
        case "mat2x2<f32>":
            return new Float32Array([1, 0, 0, 1]);
        case "mat3x3<f32>":
            return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        case "mat4x4<f32>":
            return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
        }
        return null
    }
    var mx = Object.defineProperty
      , _d = Object.getOwnPropertySymbols
      , gx = Object.prototype.hasOwnProperty
      , _x = Object.prototype.propertyIsEnumerable
      , xd = (i, e, t) => e in i ? mx(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , yd = (i, e) => {
        for (var t in e || (e = {}))
            gx.call(e, t) && xd(i, t, e[t]);
        if (_d)
            for (var t of _d(e))
                _x.call(e, t) && xd(i, t, e[t]);
        return i
    }
      , w0 = class A0 {
        constructor(e, t) {
            this._touched = 0,
            this.uid = Xe("uniform"),
            this._resourceType = "uniformGroup",
            this._resourceId = Xe("resource"),
            this.isUniformGroup = !0,
            this._dirtyId = 0,
            this.destroyed = !1;
            var r, s;
            t = yd(yd({}, A0.defaultOptions), t),
            this.uniformStructures = e;
            let n = {};
            for (let a in e) {
                let c = e[a];
                if (c.name = a,
                c.size = (r = c.size) != null ? r : 1,
                !px[c.type]) {
                    let l = c.type.match(/^array<(\w+(?:<\w+>)?),\s*(\d+)>$/);
                    if (l) {
                        let[,u,d] = l;
                        throw new Error(`Uniform type ${c.type} is not supported. Use type: '${u}', size: ${d} instead.`)
                    }
                    throw new Error(`Uniform type ${c.type} is not supported. Supported uniform types are: ${S0.join(", ")}`)
                }
                (s = c.value) != null || (c.value = bx(c.type, c.size)),
                n[a] = c.value
            }
            this.uniforms = n,
            this._dirtyId = 1,
            this.ubo = t.ubo,
            this.isStatic = t.isStatic,
            this._signature = bs(Object.keys(n).map(a => `${a}-${e[a].type}`).join("-"), "uniform-group")
        }
        update() {
            this._dirtyId++
        }
    }
    ;
    w0.defaultOptions = {
        ubo: !1,
        isStatic: !1
    };
    var ct = w0
      , vd = {};
    function Ih(i) {
        let e = vd[i];
        if (e)
            return e;
        let t = new Int32Array(i);
        for (let r = 0; r < i; r++)
            t[r] = r;
        return e = vd[i] = new ct({
            uTextures: {
                value: t,
                type: "i32",
                size: i
            }
        },{
            isStatic: !0
        }),
        e
    }
    var Bt = (i => (i[i.WEBGL = 1] = "WEBGL",
    i[i.WEBGPU = 2] = "WEBGPU",
    i[i.BOTH = 3] = "BOTH",
    i))(Bt || {})
      , xx = Object.defineProperty
      , Mn = Object.getOwnPropertySymbols
      , E0 = Object.prototype.hasOwnProperty
      , P0 = Object.prototype.propertyIsEnumerable
      , Td = (i, e, t) => e in i ? xx(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , yx = (i, e) => {
        for (var t in e || (e = {}))
            E0.call(e, t) && Td(i, t, e[t]);
        if (Mn)
            for (var t of Mn(e))
                P0.call(e, t) && Td(i, t, e[t]);
        return i
    }
      , vx = (i, e) => {
        var t = {};
        for (var r in i)
            E0.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && Mn)
            for (var r of Mn(i))
                e.indexOf(r) < 0 && P0.call(i, r) && (t[r] = i[r]);
        return t
    }
      , At = class i extends Ft {
        constructor(e) {
            super(),
            this.uid = Xe("shader"),
            this._uniformBindMap = Object.create(null),
            this._ownedBindGroups = [];
            let {gpuProgram: t, glProgram: r, groups: s, resources: n, compatibleRenderers: a, groupMap: c} = e;
            this.gpuProgram = t,
            this.glProgram = r,
            a === void 0 && (a = 0,
            t && (a |= Bt.WEBGPU),
            r && (a |= Bt.WEBGL)),
            this.compatibleRenderers = a;
            let l = {};
            if (!n && !s && (n = {}),
            n && s)
                throw new Error("[Shader] Cannot have both resources and groups");
            if (!t && s && !c)
                throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
            if (!t && s && c)
                for (let u in c)
                    for (let d in c[u]) {
                        let f = c[u][d];
                        l[f] = {
                            group: u,
                            binding: d,
                            name: f
                        }
                    }
            else if (t && s && !c) {
                let u = t.structsAndGroups.groups;
                c = {},
                u.forEach(d => {
                    c[d.group] = c[d.group] || {},
                    c[d.group][d.binding] = d.name,
                    l[d.name] = d
                }
                )
            } else if (n) {
                s = {},
                c = {},
                t && t.structsAndGroups.groups.forEach(d => {
                    c[d.group] = c[d.group] || {},
                    c[d.group][d.binding] = d.name,
                    l[d.name] = d
                }
                );
                let u = 0;
                for (let d in n)
                    l[d] || (s[99] || (s[99] = new Qt,
                    this._ownedBindGroups.push(s[99])),
                    l[d] = {
                        group: 99,
                        binding: u,
                        name: d
                    },
                    c[99] = c[99] || {},
                    c[99][u] = d,
                    u++);
                for (let d in n) {
                    let f = d
                      , b = n[d];
                    !b.source && !b._resourceType && (b = new ct(b));
                    let m = l[f];
                    m && (s[m.group] || (s[m.group] = new Qt,
                    this._ownedBindGroups.push(s[m.group])),
                    s[m.group].setResource(b, m.binding))
                }
            }
            this.groups = s,
            this._uniformBindMap = c,
            this.resources = this._buildResourceAccessor(s, l)
        }
        addResource(e, t, r) {
            var s, n;
            (s = this._uniformBindMap)[t] || (s[t] = {}),
            (n = this._uniformBindMap[t])[r] || (n[r] = e),
            this.groups[t] || (this.groups[t] = new Qt,
            this._ownedBindGroups.push(this.groups[t]))
        }
        _buildResourceAccessor(e, t) {
            let r = {};
            for (let s in t) {
                let n = t[s];
                Object.defineProperty(r, n.name, {
                    get() {
                        return e[n.group].getResource(n.binding)
                    },
                    set(a) {
                        e[n.group].setResource(a, n.binding)
                    }
                })
            }
            return r
        }
        destroy(e=!1) {
            var t, r;
            this.emit("destroy", this),
            e && ((t = this.gpuProgram) == null || t.destroy(),
            (r = this.glProgram) == null || r.destroy()),
            this.gpuProgram = null,
            this.glProgram = null,
            this.removeAllListeners(),
            this._uniformBindMap = null,
            this._ownedBindGroups.forEach(s => {
                s.destroy()
            }
            ),
            this._ownedBindGroups = null,
            this.resources = null,
            this.groups = null
        }
        static from(e) {
            let t = e, {gpu: r, gl: s} = t, n = vx(t, ["gpu", "gl"]), a, c;
            return r && (a = ci.from(r)),
            s && (c = wi.from(s)),
            new i(yx({
                gpuProgram: a,
                glProgram: c
            }, n))
        }
    }
      , Kc = class extends At {
        constructor(e) {
            let t = Rs({
                name: "batch",
                bits: [Mh, Oh(e), Cs]
            })
              , r = Ps({
                name: "batch",
                bits: [Rh, Ch(e), Ms]
            });
            super({
                glProgram: t,
                gpuProgram: r,
                resources: {
                    batchSamplers: Ih(e)
                }
            })
        }
    }
      , Ho = null
      , R0 = class M0 extends E2 {
        constructor(e) {
            super(e),
            this.geometry = new Yc,
            this.name = M0.extension.name,
            this.vertexSize = 6,
            Ho != null || (Ho = new Kc(e.maxTextures)),
            this.shader = Ho
        }
        packAttributes(e, t, r, s, n) {
            let a = n << 16 | e.roundPixels & 65535
              , c = e.transform
              , l = c.a
              , u = c.b
              , d = c.c
              , f = c.d
              , b = c.tx
              , m = c.ty
              , {positions: x, uvs: y} = e
              , S = e.color
              , A = e.attributeOffset
              , E = A + e.attributeSize;
            for (let O = A; O < E; O++) {
                let M = O * 2
                  , j = x[M]
                  , L = x[M + 1];
                t[s++] = l * j + d * L + b,
                t[s++] = f * L + u * j + m,
                t[s++] = y[M],
                t[s++] = y[M + 1],
                r[s++] = S,
                r[s++] = a
            }
        }
        packQuadAttributes(e, t, r, s, n) {
            let a = e.texture
              , c = e.transform
              , l = c.a
              , u = c.b
              , d = c.c
              , f = c.d
              , b = c.tx
              , m = c.ty
              , x = e.bounds
              , y = x.maxX
              , S = x.minX
              , A = x.maxY
              , E = x.minY
              , O = a.uvs
              , M = e.color
              , j = n << 16 | e.roundPixels & 65535;
            t[s + 0] = l * S + d * E + b,
            t[s + 1] = f * E + u * S + m,
            t[s + 2] = O.x0,
            t[s + 3] = O.y0,
            r[s + 4] = M,
            r[s + 5] = j,
            t[s + 6] = l * y + d * E + b,
            t[s + 7] = f * E + u * y + m,
            t[s + 8] = O.x1,
            t[s + 9] = O.y1,
            r[s + 10] = M,
            r[s + 11] = j,
            t[s + 12] = l * y + d * A + b,
            t[s + 13] = f * A + u * y + m,
            t[s + 14] = O.x2,
            t[s + 15] = O.y2,
            r[s + 16] = M,
            r[s + 17] = j,
            t[s + 18] = l * S + d * A + b,
            t[s + 19] = f * A + u * S + m,
            t[s + 20] = O.x3,
            t[s + 21] = O.y3,
            r[s + 22] = M,
            r[s + 23] = j
        }
    }
    ;
    R0.extension = {
        type: [B.Batcher],
        name: "default"
    };
    var Gh = R0;
    function Tx(i, e, t, r, s, n, a, c=null) {
        let l = 0;
        t *= e,
        s *= n;
        let u = c.a
          , d = c.b
          , f = c.c
          , b = c.d
          , m = c.tx
          , x = c.ty;
        for (; l < a; ) {
            let y = i[t]
              , S = i[t + 1];
            r[s] = u * y + f * S + m,
            r[s + 1] = d * y + b * S + x,
            s += n,
            t += e,
            l++
        }
    }
    function Sx(i, e, t, r) {
        let s = 0;
        for (e *= t; s < r; )
            i[e] = 0,
            i[e + 1] = 0,
            e += t,
            s++
    }
    function C0(i, e, t, r, s) {
        let n = e.a
          , a = e.b
          , c = e.c
          , l = e.d
          , u = e.tx
          , d = e.ty;
        t || (t = 0),
        r || (r = 2),
        s || (s = i.length / r - t);
        let f = t * r;
        for (let b = 0; b < s; b++) {
            let m = i[f]
              , x = i[f + 1];
            i[f] = n * m + c * x + u,
            i[f + 1] = a * m + l * x + d,
            f += r
        }
    }
    var wx = new ce
      , ms = class {
        constructor() {
            this.packAsQuad = !1,
            this.batcherName = "default",
            this.topology = "triangle-list",
            this.applyTransform = !0,
            this.roundPixels = 0,
            this._batcher = null,
            this._batch = null
        }
        get uvs() {
            return this.geometryData.uvs
        }
        get positions() {
            return this.geometryData.vertices
        }
        get indices() {
            return this.geometryData.indices
        }
        get blendMode() {
            return this.renderable && this.applyTransform ? this.renderable.groupBlendMode : "normal"
        }
        get color() {
            let e = this.baseColor
              , t = e >> 16 | e & 65280 | (e & 255) << 16
              , r = this.renderable;
            return r ? Vb(t, r.groupColor) + (this.alpha * r.groupAlpha * 255 << 24) : t + (this.alpha * 255 << 24)
        }
        get transform() {
            var e;
            return ((e = this.renderable) == null ? void 0 : e.groupTransform) || wx
        }
        copyTo(e) {
            e.indexOffset = this.indexOffset,
            e.indexSize = this.indexSize,
            e.attributeOffset = this.attributeOffset,
            e.attributeSize = this.attributeSize,
            e.baseColor = this.baseColor,
            e.alpha = this.alpha,
            e.texture = this.texture,
            e.geometryData = this.geometryData,
            e.topology = this.topology
        }
        reset() {
            this.applyTransform = !0,
            this.renderable = null,
            this.topology = "triangle-list"
        }
        destroy() {
            this.renderable = null,
            this.texture = null,
            this.geometryData = null,
            this._batcher.destroy(),
            this._batcher = null,
            this._batch.destroy(),
            this._batch = null
        }
    }
      , Ax = Object.defineProperty
      , Ex = Object.defineProperties
      , Px = Object.getOwnPropertyDescriptors
      , Sd = Object.getOwnPropertySymbols
      , Rx = Object.prototype.hasOwnProperty
      , Mx = Object.prototype.propertyIsEnumerable
      , wd = (i, e, t) => e in i ? Ax(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Cn = (i, e) => {
        for (var t in e || (e = {}))
            Rx.call(e, t) && wd(i, t, e[t]);
        if (Sd)
            for (var t of Sd(e))
                Mx.call(e, t) && wd(i, t, e[t]);
        return i
    }
      , On = (i, e) => Ex(i, Px(e))
      , gs = {
        extension: {
            type: B.ShapeBuilder,
            name: "circle"
        },
        build(i, e) {
            let t, r, s, n, a, c;
            if (i.type === "circle") {
                let M = i;
                if (a = c = M.radius,
                a <= 0)
                    return !1;
                t = M.x,
                r = M.y,
                s = n = 0
            } else if (i.type === "ellipse") {
                let M = i;
                if (a = M.halfWidth,
                c = M.halfHeight,
                a <= 0 || c <= 0)
                    return !1;
                t = M.x,
                r = M.y,
                s = n = 0
            } else {
                let M = i
                  , j = M.width / 2
                  , L = M.height / 2;
                t = M.x + j,
                r = M.y + L,
                a = c = Math.max(0, Math.min(M.radius, Math.min(j, L))),
                s = j - a,
                n = L - c
            }
            if (s < 0 || n < 0)
                return !1;
            let l = Math.ceil(2.3 * Math.sqrt(a + c))
              , u = l * 8 + (s ? 4 : 0) + (n ? 4 : 0);
            if (u === 0)
                return !1;
            if (l === 0)
                return e[0] = e[6] = t + s,
                e[1] = e[3] = r + n,
                e[2] = e[4] = t - s,
                e[5] = e[7] = r - n,
                !0;
            let d = 0
              , f = l * 4 + (s ? 2 : 0) + 2
              , b = f
              , m = u
              , x = s + a
              , y = n
              , S = t + x
              , A = t - x
              , E = r + y;
            if (e[d++] = S,
            e[d++] = E,
            e[--f] = E,
            e[--f] = A,
            n) {
                let M = r - y;
                e[b++] = A,
                e[b++] = M,
                e[--m] = M,
                e[--m] = S
            }
            for (let M = 1; M < l; M++) {
                let j = Math.PI / 2 * (M / l)
                  , L = s + Math.cos(j) * a
                  , N = n + Math.sin(j) * c
                  , Y = t + L
                  , ie = t - L
                  , $ = r + N
                  , J = r - N;
                e[d++] = Y,
                e[d++] = $,
                e[--f] = $,
                e[--f] = ie,
                e[b++] = ie,
                e[b++] = J,
                e[--m] = J,
                e[--m] = Y
            }
            x = s,
            y = n + c,
            S = t + x,
            A = t - x,
            E = r + y;
            let O = r - y;
            return e[d++] = S,
            e[d++] = E,
            e[--m] = O,
            e[--m] = S,
            s && (e[d++] = A,
            e[d++] = E,
            e[--m] = O,
            e[--m] = A),
            !0
        },
        triangulate(i, e, t, r, s, n) {
            if (i.length === 0)
                return;
            let a = 0
              , c = 0;
            for (let d = 0; d < i.length; d += 2)
                a += i[d],
                c += i[d + 1];
            a /= i.length / 2,
            c /= i.length / 2;
            let l = r;
            e[l * t] = a,
            e[l * t + 1] = c;
            let u = l++;
            for (let d = 0; d < i.length; d += 2)
                e[l * t] = i[d],
                e[l * t + 1] = i[d + 1],
                d > 0 && (s[n++] = l,
                s[n++] = u,
                s[n++] = l - 1),
                l++;
            s[n++] = u + 1,
            s[n++] = u,
            s[n++] = l - 1
        }
    }
      , Cx = On(Cn({}, gs), {
        extension: On(Cn({}, gs.extension), {
            name: "ellipse"
        })
    })
      , Ox = On(Cn({}, gs), {
        extension: On(Cn({}, gs.extension), {
            name: "roundedRectangle"
        })
    })
      , O0 = 1e-4
      , Ad = 1e-4;
    function Ix(i) {
        let e = i.length;
        if (e < 6)
            return 1;
        let t = 0;
        for (let r = 0, s = i[e - 2], n = i[e - 1]; r < e; r += 2) {
            let a = i[r]
              , c = i[r + 1];
            t += (a - s) * (c + n),
            s = a,
            n = c
        }
        return t < 0 ? -1 : 1
    }
    function Ed(i, e, t, r, s, n, a, c) {
        let l = i - t * s, u = e - r * s, d = i + t * n, f = e + r * n, b, m;
        a ? (b = r,
        m = -t) : (b = -r,
        m = t);
        let x = l + b
          , y = u + m
          , S = d + b
          , A = f + m;
        return c.push(x, y),
        c.push(S, A),
        2
    }
    function ji(i, e, t, r, s, n, a, c) {
        let l = t - i
          , u = r - e
          , d = Math.atan2(l, u)
          , f = Math.atan2(s - i, n - e);
        c && d < f ? d += Math.PI * 2 : !c && d > f && (f += Math.PI * 2);
        let b = d
          , m = f - d
          , x = Math.abs(m)
          , y = Math.sqrt(l * l + u * u)
          , S = (15 * x * Math.sqrt(y) / Math.PI >> 0) + 1
          , A = m / S;
        if (b += A,
        c) {
            a.push(i, e),
            a.push(t, r);
            for (let E = 1, O = b; E < S; E++,
            O += A)
                a.push(i, e),
                a.push(i + Math.sin(O) * y, e + Math.cos(O) * y);
            a.push(i, e),
            a.push(s, n)
        } else {
            a.push(t, r),
            a.push(i, e);
            for (let E = 1, O = b; E < S; E++,
            O += A)
                a.push(i + Math.sin(O) * y, e + Math.cos(O) * y),
                a.push(i, e);
            a.push(s, n),
            a.push(i, e)
        }
        return S * 2
    }
    function Gx(i, e, t, r, s, n) {
        let a = O0;
        if (i.length === 0)
            return;
        let c = e
          , l = c.alignment;
        if (e.alignment !== .5) {
            let Se = Ix(i);
            t && (Se *= -1),
            l = (l - .5) * Se + .5
        }
        let u = new Ne(i[0],i[1])
          , d = new Ne(i[i.length - 2],i[i.length - 1])
          , f = r
          , b = Math.abs(u.x - d.x) < a && Math.abs(u.y - d.y) < a;
        if (f) {
            i = i.slice(),
            b && (i.pop(),
            i.pop(),
            d.set(i[i.length - 2], i[i.length - 1]));
            let Se = (u.x + d.x) * .5
              , xt = (d.y + u.y) * .5;
            i.unshift(Se, xt),
            i.push(Se, xt)
        }
        let m = s
          , x = i.length / 2
          , y = i.length
          , S = m.length / 2
          , A = c.width / 2
          , E = A * A
          , O = c.miterLimit * c.miterLimit
          , M = i[0]
          , j = i[1]
          , L = i[2]
          , N = i[3]
          , Y = 0
          , ie = 0
          , $ = -(j - N)
          , J = M - L
          , re = 0
          , Q = 0
          , pe = Math.sqrt($ * $ + J * J);
        $ /= pe,
        J /= pe,
        $ *= A,
        J *= A;
        let Be = l
          , ne = (1 - Be) * 2
          , se = Be * 2;
        f || (c.cap === "round" ? y += ji(M - $ * (ne - se) * .5, j - J * (ne - se) * .5, M - $ * ne, j - J * ne, M + $ * se, j + J * se, m, !0) + 2 : c.cap === "square" && (y += Ed(M, j, $, J, ne, se, !0, m))),
        m.push(M - $ * ne, j - J * ne),
        m.push(M + $ * se, j + J * se);
        for (let Se = 1; Se < x - 1; ++Se) {
            M = i[(Se - 1) * 2],
            j = i[(Se - 1) * 2 + 1],
            L = i[Se * 2],
            N = i[Se * 2 + 1],
            Y = i[(Se + 1) * 2],
            ie = i[(Se + 1) * 2 + 1],
            $ = -(j - N),
            J = M - L,
            pe = Math.sqrt($ * $ + J * J),
            $ /= pe,
            J /= pe,
            $ *= A,
            J *= A,
            re = -(N - ie),
            Q = L - Y,
            pe = Math.sqrt(re * re + Q * Q),
            re /= pe,
            Q /= pe,
            re *= A,
            Q *= A;
            let xt = L - M
              , tt = j - N
              , zt = L - Y
              , Ve = ie - N
              , Vt = xt * zt + tt * Ve
              , Wt = tt * zt - Ve * xt
              , it = Wt < 0;
            if (Math.abs(Wt) < .001 * Math.abs(Vt)) {
                m.push(L - $ * ne, N - J * ne),
                m.push(L + $ * se, N + J * se),
                Vt >= 0 && (c.join === "round" ? y += ji(L, N, L - $ * ne, N - J * ne, L - re * ne, N - Q * ne, m, !1) + 4 : y += 2,
                m.push(L - re * se, N - Q * se),
                m.push(L + re * ne, N + Q * ne));
                continue
            }
            let ze = (-$ + M) * (-J + N) - (-$ + L) * (-J + j)
              , ot = (-re + Y) * (-Q + N) - (-re + L) * (-Q + ie)
              , je = (xt * ot - zt * ze) / Wt
              , yt = (Ve * ze - tt * ot) / Wt
              , si = (je - L) * (je - L) + (yt - N) * (yt - N)
              , vt = L + (je - L) * ne
              , Tt = N + (yt - N) * ne
              , ut = L - (je - L) * se
              , ft = N - (yt - N) * se
              , Dt = Math.min(xt * xt + tt * tt, zt * zt + Ve * Ve)
              , kt = it ? ne : se
              , ke = Dt + kt * kt * E;
            si <= ke ? c.join === "bevel" || si / E > O ? (it ? (m.push(vt, Tt),
            m.push(L + $ * se, N + J * se),
            m.push(vt, Tt),
            m.push(L + re * se, N + Q * se)) : (m.push(L - $ * ne, N - J * ne),
            m.push(ut, ft),
            m.push(L - re * ne, N - Q * ne),
            m.push(ut, ft)),
            y += 2) : c.join === "round" ? it ? (m.push(vt, Tt),
            m.push(L + $ * se, N + J * se),
            y += ji(L, N, L + $ * se, N + J * se, L + re * se, N + Q * se, m, !0) + 4,
            m.push(vt, Tt),
            m.push(L + re * se, N + Q * se)) : (m.push(L - $ * ne, N - J * ne),
            m.push(ut, ft),
            y += ji(L, N, L - $ * ne, N - J * ne, L - re * ne, N - Q * ne, m, !1) + 4,
            m.push(L - re * ne, N - Q * ne),
            m.push(ut, ft)) : (m.push(vt, Tt),
            m.push(ut, ft)) : (m.push(L - $ * ne, N - J * ne),
            m.push(L + $ * se, N + J * se),
            c.join === "round" ? it ? y += ji(L, N, L + $ * se, N + J * se, L + re * se, N + Q * se, m, !0) + 2 : y += ji(L, N, L - $ * ne, N - J * ne, L - re * ne, N - Q * ne, m, !1) + 2 : c.join === "miter" && si / E <= O && (it ? (m.push(ut, ft),
            m.push(ut, ft)) : (m.push(vt, Tt),
            m.push(vt, Tt)),
            y += 2),
            m.push(L - re * ne, N - Q * ne),
            m.push(L + re * se, N + Q * se),
            y += 2)
        }
        M = i[(x - 2) * 2],
        j = i[(x - 2) * 2 + 1],
        L = i[(x - 1) * 2],
        N = i[(x - 1) * 2 + 1],
        $ = -(j - N),
        J = M - L,
        pe = Math.sqrt($ * $ + J * J),
        $ /= pe,
        J /= pe,
        $ *= A,
        J *= A,
        m.push(L - $ * ne, N - J * ne),
        m.push(L + $ * se, N + J * se),
        f || (c.cap === "round" ? y += ji(L - $ * (ne - se) * .5, N - J * (ne - se) * .5, L - $ * ne, N - J * ne, L + $ * se, N + J * se, m, !1) + 2 : c.cap === "square" && (y += Ed(L, N, $, J, ne, se, !1, m)));
        let Pi = Ad * Ad;
        for (let Se = S; Se < y + S - 2; ++Se)
            M = m[Se * 2],
            j = m[Se * 2 + 1],
            L = m[(Se + 1) * 2],
            N = m[(Se + 1) * 2 + 1],
            Y = m[(Se + 2) * 2],
            ie = m[(Se + 2) * 2 + 1],
            !(Math.abs(M * (N - ie) + L * (ie - j) + Y * (j - N)) < Pi) && n.push(Se, Se + 1, Se + 2)
    }
    function Bx(i, e, t, r) {
        let s = O0;
        if (i.length === 0)
            return;
        let n = i[0]
          , a = i[1]
          , c = i[i.length - 2]
          , l = i[i.length - 1]
          , u = e || Math.abs(n - c) < s && Math.abs(a - l) < s
          , d = t
          , f = i.length / 2
          , b = d.length / 2;
        for (let m = 0; m < f; m++)
            d.push(i[m * 2]),
            d.push(i[m * 2 + 1]);
        for (let m = 0; m < f - 1; m++)
            r.push(b + m, b + m + 1);
        u && r.push(b + f - 1, b)
    }
    function Pd(i, e, t=2) {
        let r = e && e.length
          , s = r ? e[0] * t : i.length
          , n = I0(i, 0, s, t, !0)
          , a = [];
        if (!n || n.next === n.prev)
            return a;
        let c, l, u;
        if (r && (n = Lx(i, e, n, t)),
        i.length > 80 * t) {
            c = i[0],
            l = i[1];
            let d = c
              , f = l;
            for (let b = t; b < s; b += t) {
                let m = i[b]
                  , x = i[b + 1];
                m < c && (c = m),
                x < l && (l = x),
                m > d && (d = m),
                x > f && (f = x)
            }
            u = Math.max(d - c, f - l),
            u = u !== 0 ? 32767 / u : 0
        }
        return _s(n, a, t, c, l, u, 0),
        a
    }
    function I0(i, e, t, r, s) {
        let n;
        if (s === qx(i, e, t, r) > 0)
            for (let a = e; a < t; a += r)
                n = Rd(a / r | 0, i[a], i[a + 1], n);
        else
            for (let a = t - r; a >= e; a -= r)
                n = Rd(a / r | 0, i[a], i[a + 1], n);
        return n && Er(n, n.next) && (ys(n),
        n = n.next),
        n
    }
    function er(i, e) {
        if (!i)
            return i;
        e || (e = i);
        let t = i, r;
        do
            if (r = !1,
            !t.steiner && (Er(t, t.next) || Ye(t.prev, t, t.next) === 0)) {
                if (ys(t),
                t = e = t.prev,
                t === t.next)
                    break;
                r = !0
            } else
                t = t.next;
        while (r || t !== e);
        return e
    }
    function _s(i, e, t, r, s, n, a) {
        if (!i)
            return;
        !a && n && zx(i, r, s, n);
        let c = i;
        for (; i.prev !== i.next; ) {
            let l = i.prev
              , u = i.next;
            if (n ? Dx(i, r, s, n) : Fx(i)) {
                e.push(l.i, i.i, u.i),
                ys(i),
                i = u.next,
                c = u.next;
                continue
            }
            if (i = u,
            i === c) {
                a ? a === 1 ? (i = kx(er(i), e),
                _s(i, e, t, r, s, n, 2)) : a === 2 && Ux(i, e, t, r, s, n) : _s(er(i), e, t, r, s, n, 1);
                break
            }
        }
    }
    function Fx(i) {
        let e = i.prev
          , t = i
          , r = i.next;
        if (Ye(e, t, r) >= 0)
            return !1;
        let s = e.x
          , n = t.x
          , a = r.x
          , c = e.y
          , l = t.y
          , u = r.y
          , d = Math.min(s, n, a)
          , f = Math.min(c, l, u)
          , b = Math.max(s, n, a)
          , m = Math.max(c, l, u)
          , x = r.next;
        for (; x !== e; ) {
            if (x.x >= d && x.x <= b && x.y >= f && x.y <= m && Jr(s, c, n, l, a, u, x.x, x.y) && Ye(x.prev, x, x.next) >= 0)
                return !1;
            x = x.next
        }
        return !0
    }
    function Dx(i, e, t, r) {
        let s = i.prev
          , n = i
          , a = i.next;
        if (Ye(s, n, a) >= 0)
            return !1;
        let c = s.x
          , l = n.x
          , u = a.x
          , d = s.y
          , f = n.y
          , b = a.y
          , m = Math.min(c, l, u)
          , x = Math.min(d, f, b)
          , y = Math.max(c, l, u)
          , S = Math.max(d, f, b)
          , A = qc(m, x, e, t, r)
          , E = qc(y, S, e, t, r)
          , O = i.prevZ
          , M = i.nextZ;
        for (; O && O.z >= A && M && M.z <= E; ) {
            if (O.x >= m && O.x <= y && O.y >= x && O.y <= S && O !== s && O !== a && Jr(c, d, l, f, u, b, O.x, O.y) && Ye(O.prev, O, O.next) >= 0 || (O = O.prevZ,
            M.x >= m && M.x <= y && M.y >= x && M.y <= S && M !== s && M !== a && Jr(c, d, l, f, u, b, M.x, M.y) && Ye(M.prev, M, M.next) >= 0))
                return !1;
            M = M.nextZ
        }
        for (; O && O.z >= A; ) {
            if (O.x >= m && O.x <= y && O.y >= x && O.y <= S && O !== s && O !== a && Jr(c, d, l, f, u, b, O.x, O.y) && Ye(O.prev, O, O.next) >= 0)
                return !1;
            O = O.prevZ
        }
        for (; M && M.z <= E; ) {
            if (M.x >= m && M.x <= y && M.y >= x && M.y <= S && M !== s && M !== a && Jr(c, d, l, f, u, b, M.x, M.y) && Ye(M.prev, M, M.next) >= 0)
                return !1;
            M = M.nextZ
        }
        return !0
    }
    function kx(i, e) {
        let t = i;
        do {
            let r = t.prev
              , s = t.next.next;
            !Er(r, s) && B0(r, t, t.next, s) && xs(r, s) && xs(s, r) && (e.push(r.i, t.i, s.i),
            ys(t),
            ys(t.next),
            t = i = s),
            t = t.next
        } while (t !== i);
        return er(t)
    }
    function Ux(i, e, t, r, s, n) {
        let a = i;
        do {
            let c = a.next.next;
            for (; c !== a.prev; ) {
                if (a.i !== c.i && Yx(a, c)) {
                    let l = F0(a, c);
                    a = er(a, a.next),
                    l = er(l, l.next),
                    _s(a, e, t, r, s, n, 0),
                    _s(l, e, t, r, s, n, 0);
                    return
                }
                c = c.next
            }
            a = a.next
        } while (a !== i)
    }
    function Lx(i, e, t, r) {
        let s = [];
        for (let n = 0, a = e.length; n < a; n++) {
            let c = e[n] * r
              , l = n < a - 1 ? e[n + 1] * r : i.length
              , u = I0(i, c, l, r, !1);
            u === u.next && (u.steiner = !0),
            s.push(Wx(u))
        }
        s.sort(Nx);
        for (let n = 0; n < s.length; n++)
            t = Xx(s[n], t);
        return t
    }
    function Nx(i, e) {
        let t = i.x - e.x;
        if (t === 0 && (t = i.y - e.y,
        t === 0)) {
            let r = (i.next.y - i.y) / (i.next.x - i.x)
              , s = (e.next.y - e.y) / (e.next.x - e.x);
            t = r - s
        }
        return t
    }
    function Xx(i, e) {
        let t = jx(i, e);
        if (!t)
            return e;
        let r = F0(t, i);
        return er(r, r.next),
        er(t, t.next)
    }
    function jx(i, e) {
        let t = e, r = i.x, s = i.y, n = -1 / 0, a;
        if (Er(i, t))
            return t;
        do {
            if (Er(i, t.next))
                return t.next;
            if (s <= t.y && s >= t.next.y && t.next.y !== t.y) {
                let f = t.x + (s - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
                if (f <= r && f > n && (n = f,
                a = t.x < t.next.x ? t : t.next,
                f === r))
                    return a
            }
            t = t.next
        } while (t !== e);
        if (!a)
            return null;
        let c = a
          , l = a.x
          , u = a.y
          , d = 1 / 0;
        t = a;
        do {
            if (r >= t.x && t.x >= l && r !== t.x && G0(s < u ? r : n, s, l, u, s < u ? n : r, s, t.x, t.y)) {
                let f = Math.abs(s - t.y) / (r - t.x);
                xs(t, i) && (f < d || f === d && (t.x > a.x || t.x === a.x && Hx(a, t))) && (a = t,
                d = f)
            }
            t = t.next
        } while (t !== c);
        return a
    }
    function Hx(i, e) {
        return Ye(i.prev, i, e.prev) < 0 && Ye(e.next, i, i.next) < 0
    }
    function zx(i, e, t, r) {
        let s = i;
        do
            s.z === 0 && (s.z = qc(s.x, s.y, e, t, r)),
            s.prevZ = s.prev,
            s.nextZ = s.next,
            s = s.next;
        while (s !== i);
        s.prevZ.nextZ = null,
        s.prevZ = null,
        Vx(s)
    }
    function Vx(i) {
        let e, t = 1;
        do {
            let r = i, s;
            i = null;
            let n = null;
            for (e = 0; r; ) {
                e++;
                let a = r
                  , c = 0;
                for (let u = 0; u < t && (c++,
                a = a.nextZ,
                !!a); u++)
                    ;
                let l = t;
                for (; c > 0 || l > 0 && a; )
                    c !== 0 && (l === 0 || !a || r.z <= a.z) ? (s = r,
                    r = r.nextZ,
                    c--) : (s = a,
                    a = a.nextZ,
                    l--),
                    n ? n.nextZ = s : i = s,
                    s.prevZ = n,
                    n = s;
                r = a
            }
            n.nextZ = null,
            t *= 2
        } while (e > 1);
        return i
    }
    function qc(i, e, t, r, s) {
        return i = (i - t) * s | 0,
        e = (e - r) * s | 0,
        i = (i | i << 8) & 16711935,
        i = (i | i << 4) & 252645135,
        i = (i | i << 2) & 858993459,
        i = (i | i << 1) & 1431655765,
        e = (e | e << 8) & 16711935,
        e = (e | e << 4) & 252645135,
        e = (e | e << 2) & 858993459,
        e = (e | e << 1) & 1431655765,
        i | e << 1
    }
    function Wx(i) {
        let e = i
          , t = i;
        do
            (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e),
            e = e.next;
        while (e !== i);
        return t
    }
    function G0(i, e, t, r, s, n, a, c) {
        return (s - a) * (e - c) >= (i - a) * (n - c) && (i - a) * (r - c) >= (t - a) * (e - c) && (t - a) * (n - c) >= (s - a) * (r - c)
    }
    function Jr(i, e, t, r, s, n, a, c) {
        return !(i === a && e === c) && G0(i, e, t, r, s, n, a, c)
    }
    function Yx(i, e) {
        return i.next.i !== e.i && i.prev.i !== e.i && !$x(i, e) && (xs(i, e) && xs(e, i) && Kx(i, e) && (Ye(i.prev, i, e.prev) || Ye(i, e.prev, e)) || Er(i, e) && Ye(i.prev, i, i.next) > 0 && Ye(e.prev, e, e.next) > 0)
    }
    function Ye(i, e, t) {
        return (e.y - i.y) * (t.x - e.x) - (e.x - i.x) * (t.y - e.y)
    }
    function Er(i, e) {
        return i.x === e.x && i.y === e.y
    }
    function B0(i, e, t, r) {
        let s = Vs(Ye(i, e, t))
          , n = Vs(Ye(i, e, r))
          , a = Vs(Ye(t, r, i))
          , c = Vs(Ye(t, r, e));
        return !!(s !== n && a !== c || s === 0 && zs(i, t, e) || n === 0 && zs(i, r, e) || a === 0 && zs(t, i, r) || c === 0 && zs(t, e, r))
    }
    function zs(i, e, t) {
        return e.x <= Math.max(i.x, t.x) && e.x >= Math.min(i.x, t.x) && e.y <= Math.max(i.y, t.y) && e.y >= Math.min(i.y, t.y)
    }
    function Vs(i) {
        return i > 0 ? 1 : i < 0 ? -1 : 0
    }
    function $x(i, e) {
        let t = i;
        do {
            if (t.i !== i.i && t.next.i !== i.i && t.i !== e.i && t.next.i !== e.i && B0(t, t.next, i, e))
                return !0;
            t = t.next
        } while (t !== i);
        return !1
    }
    function xs(i, e) {
        return Ye(i.prev, i, i.next) < 0 ? Ye(i, e, i.next) >= 0 && Ye(i, i.prev, e) >= 0 : Ye(i, e, i.prev) < 0 || Ye(i, i.next, e) < 0
    }
    function Kx(i, e) {
        let t = i
          , r = !1
          , s = (i.x + e.x) / 2
          , n = (i.y + e.y) / 2;
        do
            t.y > n != t.next.y > n && t.next.y !== t.y && s < (t.next.x - t.x) * (n - t.y) / (t.next.y - t.y) + t.x && (r = !r),
            t = t.next;
        while (t !== i);
        return r
    }
    function F0(i, e) {
        let t = Zc(i.i, i.x, i.y)
          , r = Zc(e.i, e.x, e.y)
          , s = i.next
          , n = e.prev;
        return i.next = e,
        e.prev = i,
        t.next = s,
        s.prev = t,
        r.next = t,
        t.prev = r,
        n.next = r,
        r.prev = n,
        r
    }
    function Rd(i, e, t, r) {
        let s = Zc(i, e, t);
        return r ? (s.next = r.next,
        s.prev = r,
        r.next.prev = s,
        r.next = s) : (s.prev = s,
        s.next = s),
        s
    }
    function ys(i) {
        i.next.prev = i.prev,
        i.prev.next = i.next,
        i.prevZ && (i.prevZ.nextZ = i.nextZ),
        i.nextZ && (i.nextZ.prevZ = i.prevZ)
    }
    function Zc(i, e, t) {
        return {
            i,
            x: e,
            y: t,
            prev: null,
            next: null,
            z: 0,
            prevZ: null,
            nextZ: null,
            steiner: !1
        }
    }
    function qx(i, e, t, r) {
        let s = 0;
        for (let n = e, a = t - r; n < t; n += r)
            s += (i[a] - i[n]) * (i[n + 1] + i[a + 1]),
            a = n;
        return s
    }
    var Zx = Pd.default || Pd;
    function D0(i, e, t, r, s, n, a) {
        let c = Zx(i, e, 2);
        if (!c)
            return;
        for (let u = 0; u < c.length; u += 3)
            n[a++] = c[u] + s,
            n[a++] = c[u + 1] + s,
            n[a++] = c[u + 2] + s;
        let l = s * r;
        for (let u = 0; u < i.length; u += 2)
            t[l] = i[u],
            t[l + 1] = i[u + 1],
            l += r
    }
    var Qx = []
      , Jx = {
        extension: {
            type: B.ShapeBuilder,
            name: "polygon"
        },
        build(i, e) {
            for (let t = 0; t < i.points.length; t++)
                e[t] = i.points[t];
            return !0
        },
        triangulate(i, e, t, r, s, n) {
            D0(i, Qx, e, t, r, s, n)
        }
    }
      , ey = {
        extension: {
            type: B.ShapeBuilder,
            name: "rectangle"
        },
        build(i, e) {
            let t = i
              , r = t.x
              , s = t.y
              , n = t.width
              , a = t.height;
            return n > 0 && a > 0 ? (e[0] = r,
            e[1] = s,
            e[2] = r + n,
            e[3] = s,
            e[4] = r + n,
            e[5] = s + a,
            e[6] = r,
            e[7] = s + a,
            !0) : !1
        },
        triangulate(i, e, t, r, s, n) {
            let a = 0;
            r *= t,
            e[r + a] = i[0],
            e[r + a + 1] = i[1],
            a += t,
            e[r + a] = i[2],
            e[r + a + 1] = i[3],
            a += t,
            e[r + a] = i[6],
            e[r + a + 1] = i[7],
            a += t,
            e[r + a] = i[4],
            e[r + a + 1] = i[5],
            a += t;
            let c = r / t;
            s[n++] = c,
            s[n++] = c + 1,
            s[n++] = c + 2,
            s[n++] = c + 1,
            s[n++] = c + 3,
            s[n++] = c + 2
        }
    }
      , ty = {
        extension: {
            type: B.ShapeBuilder,
            name: "triangle"
        },
        build(i, e) {
            return e[0] = i.x,
            e[1] = i.y,
            e[2] = i.x2,
            e[3] = i.y2,
            e[4] = i.x3,
            e[5] = i.y3,
            !0
        },
        triangulate(i, e, t, r, s, n) {
            let a = 0;
            r *= t,
            e[r + a] = i[0],
            e[r + a + 1] = i[1],
            a += t,
            e[r + a] = i[2],
            e[r + a + 1] = i[3],
            a += t,
            e[r + a] = i[4],
            e[r + a + 1] = i[5];
            let c = r / t;
            s[n++] = c,
            s[n++] = c + 1,
            s[n++] = c + 2
        }
    }
      , iy = Object.defineProperty
      , Md = Object.getOwnPropertySymbols
      , ry = Object.prototype.hasOwnProperty
      , sy = Object.prototype.propertyIsEnumerable
      , Cd = (i, e, t) => e in i ? iy(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Od = (i, e) => {
        for (var t in e || (e = {}))
            ry.call(e, t) && Cd(i, t, e[t]);
        if (Md)
            for (var t of Md(e))
                sy.call(e, t) && Cd(i, t, e[t]);
        return i
    }
      , Id = [{
        offset: 0,
        color: "white"
    }, {
        offset: 1,
        color: "black"
    }]
      , Qc = class Jc {
        constructor(...e) {
            this.uid = Xe("fillGradient"),
            this._tick = 0,
            this.type = "linear",
            this.colorStops = [];
            var t;
            let r = ny(e)
              , s = r.type === "radial" ? Jc.defaultRadialOptions : Jc.defaultLinearOptions;
            r = Od(Od({}, s), wr(r)),
            this._textureSize = r.textureSize,
            this._wrapMode = r.wrapMode,
            r.type === "radial" ? (this.center = r.center,
            this.outerCenter = (t = r.outerCenter) != null ? t : this.center,
            this.innerRadius = r.innerRadius,
            this.outerRadius = r.outerRadius,
            this.scale = r.scale,
            this.rotation = r.rotation) : (this.start = r.start,
            this.end = r.end),
            this.textureSpace = r.textureSpace,
            this.type = r.type,
            r.colorStops.forEach(n => {
                this.addColorStop(n.offset, n.color)
            }
            )
        }
        addColorStop(e, t) {
            return this.colorStops.push({
                offset: e,
                color: Ie.shared.setValue(t).toHexa()
            }),
            this
        }
        buildLinearGradient() {
            if (this.texture)
                return;
            let {x: e, y: t} = this.start
              , {x: r, y: s} = this.end
              , n = r - e
              , a = s - t
              , c = n < 0 || a < 0;
            if (this._wrapMode === "clamp-to-edge") {
                if (n < 0) {
                    let S = e;
                    e = r,
                    r = S,
                    n *= -1
                }
                if (a < 0) {
                    let S = t;
                    t = s,
                    s = S,
                    a *= -1
                }
            }
            let l = this.colorStops.length ? this.colorStops : Id
              , u = this._textureSize
              , {canvas: d, context: f} = Bd(u, 1)
              , b = c ? f.createLinearGradient(this._textureSize, 0, 0, 0) : f.createLinearGradient(0, 0, this._textureSize, 0);
            Gd(b, l),
            f.fillStyle = b,
            f.fillRect(0, 0, u, 1),
            this.texture = new Z({
                source: new yi({
                    resource: d,
                    addressMode: this._wrapMode
                })
            });
            let m = Math.sqrt(n * n + a * a)
              , x = Math.atan2(a, n)
              , y = new ce;
            y.scale(m / u, 1),
            y.rotate(x),
            y.translate(e, t),
            this.textureSpace === "local" && y.scale(u, u),
            this.transform = y
        }
        buildGradient() {
            this.texture || this._tick++,
            this.type === "linear" ? this.buildLinearGradient() : this.buildRadialGradient()
        }
        buildRadialGradient() {
            if (this.texture)
                return;
            let e = this.colorStops.length ? this.colorStops : Id
              , t = this._textureSize
              , {canvas: r, context: s} = Bd(t, t)
              , {x: n, y: a} = this.center
              , {x: c, y: l} = this.outerCenter
              , u = this.innerRadius
              , d = this.outerRadius
              , f = c - d
              , b = l - d
              , m = t / (d * 2)
              , x = (n - f) * m
              , y = (a - b) * m
              , S = s.createRadialGradient(x, y, u * m, (c - f) * m, (l - b) * m, d * m);
            Gd(S, e),
            s.fillStyle = e[e.length - 1].color,
            s.fillRect(0, 0, t, t),
            s.fillStyle = S,
            s.translate(x, y),
            s.rotate(this.rotation),
            s.scale(1, this.scale),
            s.translate(-x, -y),
            s.fillRect(0, 0, t, t),
            this.texture = new Z({
                source: new yi({
                    resource: r,
                    addressMode: this._wrapMode
                })
            });
            let A = new ce;
            A.scale(1 / m, 1 / m),
            A.translate(f, b),
            this.textureSpace === "local" && A.scale(t, t),
            this.transform = A
        }
        destroy() {
            var e;
            (e = this.texture) == null || e.destroy(!0),
            this.texture = null,
            this.transform = null,
            this.colorStops = [],
            this.start = null,
            this.end = null,
            this.center = null,
            this.outerCenter = null
        }
        get styleKey() {
            return `fill-gradient-${this.uid}-${this._tick}`
        }
    }
    ;
    Qc.defaultLinearOptions = {
        start: {
            x: 0,
            y: 0
        },
        end: {
            x: 0,
            y: 1
        },
        colorStops: [],
        textureSpace: "local",
        type: "linear",
        textureSize: 256,
        wrapMode: "clamp-to-edge"
    },
    Qc.defaultRadialOptions = {
        center: {
            x: .5,
            y: .5
        },
        innerRadius: 0,
        outerRadius: .5,
        colorStops: [],
        scale: 1,
        textureSpace: "local",
        type: "radial",
        textureSize: 256,
        wrapMode: "clamp-to-edge"
    };
    var vi = Qc;
    function Gd(i, e) {
        for (let t = 0; t < e.length; t++) {
            let r = e[t];
            i.addColorStop(r.offset, r.color)
        }
    }
    function Bd(i, e) {
        let t = xe.get().createCanvas(i, e)
          , r = t.getContext("2d");
        return {
            canvas: t,
            context: r
        }
    }
    function ny(i) {
        var e, t;
        let r = (e = i[0]) != null ? e : {};
        return (typeof r == "number" || i[1]) && (r = {
            type: "linear",
            start: {
                x: i[0],
                y: i[1]
            },
            end: {
                x: i[2],
                y: i[3]
            },
            textureSpace: i[4],
            textureSize: (t = i[5]) != null ? t : vi.defaultLinearOptions.textureSize
        }),
        r
    }
    var ay = new ce
      , oy = new Re;
    function cy(i, e, t, r) {
        let s = e.matrix ? i.copyFrom(e.matrix).invert() : i.identity();
        if (e.textureSpace === "local") {
            let a = t.getBounds(oy);
            e.width && a.pad(e.width);
            let {x: c, y: l} = a
              , u = 1 / a.width
              , d = 1 / a.height
              , f = -c * u
              , b = -l * d
              , m = s.a
              , x = s.b
              , y = s.c
              , S = s.d;
            s.a *= u,
            s.b *= u,
            s.c *= d,
            s.d *= d,
            s.tx = f * m + b * y + s.tx,
            s.ty = f * x + b * S + s.ty
        } else
            s.translate(e.texture.frame.x, e.texture.frame.y),
            s.scale(1 / e.texture.source.width, 1 / e.texture.source.height);
        let n = e.texture.source.style;
        return !(e.fill instanceof vi) && n.addressMode === "clamp-to-edge" && (n.addressMode = "repeat",
        n.update()),
        r && s.append(ay.copyFrom(r).invert()),
        s
    }
    var fo = {};
    be.handleByMap(B.ShapeBuilder, fo),
    be.add(ey, Jx, ty, gs, Cx, Ox);
    var ly = new Re
      , hy = new ce;
    function uy(i, e) {
        let {geometryData: t, batches: r} = e;
        r.length = 0,
        t.indices.length = 0,
        t.vertices.length = 0,
        t.uvs.length = 0;
        for (let s = 0; s < i.instructions.length; s++) {
            let n = i.instructions[s];
            if (n.action === "texture")
                dy(n.data, r, t);
            else if (n.action === "fill" || n.action === "stroke") {
                let a = n.action === "stroke"
                  , c = n.data.path.shapePath
                  , l = n.data.style
                  , u = n.data.hole;
                a && u && Fd(u.shapePath, l, !0, r, t),
                u && (c.shapePrimitives[c.shapePrimitives.length - 1].holes = u.shapePath.shapePrimitives),
                Fd(c, l, a, r, t)
            }
        }
    }
    function dy(i, e, t) {
        let r = []
          , s = fo.rectangle
          , n = ly;
        n.x = i.dx,
        n.y = i.dy,
        n.width = i.dw,
        n.height = i.dh;
        let a = i.transform;
        if (!s.build(n, r))
            return;
        let {vertices: c, uvs: l, indices: u} = t
          , d = u.length
          , f = c.length / 2;
        a && C0(r, a),
        s.triangulate(r, c, 2, f, u, d);
        let b = i.image
          , m = b.uvs;
        l.push(m.x0, m.y0, m.x1, m.y1, m.x3, m.y3, m.x2, m.y2);
        let x = et.get(ms);
        x.indexOffset = d,
        x.indexSize = u.length - d,
        x.attributeOffset = f,
        x.attributeSize = c.length / 2 - f,
        x.baseColor = i.style,
        x.alpha = i.alpha,
        x.texture = b,
        x.geometryData = t,
        e.push(x)
    }
    function Fd(i, e, t, r, s) {
        let {vertices: n, uvs: a, indices: c} = s;
        i.shapePrimitives.forEach( ({shape: l, transform: u, holes: d}) => {
            var f;
            let b = []
              , m = fo[l.type];
            if (!m.build(l, b))
                return;
            let x = c.length
              , y = n.length / 2
              , S = "triangle-list";
            if (u && C0(b, u),
            t) {
                let M = (f = l.closePath) != null ? f : !0
                  , j = e;
                j.pixelLine ? (Bx(b, M, n, c),
                S = "line-list") : Gx(b, j, !1, M, n, c)
            } else if (d) {
                let M = []
                  , j = b.slice();
                fy(d).forEach(L => {
                    M.push(j.length / 2),
                    j.push(...L)
                }
                ),
                D0(j, M, n, 2, y, c, x)
            } else
                m.triangulate(b, n, 2, y, c, x);
            let A = a.length / 2
              , E = e.texture;
            if (E !== Z.WHITE) {
                let M = cy(hy, e, l, u);
                Tx(n, 2, y, a, A, 2, n.length / 2 - y, M)
            } else
                Sx(a, A, 2, n.length / 2 - y);
            let O = et.get(ms);
            O.indexOffset = x,
            O.indexSize = c.length - x,
            O.attributeOffset = y,
            O.attributeSize = n.length / 2 - y,
            O.baseColor = e.color,
            O.alpha = e.alpha,
            O.texture = E,
            O.geometryData = s,
            O.topology = S,
            r.push(O)
        }
        )
    }
    function fy(i) {
        let e = [];
        for (let t = 0; t < i.length; t++) {
            let r = i[t].shape
              , s = [];
            fo[r.type].build(r, s) && e.push(s)
        }
        return e
    }
    var el = class {
        constructor() {
            this.batches = [],
            this.geometryData = {
                vertices: [],
                uvs: [],
                indices: []
            }
        }
    }
      , tl = class {
        constructor() {
            this.instructions = new bn
        }
        init(e) {
            this.batcher = new Gh({
                maxTextures: e
            }),
            this.instructions.reset()
        }
        get geometry() {
            return this.batcher.geometry
        }
        destroy() {
            this.batcher.destroy(),
            this.instructions.destroy(),
            this.batcher = null,
            this.instructions = null
        }
    }
      , il = class rl {
        constructor(e) {
            this._gpuContextHash = {},
            this._graphicsDataContextHash = Object.create(null),
            this._renderer = e,
            e.renderableGC.addManagedHash(this, "_gpuContextHash"),
            e.renderableGC.addManagedHash(this, "_graphicsDataContextHash")
        }
        init(e) {
            var t;
            rl.defaultOptions.bezierSmoothness = (t = e?.bezierSmoothness) != null ? t : rl.defaultOptions.bezierSmoothness
        }
        getContextRenderData(e) {
            return this._graphicsDataContextHash[e.uid] || this._initContextRenderData(e)
        }
        updateGpuContext(e) {
            let t = this._gpuContextHash[e.uid] || this._initContext(e);
            if (e.dirty) {
                t ? this._cleanGraphicsContextData(e) : t = this._initContext(e),
                uy(e, t);
                let r = e.batchMode;
                e.customShader || r === "no-batch" ? t.isBatchable = !1 : r === "auto" ? t.isBatchable = t.geometryData.vertices.length < 400 : t.isBatchable = !0,
                e.dirty = !1
            }
            return t
        }
        getGpuContext(e) {
            return this._gpuContextHash[e.uid] || this._initContext(e)
        }
        _initContextRenderData(e) {
            let t = et.get(tl, {
                maxTextures: this._renderer.limits.maxBatchableTextures
            })
              , {batches: r, geometryData: s} = this._gpuContextHash[e.uid]
              , n = s.vertices.length
              , a = s.indices.length;
            for (let d = 0; d < r.length; d++)
                r[d].applyTransform = !1;
            let c = t.batcher;
            c.ensureAttributeBuffer(n),
            c.ensureIndexBuffer(a),
            c.begin();
            for (let d = 0; d < r.length; d++) {
                let f = r[d];
                c.add(f)
            }
            c.finish(t.instructions);
            let l = c.geometry;
            l.indexBuffer.setDataWithSize(c.indexBuffer, c.indexSize, !0),
            l.buffers[0].setDataWithSize(c.attributeBuffer.float32View, c.attributeSize, !0);
            let u = c.batches;
            for (let d = 0; d < u.length; d++) {
                let f = u[d];
                f.bindGroup = Ph(f.textures.textures, f.textures.count, this._renderer.limits.maxBatchableTextures)
            }
            return this._graphicsDataContextHash[e.uid] = t,
            t
        }
        _initContext(e) {
            let t = new el;
            return t.context = e,
            this._gpuContextHash[e.uid] = t,
            e.on("destroy", this.onGraphicsContextDestroy, this),
            this._gpuContextHash[e.uid]
        }
        onGraphicsContextDestroy(e) {
            this._cleanGraphicsContextData(e),
            e.off("destroy", this.onGraphicsContextDestroy, this),
            this._gpuContextHash[e.uid] = null
        }
        _cleanGraphicsContextData(e) {
            let t = this._gpuContextHash[e.uid];
            t.isBatchable || this._graphicsDataContextHash[e.uid] && (et.return(this.getContextRenderData(e)),
            this._graphicsDataContextHash[e.uid] = null),
            t.batches && t.batches.forEach(r => {
                et.return(r)
            }
            )
        }
        destroy() {
            for (let e in this._gpuContextHash)
                this._gpuContextHash[e] && this.onGraphicsContextDestroy(this._gpuContextHash[e].context)
        }
    }
    ;
    il.extension = {
        type: [B.WebGLSystem, B.WebGPUSystem, B.CanvasSystem],
        name: "graphicsContext"
    },
    il.defaultOptions = {
        bezierSmoothness: .5
    };
    var Bh = il
      , py = {
        normal: 0,
        add: 1,
        multiply: 2,
        screen: 3,
        overlay: 4,
        erase: 5,
        "normal-npm": 6,
        "add-npm": 7,
        "screen-npm": 8,
        min: 9,
        max: 10
    }
      , zo = 0
      , Vo = 1
      , Wo = 2
      , Yo = 3
      , $o = 4
      , Ko = 5
      , sl = class k0 {
        constructor() {
            this.data = 0,
            this.blendMode = "normal",
            this.polygonOffset = 0,
            this.blend = !0,
            this.depthMask = !0
        }
        get blend() {
            return !!(this.data & 1 << zo)
        }
        set blend(e) {
            !!(this.data & 1 << zo) !== e && (this.data ^= 1 << zo)
        }
        get offsets() {
            return !!(this.data & 1 << Vo)
        }
        set offsets(e) {
            !!(this.data & 1 << Vo) !== e && (this.data ^= 1 << Vo)
        }
        set cullMode(e) {
            if (e === "none") {
                this.culling = !1;
                return
            }
            this.culling = !0,
            this.clockwiseFrontFace = e === "front"
        }
        get cullMode() {
            return this.culling ? this.clockwiseFrontFace ? "front" : "back" : "none"
        }
        get culling() {
            return !!(this.data & 1 << Wo)
        }
        set culling(e) {
            !!(this.data & 1 << Wo) !== e && (this.data ^= 1 << Wo)
        }
        get depthTest() {
            return !!(this.data & 1 << Yo)
        }
        set depthTest(e) {
            !!(this.data & 1 << Yo) !== e && (this.data ^= 1 << Yo)
        }
        get depthMask() {
            return !!(this.data & 1 << Ko)
        }
        set depthMask(e) {
            !!(this.data & 1 << Ko) !== e && (this.data ^= 1 << Ko)
        }
        get clockwiseFrontFace() {
            return !!(this.data & 1 << $o)
        }
        set clockwiseFrontFace(e) {
            !!(this.data & 1 << $o) !== e && (this.data ^= 1 << $o)
        }
        get blendMode() {
            return this._blendMode
        }
        set blendMode(e) {
            this.blend = e !== "none",
            this._blendMode = e,
            this._blendModeId = py[e] || 0
        }
        get polygonOffset() {
            return this._polygonOffset
        }
        set polygonOffset(e) {
            this.offsets = !!e,
            this._polygonOffset = e
        }
        static for2d() {
            let e = new k0;
            return e.depthTest = !1,
            e.blend = !0,
            e
        }
    }
    ;
    sl.default2d = sl.for2d();
    var Nt = sl;
    function Os(i, e, t) {
        let r = (i >> 24 & 255) / 255;
        e[t++] = (i & 255) / 255 * r,
        e[t++] = (i >> 8 & 255) / 255 * r,
        e[t++] = (i >> 16 & 255) / 255 * r,
        e[t++] = r
    }
    var nl = class {
        constructor() {
            this.batches = [],
            this.batched = !1
        }
        destroy() {
            this.batches.forEach(e => {
                et.return(e)
            }
            ),
            this.batches.length = 0
        }
    }
      , In = class {
        constructor(e, t) {
            this.state = Nt.for2d(),
            this.renderer = e,
            this._adaptor = t,
            this.renderer.runners.contextChange.add(this)
        }
        contextChange() {
            this._adaptor.contextChange(this.renderer)
        }
        validateRenderable(e) {
            let t = e.context
              , r = !!e._gpuData
              , s = this.renderer.graphicsContext.updateGpuContext(t);
            return !!(s.isBatchable || r !== s.isBatchable)
        }
        addRenderable(e, t) {
            let r = this.renderer.graphicsContext.updateGpuContext(e.context);
            e.didViewUpdate && this._rebuild(e),
            r.isBatchable ? this._addToBatcher(e, t) : (this.renderer.renderPipes.batch.break(t),
            t.add(e))
        }
        updateRenderable(e) {
            let t = this._getGpuDataForRenderable(e).batches;
            for (let r = 0; r < t.length; r++) {
                let s = t[r];
                s._batcher.updateElement(s)
            }
        }
        execute(e) {
            if (!e.isRenderable)
                return;
            let t = this.renderer
              , r = e.context;
            if (!t.graphicsContext.getGpuContext(r).batches.length)
                return;
            let s = r.customShader || this._adaptor.shader;
            this.state.blendMode = e.groupBlendMode;
            let n = s.resources.localUniforms.uniforms;
            n.uTransformMatrix = e.groupTransform,
            n.uRound = t._roundPixels | e._roundPixels,
            Os(e.groupColorAlpha, n.uColor, 0),
            this._adaptor.execute(this, e)
        }
        _rebuild(e) {
            let t = this._getGpuDataForRenderable(e)
              , r = this.renderer.graphicsContext.updateGpuContext(e.context);
            t.destroy(),
            r.isBatchable && this._updateBatchesForRenderable(e, t)
        }
        _addToBatcher(e, t) {
            let r = this.renderer.renderPipes.batch
              , s = this._getGpuDataForRenderable(e).batches;
            for (let n = 0; n < s.length; n++) {
                let a = s[n];
                r.addToBatch(a, t)
            }
        }
        _getGpuDataForRenderable(e) {
            return e._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(e)
        }
        _initGpuDataForRenderable(e) {
            let t = new nl;
            return e._gpuData[this.renderer.uid] = t,
            t
        }
        _updateBatchesForRenderable(e, t) {
            let r = e.context
              , s = this.renderer.graphicsContext.getGpuContext(r)
              , n = this.renderer._roundPixels | e._roundPixels;
            t.batches = s.batches.map(a => {
                let c = et.get(ms);
                return a.copyTo(c),
                c.renderable = e,
                c.roundPixels = n,
                c
            }
            )
        }
        destroy() {
            this.renderer = null,
            this._adaptor.destroy(),
            this._adaptor = null,
            this.state = null
        }
    }
    ;
    In.extension = {
        type: [B.WebGLPipes, B.WebGPUPipes, B.CanvasPipes],
        name: "graphics"
    },
    be.add(In),
    be.add(Bh);
    var vs = class {
        constructor() {
            this.batcherName = "default",
            this.packAsQuad = !1,
            this.indexOffset = 0,
            this.attributeOffset = 0,
            this.roundPixels = 0,
            this._batcher = null,
            this._batch = null,
            this._textureMatrixUpdateId = -1,
            this._uvUpdateId = -1
        }
        get blendMode() {
            return this.renderable.groupBlendMode
        }
        get topology() {
            return this._topology || this.geometry.topology
        }
        set topology(e) {
            this._topology = e
        }
        reset() {
            this.renderable = null,
            this.texture = null,
            this._batcher = null,
            this._batch = null,
            this.geometry = null,
            this._uvUpdateId = -1,
            this._textureMatrixUpdateId = -1
        }
        setTexture(e) {
            this.texture !== e && (this.texture = e,
            this._textureMatrixUpdateId = -1)
        }
        get uvs() {
            let e = this.geometry.getBuffer("aUV")
              , t = e.data
              , r = t
              , s = this.texture.textureMatrix;
            return s.isSimple || (r = this._transformedUvs,
            (this._textureMatrixUpdateId !== s._updateID || this._uvUpdateId !== e._updateID) && ((!r || r.length < t.length) && (r = this._transformedUvs = new Float32Array(t.length)),
            this._textureMatrixUpdateId = s._updateID,
            this._uvUpdateId = e._updateID,
            s.multiplyUvs(t, r))),
            r
        }
        get positions() {
            return this.geometry.positions
        }
        get indices() {
            return this.geometry.indices
        }
        get color() {
            return this.renderable.groupColorAlpha
        }
        get groupTransform() {
            return this.renderable.groupTransform
        }
        get attributeSize() {
            return this.geometry.positions.length / 2
        }
        get indexSize() {
            return this.geometry.indices.length
        }
    }
      , Gn = class {
        destroy() {}
    }
      , Bn = class {
        constructor(e, t) {
            this.localUniforms = new ct({
                uTransformMatrix: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uColor: {
                    value: new Float32Array([1, 1, 1, 1]),
                    type: "vec4<f32>"
                },
                uRound: {
                    value: 0,
                    type: "f32"
                }
            }),
            this.localUniformsBindGroup = new Qt({
                0: this.localUniforms
            }),
            this.renderer = e,
            this._adaptor = t,
            this._adaptor.init()
        }
        validateRenderable(e) {
            let t = this._getMeshData(e)
              , r = t.batched
              , s = e.batched;
            if (t.batched = s,
            r !== s)
                return !0;
            if (s) {
                let n = e._geometry;
                if (n.indices.length !== t.indexSize || n.positions.length !== t.vertexSize)
                    return t.indexSize = n.indices.length,
                    t.vertexSize = n.positions.length,
                    !0;
                let a = this._getBatchableMesh(e);
                return a.texture.uid !== e._texture.uid && (a._textureMatrixUpdateId = -1),
                !a._batcher.checkAndUpdateTexture(a, e._texture)
            }
            return !1
        }
        addRenderable(e, t) {
            var r, s;
            let n = this.renderer.renderPipes.batch
              , a = this._getMeshData(e);
            if (e.didViewUpdate && (a.indexSize = (r = e._geometry.indices) == null ? void 0 : r.length,
            a.vertexSize = (s = e._geometry.positions) == null ? void 0 : s.length),
            a.batched) {
                let c = this._getBatchableMesh(e);
                c.setTexture(e._texture),
                c.geometry = e._geometry,
                n.addToBatch(c, t)
            } else
                n.break(t),
                t.add(e)
        }
        updateRenderable(e) {
            if (e.batched) {
                let t = this._getBatchableMesh(e);
                t.setTexture(e._texture),
                t.geometry = e._geometry,
                t._batcher.updateElement(t)
            }
        }
        execute(e) {
            if (!e.isRenderable)
                return;
            e.state.blendMode = ps(e.groupBlendMode, e.texture._source);
            let t = this.localUniforms;
            t.uniforms.uTransformMatrix = e.groupTransform,
            t.uniforms.uRound = this.renderer._roundPixels | e._roundPixels,
            t.update(),
            Os(e.groupColorAlpha, t.uniforms.uColor, 0),
            this._adaptor.execute(this, e)
        }
        _getMeshData(e) {
            var t, r;
            return (t = e._gpuData)[r = this.renderer.uid] || (t[r] = new Gn),
            e._gpuData[this.renderer.uid].meshData || this._initMeshData(e)
        }
        _initMeshData(e) {
            return e._gpuData[this.renderer.uid].meshData = {
                batched: e.batched,
                indexSize: 0,
                vertexSize: 0
            },
            e._gpuData[this.renderer.uid].meshData
        }
        _getBatchableMesh(e) {
            var t, r;
            return (t = e._gpuData)[r = this.renderer.uid] || (t[r] = new Gn),
            e._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(e)
        }
        _initBatchableMesh(e) {
            let t = new vs;
            return t.renderable = e,
            t.setTexture(e._texture),
            t.transform = e.groupTransform,
            t.roundPixels = this.renderer._roundPixels | e._roundPixels,
            e._gpuData[this.renderer.uid].batchableMesh = t,
            t
        }
        destroy() {
            this.localUniforms = null,
            this.localUniformsBindGroup = null,
            this._adaptor.destroy(),
            this._adaptor = null,
            this.renderer = null
        }
    }
    ;
    Bn.extension = {
        type: [B.WebGLPipes, B.WebGPUPipes, B.CanvasPipes],
        name: "mesh"
    },
    be.add(Bn);
    var al = class {
        execute(e, t) {
            let r = e.state
              , s = e.renderer
              , n = t.shader || e.defaultShader;
            n.resources.uTexture = t.texture._source,
            n.resources.uniforms = e.localUniforms;
            let a = s.gl
              , c = e.getBuffers(t);
            s.shader.bind(n),
            s.state.set(r),
            s.geometry.bind(c.geometry, n.glProgram);
            let l = c.geometry.indexBuffer.data.BYTES_PER_ELEMENT === 2 ? a.UNSIGNED_SHORT : a.UNSIGNED_INT;
            a.drawElements(a.TRIANGLES, t.particleChildren.length * 6, l, 0)
        }
    }
    ;
    function Dd(i, e=null) {
        let t = i * 6;
        if (t > 65535 ? e || (e = new Uint32Array(t)) : e || (e = new Uint16Array(t)),
        e.length !== t)
            throw new Error(`Out buffer length is incorrect, got ${e.length} and expected ${t}`);
        for (let r = 0, s = 0; r < t; r += 6,
        s += 4)
            e[r + 0] = s + 0,
            e[r + 1] = s + 1,
            e[r + 2] = s + 2,
            e[r + 3] = s + 0,
            e[r + 4] = s + 2,
            e[r + 5] = s + 3;
        return e
    }
    function by(i) {
        return {
            dynamicUpdate: kd(i, !0),
            staticUpdate: kd(i, !1)
        }
    }
    function kd(i, e) {
        let t = [];
        t.push(`

        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);
        let r = 0;
        for (let n in i) {
            let a = i[n];
            if (e !== a.dynamic)
                continue;
            t.push(`offset = index + ${r}`),
            t.push(a.code);
            let c = Gi(a.format);
            r += c.stride / 4
        }
        t.push(`
            index += stride * 4;
        }
    `),
        t.unshift(`
        var stride = ${r};
    `);
        let s = t.join(`
`);
        return new Function("ps","f32v","u32v",s)
    }
    var ol = class {
        constructor(e) {
            this._size = 0,
            this._generateParticleUpdateCache = {};
            var t;
            let r = this._size = (t = e.size) != null ? t : 1e3
              , s = e.properties
              , n = 0
              , a = 0;
            for (let f in s) {
                let b = s[f]
                  , m = Gi(b.format);
                b.dynamic ? a += m.stride : n += m.stride
            }
            this._dynamicStride = a / 4,
            this._staticStride = n / 4,
            this.staticAttributeBuffer = new Oi(r * 4 * n),
            this.dynamicAttributeBuffer = new Oi(r * 4 * a),
            this.indexBuffer = Dd(r);
            let c = new oi
              , l = 0
              , u = 0;
            this._staticBuffer = new gt({
                data: new Float32Array(1),
                label: "static-particle-buffer",
                shrinkToFit: !1,
                usage: Ae.VERTEX | Ae.COPY_DST
            }),
            this._dynamicBuffer = new gt({
                data: new Float32Array(1),
                label: "dynamic-particle-buffer",
                shrinkToFit: !1,
                usage: Ae.VERTEX | Ae.COPY_DST
            });
            for (let f in s) {
                let b = s[f]
                  , m = Gi(b.format);
                b.dynamic ? (c.addAttribute(b.attributeName, {
                    buffer: this._dynamicBuffer,
                    stride: this._dynamicStride * 4,
                    offset: l * 4,
                    format: b.format
                }),
                l += m.size) : (c.addAttribute(b.attributeName, {
                    buffer: this._staticBuffer,
                    stride: this._staticStride * 4,
                    offset: u * 4,
                    format: b.format
                }),
                u += m.size)
            }
            c.addIndex(this.indexBuffer);
            let d = this.getParticleUpdate(s);
            this._dynamicUpload = d.dynamicUpdate,
            this._staticUpload = d.staticUpdate,
            this.geometry = c
        }
        getParticleUpdate(e) {
            let t = my(e);
            return this._generateParticleUpdateCache[t] ? this._generateParticleUpdateCache[t] : (this._generateParticleUpdateCache[t] = this.generateParticleUpdate(e),
            this._generateParticleUpdateCache[t])
        }
        generateParticleUpdate(e) {
            return by(e)
        }
        update(e, t) {
            e.length > this._size && (t = !0,
            this._size = Math.max(e.length, this._size * 1.5 | 0),
            this.staticAttributeBuffer = new Oi(this._size * this._staticStride * 4 * 4),
            this.dynamicAttributeBuffer = new Oi(this._size * this._dynamicStride * 4 * 4),
            this.indexBuffer = Dd(this._size),
            this.geometry.indexBuffer.setDataWithSize(this.indexBuffer, this.indexBuffer.byteLength, !0));
            let r = this.dynamicAttributeBuffer;
            if (this._dynamicUpload(e, r.float32View, r.uint32View),
            this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View, e.length * this._dynamicStride * 4, !0),
            t) {
                let s = this.staticAttributeBuffer;
                this._staticUpload(e, s.float32View, s.uint32View),
                this._staticBuffer.setDataWithSize(s.float32View, e.length * this._staticStride * 4, !0)
            }
        }
        destroy() {
            this._staticBuffer.destroy(),
            this._dynamicBuffer.destroy(),
            this.geometry.destroy()
        }
    }
    ;
    function my(i) {
        let e = [];
        for (let t in i) {
            let r = i[t];
            e.push(t, r.code, r.dynamic ? "d" : "s")
        }
        return e.join("_")
    }
    var gy = `varying vec2 vUV;
varying vec4 vColor;

uniform sampler2D uTexture;

void main(void){
    vec4 color = texture2D(uTexture, vUV) * vColor;
    gl_FragColor = color;
}`
      , _y = `attribute vec2 aVertex;
attribute vec2 aUV;
attribute vec4 aColor;

attribute vec2 aPosition;
attribute float aRotation;

uniform mat3 uTranslationMatrix;
uniform float uRound;
uniform vec2 uResolution;
uniform vec4 uColor;

varying vec2 vUV;
varying vec4 vColor;

vec2 roundPixels(vec2 position, vec2 targetSize)
{       
    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

void main(void){
    float cosRotation = cos(aRotation);
    float sinRotation = sin(aRotation);
    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;
    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;

    vec2 v = vec2(x, y);
    v = v + aPosition;

    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    if(uRound == 1.0)
    {
        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
    }

    vUV = aUV;
    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;
}
`
      , Ud = `
struct ParticleUniforms {
  uTranslationMatrix:mat3x3<f32>,
  uColor:vec4<f32>,
  uRound:f32,
  uResolution:vec2<f32>,
};

fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
{
  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;

@group(1) @binding(0) var uTexture: texture_2d<f32>;
@group(1) @binding(1) var uSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) color : vec4<f32>,
  };
@vertex
fn mainVertex(
  @location(0) aVertex: vec2<f32>,
  @location(1) aPosition: vec2<f32>,
  @location(2) aUV: vec2<f32>,
  @location(3) aColor: vec4<f32>,
  @location(4) aRotation: f32,
) -> VSOutput {
  
   let v = vec2(
       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),
       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)
   ) + aPosition;

   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

   if(uniforms.uRound == 1.0) {
       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);
   }

    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;

  return VSOutput(
   position,
   aUV,
   vColor,
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) color: vec4<f32>,
  @builtin(position) position: vec4<f32>,
) -> @location(0) vec4<f32> {

    var sample = textureSample(uTexture, uSampler, uv) * color;
   
    return sample;
}`
      , cl = class extends At {
        constructor() {
            let e = wi.from({
                vertex: _y,
                fragment: gy
            })
              , t = ci.from({
                fragment: {
                    source: Ud,
                    entryPoint: "mainFragment"
                },
                vertex: {
                    source: Ud,
                    entryPoint: "mainVertex"
                }
            });
            super({
                glProgram: e,
                gpuProgram: t,
                resources: {
                    uTexture: Z.WHITE.source,
                    uSampler: new Lt({}),
                    uniforms: {
                        uTranslationMatrix: {
                            value: new ce,
                            type: "mat3x3<f32>"
                        },
                        uColor: {
                            value: new Ie(16777215),
                            type: "vec4<f32>"
                        },
                        uRound: {
                            value: 1,
                            type: "f32"
                        },
                        uResolution: {
                            value: [0, 0],
                            type: "vec2<f32>"
                        }
                    }
                }
            })
        }
    }
      , Fn = class {
        constructor(e, t) {
            this.state = Nt.for2d(),
            this.localUniforms = new ct({
                uTranslationMatrix: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uColor: {
                    value: new Float32Array(4),
                    type: "vec4<f32>"
                },
                uRound: {
                    value: 1,
                    type: "f32"
                },
                uResolution: {
                    value: [0, 0],
                    type: "vec2<f32>"
                }
            }),
            this.renderer = e,
            this.adaptor = t,
            this.defaultShader = new cl,
            this.state = Nt.for2d()
        }
        validateRenderable(e) {
            return !1
        }
        addRenderable(e, t) {
            this.renderer.renderPipes.batch.break(t),
            t.add(e)
        }
        getBuffers(e) {
            return e._gpuData[this.renderer.uid] || this._initBuffer(e)
        }
        _initBuffer(e) {
            return e._gpuData[this.renderer.uid] = new ol({
                size: e.particleChildren.length,
                properties: e._properties
            }),
            e._gpuData[this.renderer.uid]
        }
        updateRenderable(e) {}
        execute(e) {
            let t = e.particleChildren;
            if (t.length === 0)
                return;
            let r = this.renderer
              , s = this.getBuffers(e);
            e.texture || (e.texture = t[0].texture);
            let n = this.state;
            s.update(t, e._childrenDirty),
            e._childrenDirty = !1,
            n.blendMode = ps(e.blendMode, e.texture._source);
            let a = this.localUniforms.uniforms
              , c = a.uTranslationMatrix;
            e.worldTransform.copyTo(c),
            c.prepend(r.globalUniforms.globalUniformData.projectionMatrix),
            a.uResolution = r.globalUniforms.globalUniformData.resolution,
            a.uRound = r._roundPixels | e._roundPixels,
            Os(e.groupColorAlpha, a.uColor, 0),
            this.adaptor.execute(this, e)
        }
        destroy() {
            this.renderer = null,
            this.defaultShader && (this.defaultShader.destroy(),
            this.defaultShader = null)
        }
    }
      , Dn = class extends Fn {
        constructor(e) {
            super(e, new al)
        }
    }
    ;
    Dn.extension = {
        type: [B.WebGLPipes],
        name: "particle"
    };
    var ll = class {
        execute(e, t) {
            let r = e.renderer
              , s = t.shader || e.defaultShader;
            s.groups[0] = r.renderPipes.uniformBatch.getUniformBindGroup(e.localUniforms, !0),
            s.groups[1] = r.texture.getTextureBindGroup(t.texture);
            let n = e.state
              , a = e.getBuffers(t);
            r.encoder.draw({
                geometry: a.geometry,
                shader: t.shader || e.defaultShader,
                state: n,
                size: t.particleChildren.length * 6
            })
        }
    }
      , kn = class extends Fn {
        constructor(e) {
            super(e, new ll)
        }
    }
    ;
    kn.extension = {
        type: [B.WebGPUPipes],
        name: "particle"
    },
    be.add(Dn),
    be.add(kn);
    function hl(i, e) {
        let {texture: t, bounds: r} = i
          , s = e._style._getFinalPadding();
        n0(r, e._anchor, t);
        let n = e._anchor._x * s * 2
          , a = e._anchor._y * s * 2;
        r.minX -= s - n,
        r.minY -= s - a,
        r.maxX -= s - n,
        r.maxY -= s - a
    }
    var Pr = class {
        constructor() {
            this.batcherName = "default",
            this.topology = "triangle-list",
            this.attributeSize = 4,
            this.indexSize = 6,
            this.packAsQuad = !0,
            this.roundPixels = 0,
            this._attributeStart = 0,
            this._batcher = null,
            this._batch = null
        }
        get blendMode() {
            return this.renderable.groupBlendMode
        }
        get color() {
            return this.renderable.groupColorAlpha
        }
        reset() {
            this.renderable = null,
            this.texture = null,
            this._batcher = null,
            this._batch = null,
            this.bounds = null
        }
        destroy() {}
    }
      , ul = class extends Pr {
        constructor(e) {
            super(),
            this._renderer = e,
            e.runners.resolutionChange.add(this)
        }
        resolutionChange() {
            let e = this.renderable;
            e._autoResolution && e.onViewUpdate()
        }
        destroy() {
            let {canvasText: e} = this._renderer;
            e.getReferenceCount(this.currentKey) === null ? e.returnTexture(this.texture) : e.decreaseReferenceCount(this.currentKey),
            this._renderer.runners.resolutionChange.remove(this),
            this._renderer = null
        }
    }
      , Un = class {
        constructor(e) {
            this._renderer = e
        }
        validateRenderable(e) {
            let t = this._getGpuText(e)
              , r = e.styleKey;
            return t.currentKey !== r ? !0 : e._didTextUpdate
        }
        addRenderable(e, t) {
            let r = this._getGpuText(e);
            if (e._didTextUpdate) {
                let s = e._autoResolution ? this._renderer.resolution : e.resolution;
                (r.currentKey !== e.styleKey || e.resolution !== s) && this._updateGpuText(e),
                e._didTextUpdate = !1
            }
            this._renderer.renderPipes.batch.addToBatch(r, t)
        }
        updateRenderable(e) {
            let t = this._getGpuText(e);
            t._batcher.updateElement(t)
        }
        _updateGpuText(e) {
            let t = this._getGpuText(e);
            t.texture && this._renderer.canvasText.decreaseReferenceCount(t.currentKey),
            e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution,
            t.texture = this._renderer.canvasText.getManagedTexture(e),
            t.currentKey = e.styleKey,
            hl(t, e)
        }
        _getGpuText(e) {
            return e._gpuData[this._renderer.uid] || this.initGpuText(e)
        }
        initGpuText(e) {
            let t = new ul(this._renderer);
            return t.currentKey = "--",
            t.renderable = e,
            t.transform = e.groupTransform,
            t.bounds = {
                minX: 0,
                maxX: 1,
                minY: 0,
                maxY: 0
            },
            t.roundPixels = this._renderer._roundPixels | e._roundPixels,
            e._gpuData[this._renderer.uid] = t,
            t
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    Un.extension = {
        type: [B.WebGLPipes, B.WebGPUPipes, B.CanvasPipes],
        name: "text"
    };
    var Ld = {
        repeat: {
            addressModeU: "repeat",
            addressModeV: "repeat"
        },
        "repeat-x": {
            addressModeU: "repeat",
            addressModeV: "clamp-to-edge"
        },
        "repeat-y": {
            addressModeU: "clamp-to-edge",
            addressModeV: "repeat"
        },
        "no-repeat": {
            addressModeU: "clamp-to-edge",
            addressModeV: "clamp-to-edge"
        }
    }
      , Rr = class {
        constructor(e, t) {
            this.uid = Xe("fillPattern"),
            this._tick = 0,
            this.transform = new ce,
            this.texture = e,
            this.transform.scale(1 / e.frame.width, 1 / e.frame.height),
            t && (e.source.style.addressModeU = Ld[t].addressModeU,
            e.source.style.addressModeV = Ld[t].addressModeV)
        }
        setTransform(e) {
            let t = this.texture;
            this.transform.copyFrom(e),
            this.transform.invert(),
            this.transform.scale(1 / t.frame.width, 1 / t.frame.height),
            this._tick++
        }
        get texture() {
            return this._texture
        }
        set texture(e) {
            this._texture !== e && (this._texture = e,
            this._tick++)
        }
        get styleKey() {
            return `fill-pattern-${this.uid}-${this._tick}`
        }
        destroy() {
            this.texture.destroy(!0),
            this.texture = null
        }
    }
      , xy = vy
      , qo = {
        a: 7,
        c: 6,
        h: 1,
        l: 2,
        m: 2,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        z: 0
    }
      , yy = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function vy(i) {
        var e = [];
        return i.replace(yy, function(t, r, s) {
            var n = r.toLowerCase();
            for (s = Sy(s),
            n == "m" && s.length > 2 && (e.push([r].concat(s.splice(0, 2))),
            n = "l",
            r = r == "m" ? "l" : "L"); ; ) {
                if (s.length == qo[n])
                    return s.unshift(r),
                    e.push(s);
                if (s.length < qo[n])
                    throw new Error("malformed path data");
                e.push([r].concat(s.splice(0, qo[n])))
            }
        }),
        e
    }
    var Ty = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function Sy(i) {
        var e = i.match(Ty);
        return e ? e.map(Number) : []
    }
    var wy = Lb(xy);
    function Ay(i, e) {
        let t = wy(i)
          , r = []
          , s = null
          , n = 0
          , a = 0;
        for (let c = 0; c < t.length; c++) {
            let l = t[c]
              , u = l[0]
              , d = l;
            switch (u) {
            case "M":
                n = d[1],
                a = d[2],
                e.moveTo(n, a);
                break;
            case "m":
                n += d[1],
                a += d[2],
                e.moveTo(n, a);
                break;
            case "H":
                n = d[1],
                e.lineTo(n, a);
                break;
            case "h":
                n += d[1],
                e.lineTo(n, a);
                break;
            case "V":
                a = d[1],
                e.lineTo(n, a);
                break;
            case "v":
                a += d[1],
                e.lineTo(n, a);
                break;
            case "L":
                n = d[1],
                a = d[2],
                e.lineTo(n, a);
                break;
            case "l":
                n += d[1],
                a += d[2],
                e.lineTo(n, a);
                break;
            case "C":
                n = d[5],
                a = d[6],
                e.bezierCurveTo(d[1], d[2], d[3], d[4], n, a);
                break;
            case "c":
                e.bezierCurveTo(n + d[1], a + d[2], n + d[3], a + d[4], n + d[5], a + d[6]),
                n += d[5],
                a += d[6];
                break;
            case "S":
                n = d[3],
                a = d[4],
                e.bezierCurveToShort(d[1], d[2], n, a);
                break;
            case "s":
                e.bezierCurveToShort(n + d[1], a + d[2], n + d[3], a + d[4]),
                n += d[3],
                a += d[4];
                break;
            case "Q":
                n = d[3],
                a = d[4],
                e.quadraticCurveTo(d[1], d[2], n, a);
                break;
            case "q":
                e.quadraticCurveTo(n + d[1], a + d[2], n + d[3], a + d[4]),
                n += d[3],
                a += d[4];
                break;
            case "T":
                n = d[1],
                a = d[2],
                e.quadraticCurveToShort(n, a);
                break;
            case "t":
                n += d[1],
                a += d[2],
                e.quadraticCurveToShort(n, a);
                break;
            case "A":
                n = d[6],
                a = d[7],
                e.arcToSvg(d[1], d[2], d[3], d[4], d[5], n, a);
                break;
            case "a":
                n += d[6],
                a += d[7],
                e.arcToSvg(d[1], d[2], d[3], d[4], d[5], n, a);
                break;
            case "Z":
            case "z":
                e.closePath(),
                r.length > 0 && (s = r.pop(),
                s ? (n = s.startX,
                a = s.startY) : (n = 0,
                a = 0)),
                s = null;
                break;
            default:
            }
            u !== "Z" && u !== "z" && s === null && (s = {
                startX: n,
                startY: a
            },
            r.push(s))
        }
        return e
    }
    var dl = class i {
        constructor(e=0, t=0, r=0) {
            this.type = "circle",
            this.x = e,
            this.y = t,
            this.radius = r
        }
        clone() {
            return new i(this.x,this.y,this.radius)
        }
        contains(e, t) {
            if (this.radius <= 0)
                return !1;
            let r = this.radius * this.radius
              , s = this.x - e
              , n = this.y - t;
            return s *= s,
            n *= n,
            s + n <= r
        }
        strokeContains(e, t, r, s=.5) {
            if (this.radius === 0)
                return !1;
            let n = this.x - e
              , a = this.y - t
              , c = this.radius
              , l = (1 - s) * r
              , u = Math.sqrt(n * n + a * a);
            return u <= c + l && u > c - (r - l)
        }
        getBounds(e) {
            return e || (e = new Re),
            e.x = this.x - this.radius,
            e.y = this.y - this.radius,
            e.width = this.radius * 2,
            e.height = this.radius * 2,
            e
        }
        copyFrom(e) {
            return this.x = e.x,
            this.y = e.y,
            this.radius = e.radius,
            this
        }
        copyTo(e) {
            return e.copyFrom(this),
            e
        }
    }
      , fl = class i {
        constructor(e=0, t=0, r=0, s=0) {
            this.type = "ellipse",
            this.x = e,
            this.y = t,
            this.halfWidth = r,
            this.halfHeight = s
        }
        clone() {
            return new i(this.x,this.y,this.halfWidth,this.halfHeight)
        }
        contains(e, t) {
            if (this.halfWidth <= 0 || this.halfHeight <= 0)
                return !1;
            let r = (e - this.x) / this.halfWidth
              , s = (t - this.y) / this.halfHeight;
            return r *= r,
            s *= s,
            r + s <= 1
        }
        strokeContains(e, t, r, s=.5) {
            let {halfWidth: n, halfHeight: a} = this;
            if (n <= 0 || a <= 0)
                return !1;
            let c = r * (1 - s)
              , l = r - c
              , u = n - l
              , d = a - l
              , f = n + c
              , b = a + c
              , m = e - this.x
              , x = t - this.y
              , y = m * m / (u * u) + x * x / (d * d)
              , S = m * m / (f * f) + x * x / (b * b);
            return y > 1 && S <= 1
        }
        getBounds(e) {
            return e || (e = new Re),
            e.x = this.x - this.halfWidth,
            e.y = this.y - this.halfHeight,
            e.width = this.halfWidth * 2,
            e.height = this.halfHeight * 2,
            e
        }
        copyFrom(e) {
            return this.x = e.x,
            this.y = e.y,
            this.halfWidth = e.halfWidth,
            this.halfHeight = e.halfHeight,
            this
        }
        copyTo(e) {
            return e.copyFrom(this),
            e
        }
    }
    ;
    function Ey(i, e, t, r, s, n) {
        let a = i - t
          , c = e - r
          , l = s - t
          , u = n - r
          , d = a * l + c * u
          , f = l * l + u * u
          , b = -1;
        f !== 0 && (b = d / f);
        let m, x;
        b < 0 ? (m = t,
        x = r) : b > 1 ? (m = s,
        x = n) : (m = t + b * l,
        x = r + b * u);
        let y = i - m
          , S = e - x;
        return y * y + S * S
    }
    var Py, Ry, as = class i {
        constructor(...e) {
            this.type = "polygon";
            let t = Array.isArray(e[0]) ? e[0] : e;
            if (typeof t[0] != "number") {
                let r = [];
                for (let s = 0, n = t.length; s < n; s++)
                    r.push(t[s].x, t[s].y);
                t = r
            }
            this.points = t,
            this.closePath = !0
        }
        isClockwise() {
            let e = 0
              , t = this.points
              , r = t.length;
            for (let s = 0; s < r; s += 2) {
                let n = t[s]
                  , a = t[s + 1]
                  , c = t[(s + 2) % r]
                  , l = t[(s + 3) % r];
                e += (c - n) * (l + a)
            }
            return e < 0
        }
        containsPolygon(e) {
            let t = this.getBounds(Py)
              , r = e.getBounds(Ry);
            if (!t.containsRect(r))
                return !1;
            let s = e.points;
            for (let n = 0; n < s.length; n += 2) {
                let a = s[n]
                  , c = s[n + 1];
                if (!this.contains(a, c))
                    return !1
            }
            return !0
        }
        clone() {
            let e = this.points.slice()
              , t = new i(e);
            return t.closePath = this.closePath,
            t
        }
        contains(e, t) {
            let r = !1
              , s = this.points.length / 2;
            for (let n = 0, a = s - 1; n < s; a = n++) {
                let c = this.points[n * 2]
                  , l = this.points[n * 2 + 1]
                  , u = this.points[a * 2]
                  , d = this.points[a * 2 + 1];
                l > t != d > t && e < (u - c) * ((t - l) / (d - l)) + c && (r = !r)
            }
            return r
        }
        strokeContains(e, t, r, s=.5) {
            let n = r * r
              , a = n * (1 - s)
              , c = n - a
              , {points: l} = this
              , u = l.length - (this.closePath ? 0 : 2);
            for (let d = 0; d < u; d += 2) {
                let f = l[d]
                  , b = l[d + 1]
                  , m = l[(d + 2) % l.length]
                  , x = l[(d + 3) % l.length]
                  , y = Ey(e, t, f, b, m, x)
                  , S = Math.sign((m - f) * (t - b) - (x - b) * (e - f));
                if (y <= (S < 0 ? c : a))
                    return !0
            }
            return !1
        }
        getBounds(e) {
            e || (e = new Re);
            let t = this.points
              , r = 1 / 0
              , s = -1 / 0
              , n = 1 / 0
              , a = -1 / 0;
            for (let c = 0, l = t.length; c < l; c += 2) {
                let u = t[c]
                  , d = t[c + 1];
                r = u < r ? u : r,
                s = u > s ? u : s,
                n = d < n ? d : n,
                a = d > a ? d : a
            }
            return e.x = r,
            e.width = s - r,
            e.y = n,
            e.height = a - n,
            e
        }
        copyFrom(e) {
            return this.points = e.points.slice(),
            this.closePath = e.closePath,
            this
        }
        copyTo(e) {
            return e.copyFrom(this),
            e
        }
        get lastX() {
            return this.points[this.points.length - 2]
        }
        get lastY() {
            return this.points[this.points.length - 1]
        }
        get x() {
            return this.points[this.points.length - 2]
        }
        get y() {
            return this.points[this.points.length - 1]
        }
        get startX() {
            return this.points[0]
        }
        get startY() {
            return this.points[1]
        }
    }
    , Ws = (i, e, t, r, s, n, a) => {
        let c = i - t
          , l = e - r
          , u = Math.sqrt(c * c + l * l);
        return u >= s - n && u <= s + a
    }
    , pl = class i {
        constructor(e=0, t=0, r=0, s=0, n=20) {
            this.type = "roundedRectangle",
            this.x = e,
            this.y = t,
            this.width = r,
            this.height = s,
            this.radius = n
        }
        getBounds(e) {
            return e || (e = new Re),
            e.x = this.x,
            e.y = this.y,
            e.width = this.width,
            e.height = this.height,
            e
        }
        clone() {
            return new i(this.x,this.y,this.width,this.height,this.radius)
        }
        copyFrom(e) {
            return this.x = e.x,
            this.y = e.y,
            this.width = e.width,
            this.height = e.height,
            this
        }
        copyTo(e) {
            return e.copyFrom(this),
            e
        }
        contains(e, t) {
            if (this.width <= 0 || this.height <= 0)
                return !1;
            if (e >= this.x && e <= this.x + this.width && t >= this.y && t <= this.y + this.height) {
                let r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
                if (t >= this.y + r && t <= this.y + this.height - r || e >= this.x + r && e <= this.x + this.width - r)
                    return !0;
                let s = e - (this.x + r)
                  , n = t - (this.y + r)
                  , a = r * r;
                if (s * s + n * n <= a || (s = e - (this.x + this.width - r),
                s * s + n * n <= a) || (n = t - (this.y + this.height - r),
                s * s + n * n <= a) || (s = e - (this.x + r),
                s * s + n * n <= a))
                    return !0
            }
            return !1
        }
        strokeContains(e, t, r, s=.5) {
            let {x: n, y: a, width: c, height: l, radius: u} = this
              , d = r * (1 - s)
              , f = r - d
              , b = n + u
              , m = a + u
              , x = c - u * 2
              , y = l - u * 2
              , S = n + c
              , A = a + l;
            return (e >= n - d && e <= n + f || e >= S - f && e <= S + d) && t >= m && t <= m + y || (t >= a - d && t <= a + f || t >= A - f && t <= A + d) && e >= b && e <= b + x ? !0 : e < b && t < m && Ws(e, t, b, m, u, f, d) || e > S - u && t < m && Ws(e, t, S - u, m, u, f, d) || e > S - u && t > A - u && Ws(e, t, S - u, A - u, u, f, d) || e < b && t > A - u && Ws(e, t, b, A - u, u, f, d)
        }
    }
    , My = 8, Ys = 11920929e-14, Cy = 1, Zo = .01, hr = 0, Hi = 0;
    function U0(i, e, t, r, s, n, a, c, l, u) {
        let d = Math.min(.99, Math.max(0, u ?? Bh.defaultOptions.bezierSmoothness))
          , f = (Cy - d) / 1;
        return f *= f,
        Oy(e, t, r, s, n, a, c, l, i, f),
        i
    }
    function Oy(i, e, t, r, s, n, a, c, l, u) {
        bl(i, e, t, r, s, n, a, c, l, u, 0),
        l.push(a, c)
    }
    function bl(i, e, t, r, s, n, a, c, l, u, d) {
        if (d > My)
            return;
        let f = Math.PI
          , b = (i + t) / 2
          , m = (e + r) / 2
          , x = (t + s) / 2
          , y = (r + n) / 2
          , S = (s + a) / 2
          , A = (n + c) / 2
          , E = (b + x) / 2
          , O = (m + y) / 2
          , M = (x + S) / 2
          , j = (y + A) / 2
          , L = (E + M) / 2
          , N = (O + j) / 2;
        if (d > 0) {
            let Y = a - i, ie = c - e, $ = Math.abs((t - a) * ie - (r - c) * Y), J = Math.abs((s - a) * ie - (n - c) * Y), re, Q;
            if ($ > Ys && J > Ys) {
                if (($ + J) * ($ + J) <= u * (Y * Y + ie * ie)) {
                    if (hr < Zo) {
                        l.push(L, N);
                        return
                    }
                    let pe = Math.atan2(n - r, s - t);
                    if (re = Math.abs(pe - Math.atan2(r - e, t - i)),
                    Q = Math.abs(Math.atan2(c - n, a - s) - pe),
                    re >= f && (re = 2 * f - re),
                    Q >= f && (Q = 2 * f - Q),
                    re + Q < hr) {
                        l.push(L, N);
                        return
                    }
                    if (Hi !== 0) {
                        if (re > Hi) {
                            l.push(t, r);
                            return
                        }
                        if (Q > Hi) {
                            l.push(s, n);
                            return
                        }
                    }
                }
            } else if ($ > Ys) {
                if ($ * $ <= u * (Y * Y + ie * ie)) {
                    if (hr < Zo) {
                        l.push(L, N);
                        return
                    }
                    if (re = Math.abs(Math.atan2(n - r, s - t) - Math.atan2(r - e, t - i)),
                    re >= f && (re = 2 * f - re),
                    re < hr) {
                        l.push(t, r),
                        l.push(s, n);
                        return
                    }
                    if (Hi !== 0 && re > Hi) {
                        l.push(t, r);
                        return
                    }
                }
            } else if (J > Ys) {
                if (J * J <= u * (Y * Y + ie * ie)) {
                    if (hr < Zo) {
                        l.push(L, N);
                        return
                    }
                    if (re = Math.abs(Math.atan2(c - n, a - s) - Math.atan2(n - r, s - t)),
                    re >= f && (re = 2 * f - re),
                    re < hr) {
                        l.push(t, r),
                        l.push(s, n);
                        return
                    }
                    if (Hi !== 0 && re > Hi) {
                        l.push(s, n);
                        return
                    }
                }
            } else if (Y = L - (i + a) / 2,
            ie = N - (e + c) / 2,
            Y * Y + ie * ie <= u) {
                l.push(L, N);
                return
            }
        }
        bl(i, e, b, m, E, O, L, N, l, u, d + 1),
        bl(L, N, M, j, S, A, a, c, l, u, d + 1)
    }
    var Iy = 8
      , Gy = 11920929e-14
      , By = 1
      , Fy = .01
      , Nd = 0;
    function Dy(i, e, t, r, s, n, a, c) {
        let l = Math.min(.99, Math.max(0, c ?? Bh.defaultOptions.bezierSmoothness))
          , u = (By - l) / 1;
        return u *= u,
        ky(e, t, r, s, n, a, i, u),
        i
    }
    function ky(i, e, t, r, s, n, a, c) {
        ml(a, i, e, t, r, s, n, c, 0),
        a.push(s, n)
    }
    function ml(i, e, t, r, s, n, a, c, l) {
        if (l > Iy)
            return;
        let u = Math.PI
          , d = (e + r) / 2
          , f = (t + s) / 2
          , b = (r + n) / 2
          , m = (s + a) / 2
          , x = (d + b) / 2
          , y = (f + m) / 2
          , S = n - e
          , A = a - t
          , E = Math.abs((r - n) * A - (s - a) * S);
        if (E > Gy) {
            if (E * E <= c * (S * S + A * A)) {
                if (Nd < Fy) {
                    i.push(x, y);
                    return
                }
                let O = Math.abs(Math.atan2(a - s, n - r) - Math.atan2(s - t, r - e));
                if (O >= u && (O = 2 * u - O),
                O < Nd) {
                    i.push(x, y);
                    return
                }
            }
        } else if (S = x - (e + n) / 2,
        A = y - (t + a) / 2,
        S * S + A * A <= c) {
            i.push(x, y);
            return
        }
        ml(i, e, t, d, f, x, y, c, l + 1),
        ml(i, x, y, b, m, n, a, c, l + 1)
    }
    function L0(i, e, t, r, s, n, a, c) {
        let l = Math.abs(s - n);
        (!a && s > n || a && n > s) && (l = 2 * Math.PI - l),
        c || (c = Math.max(6, Math.floor(6 * Math.pow(r, 1 / 3) * (l / Math.PI)))),
        c = Math.max(c, 3);
        let u = l / c
          , d = s;
        u *= a ? -1 : 1;
        for (let f = 0; f < c + 1; f++) {
            let b = Math.cos(d)
              , m = Math.sin(d)
              , x = e + b * r
              , y = t + m * r;
            i.push(x, y),
            d += u
        }
    }
    function Uy(i, e, t, r, s, n) {
        let a = i[i.length - 2]
          , c = i[i.length - 1] - t
          , l = a - e
          , u = s - t
          , d = r - e
          , f = Math.abs(c * d - l * u);
        if (f < 1e-8 || n === 0) {
            (i[i.length - 2] !== e || i[i.length - 1] !== t) && i.push(e, t);
            return
        }
        let b = c * c + l * l
          , m = u * u + d * d
          , x = c * u + l * d
          , y = n * Math.sqrt(b) / f
          , S = n * Math.sqrt(m) / f
          , A = y * x / b
          , E = S * x / m
          , O = y * d + S * l
          , M = y * u + S * c
          , j = l * (S + A)
          , L = c * (S + A)
          , N = d * (y + E)
          , Y = u * (y + E)
          , ie = Math.atan2(L - M, j - O)
          , $ = Math.atan2(Y - M, N - O);
        L0(i, O + e, M + t, n, ie, $, l * u > d * c)
    }
    var os = Math.PI * 2
      , Qo = {
        centerX: 0,
        centerY: 0,
        ang1: 0,
        ang2: 0
    }
      , Jo = ({x: i, y: e}, t, r, s, n, a, c, l) => {
        i *= t,
        e *= r;
        let u = s * i - n * e
          , d = n * i + s * e;
        return l.x = u + a,
        l.y = d + c,
        l
    }
    ;
    function Ly(i, e) {
        let t = e === -1.5707963267948966 ? -.551915024494 : 1.3333333333333333 * Math.tan(e / 4)
          , r = e === 1.5707963267948966 ? .551915024494 : t
          , s = Math.cos(i)
          , n = Math.sin(i)
          , a = Math.cos(i + e)
          , c = Math.sin(i + e);
        return [{
            x: s - n * r,
            y: n + s * r
        }, {
            x: a + c * r,
            y: c - a * r
        }, {
            x: a,
            y: c
        }]
    }
    var Xd = (i, e, t, r) => {
        let s = i * r - e * t < 0 ? -1 : 1
          , n = i * t + e * r;
        return n > 1 && (n = 1),
        n < -1 && (n = -1),
        s * Math.acos(n)
    }
      , Ny = (i, e, t, r, s, n, a, c, l, u, d, f, b) => {
        let m = Math.pow(s, 2)
          , x = Math.pow(n, 2)
          , y = Math.pow(d, 2)
          , S = Math.pow(f, 2)
          , A = m * x - m * S - x * y;
        A < 0 && (A = 0),
        A /= m * S + x * y,
        A = Math.sqrt(A) * (a === c ? -1 : 1);
        let E = A * s / n * f
          , O = A * -n / s * d
          , M = u * E - l * O + (i + t) / 2
          , j = l * E + u * O + (e + r) / 2
          , L = (d - E) / s
          , N = (f - O) / n
          , Y = (-d - E) / s
          , ie = (-f - O) / n
          , $ = Xd(1, 0, L, N)
          , J = Xd(L, N, Y, ie);
        c === 0 && J > 0 && (J -= os),
        c === 1 && J < 0 && (J += os),
        b.centerX = M,
        b.centerY = j,
        b.ang1 = $,
        b.ang2 = J
    }
    ;
    function Xy(i, e, t, r, s, n, a, c=0, l=0, u=0) {
        if (n === 0 || a === 0)
            return;
        let d = Math.sin(c * os / 360)
          , f = Math.cos(c * os / 360)
          , b = f * (e - r) / 2 + d * (t - s) / 2
          , m = -d * (e - r) / 2 + f * (t - s) / 2;
        if (b === 0 && m === 0)
            return;
        n = Math.abs(n),
        a = Math.abs(a);
        let x = Math.pow(b, 2) / Math.pow(n, 2) + Math.pow(m, 2) / Math.pow(a, 2);
        x > 1 && (n *= Math.sqrt(x),
        a *= Math.sqrt(x)),
        Ny(e, t, r, s, n, a, l, u, d, f, b, m, Qo);
        let {ang1: y, ang2: S} = Qo
          , {centerX: A, centerY: E} = Qo
          , O = Math.abs(S) / (os / 4);
        Math.abs(1 - O) < 1e-7 && (O = 1);
        let M = Math.max(Math.ceil(O), 1);
        S /= M;
        let j = i[i.length - 2]
          , L = i[i.length - 1]
          , N = {
            x: 0,
            y: 0
        };
        for (let Y = 0; Y < M; Y++) {
            let ie = Ly(y, S)
              , {x: $, y: J} = Jo(ie[0], n, a, f, d, A, E, N)
              , {x: re, y: Q} = Jo(ie[1], n, a, f, d, A, E, N)
              , {x: pe, y: Be} = Jo(ie[2], n, a, f, d, A, E, N);
            U0(i, j, L, $, J, re, Q, pe, Be),
            j = pe,
            L = Be,
            y += S
        }
    }
    function jy(i, e, t) {
        var r;
        let s = (c, l) => {
            let u = l.x - c.x
              , d = l.y - c.y
              , f = Math.sqrt(u * u + d * d)
              , b = u / f
              , m = d / f;
            return {
                len: f,
                nx: b,
                ny: m
            }
        }
          , n = (c, l) => {
            c === 0 ? i.moveTo(l.x, l.y) : i.lineTo(l.x, l.y)
        }
          , a = e[e.length - 1];
        for (let c = 0; c < e.length; c++) {
            let l = e[c % e.length]
              , u = (r = l.radius) != null ? r : t;
            if (u <= 0) {
                n(c, l),
                a = l;
                continue
            }
            let d = e[(c + 1) % e.length]
              , f = s(l, a)
              , b = s(l, d);
            if (f.len < 1e-4 || b.len < 1e-4) {
                n(c, l),
                a = l;
                continue
            }
            let m = Math.asin(f.nx * b.ny - f.ny * b.nx)
              , x = 1
              , y = !1;
            f.nx * b.nx - f.ny * -b.ny < 0 ? m < 0 ? m = Math.PI + m : (m = Math.PI - m,
            x = -1,
            y = !0) : m > 0 && (x = -1,
            y = !0);
            let S = m / 2, A, E = Math.abs(Math.cos(S) * u / Math.sin(S));
            E > Math.min(f.len / 2, b.len / 2) ? (E = Math.min(f.len / 2, b.len / 2),
            A = Math.abs(E * Math.sin(S) / Math.cos(S))) : A = u;
            let O = l.x + b.nx * E + -b.ny * A * x
              , M = l.y + b.ny * E + b.nx * A * x
              , j = Math.atan2(f.ny, f.nx) + Math.PI / 2 * x
              , L = Math.atan2(b.ny, b.nx) - Math.PI / 2 * x;
            c === 0 && i.moveTo(O + Math.cos(j) * A, M + Math.sin(j) * A),
            i.arc(O, M, A, j, L, y),
            a = l
        }
    }
    function Hy(i, e, t, r) {
        var s;
        let n = (l, u) => Math.sqrt((l.x - u.x) ** 2 + (l.y - u.y) ** 2)
          , a = (l, u, d) => ({
            x: l.x + (u.x - l.x) * d,
            y: l.y + (u.y - l.y) * d
        })
          , c = e.length;
        for (let l = 0; l < c; l++) {
            let u = e[(l + 1) % c]
              , d = (s = u.radius) != null ? s : t;
            if (d <= 0) {
                l === 0 ? i.moveTo(u.x, u.y) : i.lineTo(u.x, u.y);
                continue
            }
            let f = e[l], b = e[(l + 2) % c], m = n(f, u), x;
            if (m < 1e-4)
                x = u;
            else {
                let A = Math.min(m / 2, d);
                x = a(u, f, A / m)
            }
            let y = n(b, u), S;
            if (y < 1e-4)
                S = u;
            else {
                let A = Math.min(y / 2, d);
                S = a(u, b, A / y)
            }
            l === 0 ? i.moveTo(x.x, x.y) : i.lineTo(x.x, x.y),
            i.quadraticCurveTo(u.x, u.y, S.x, S.y, r)
        }
    }
    var zy = new Re
      , gl = class {
        constructor(e) {
            this.shapePrimitives = [],
            this._currentPoly = null,
            this._bounds = new at,
            this._graphicsPath2D = e,
            this.signed = e.checkForHoles
        }
        moveTo(e, t) {
            return this.startPoly(e, t),
            this
        }
        lineTo(e, t) {
            this._ensurePoly();
            let r = this._currentPoly.points
              , s = r[r.length - 2]
              , n = r[r.length - 1];
            return (s !== e || n !== t) && r.push(e, t),
            this
        }
        arc(e, t, r, s, n, a) {
            this._ensurePoly(!1);
            let c = this._currentPoly.points;
            return L0(c, e, t, r, s, n, a),
            this
        }
        arcTo(e, t, r, s, n) {
            this._ensurePoly();
            let a = this._currentPoly.points;
            return Uy(a, e, t, r, s, n),
            this
        }
        arcToSvg(e, t, r, s, n, a, c) {
            let l = this._currentPoly.points;
            return Xy(l, this._currentPoly.lastX, this._currentPoly.lastY, a, c, e, t, r, s, n),
            this
        }
        bezierCurveTo(e, t, r, s, n, a, c) {
            this._ensurePoly();
            let l = this._currentPoly;
            return U0(this._currentPoly.points, l.lastX, l.lastY, e, t, r, s, n, a, c),
            this
        }
        quadraticCurveTo(e, t, r, s, n) {
            this._ensurePoly();
            let a = this._currentPoly;
            return Dy(this._currentPoly.points, a.lastX, a.lastY, e, t, r, s, n),
            this
        }
        closePath() {
            return this.endPoly(!0),
            this
        }
        addPath(e, t) {
            this.endPoly(),
            t && !t.isIdentity() && (e = e.clone(!0),
            e.transform(t));
            let r = this.shapePrimitives
              , s = r.length;
            for (let n = 0; n < e.instructions.length; n++) {
                let a = e.instructions[n];
                this[a.action](...a.data)
            }
            if (e.checkForHoles && r.length - s > 1) {
                let n = null;
                for (let a = s; a < r.length; a++) {
                    let c = r[a];
                    if (c.shape.type === "polygon") {
                        let l = c.shape
                          , u = n?.shape;
                        u && u.containsPolygon(l) ? (n.holes || (n.holes = []),
                        n.holes.push(c),
                        r.copyWithin(a, a + 1),
                        r.length--,
                        a--) : n = c
                    }
                }
            }
            return this
        }
        finish(e=!1) {
            this.endPoly(e)
        }
        rect(e, t, r, s, n) {
            return this.drawShape(new Re(e,t,r,s), n),
            this
        }
        circle(e, t, r, s) {
            return this.drawShape(new dl(e,t,r), s),
            this
        }
        poly(e, t, r) {
            let s = new as(e);
            return s.closePath = t,
            this.drawShape(s, r),
            this
        }
        regularPoly(e, t, r, s, n=0, a) {
            s = Math.max(s | 0, 3);
            let c = -1 * Math.PI / 2 + n
              , l = Math.PI * 2 / s
              , u = [];
            for (let d = 0; d < s; d++) {
                let f = c - d * l;
                u.push(e + r * Math.cos(f), t + r * Math.sin(f))
            }
            return this.poly(u, !0, a),
            this
        }
        roundPoly(e, t, r, s, n, a=0, c) {
            if (s = Math.max(s | 0, 3),
            n <= 0)
                return this.regularPoly(e, t, r, s, a);
            let l = r * Math.sin(Math.PI / s) - .001;
            n = Math.min(n, l);
            let u = -1 * Math.PI / 2 + a
              , d = Math.PI * 2 / s
              , f = (s - 2) * Math.PI / s / 2;
            for (let b = 0; b < s; b++) {
                let m = b * d + u
                  , x = e + r * Math.cos(m)
                  , y = t + r * Math.sin(m)
                  , S = m + Math.PI + f
                  , A = m - Math.PI - f
                  , E = x + n * Math.cos(S)
                  , O = y + n * Math.sin(S)
                  , M = x + n * Math.cos(A)
                  , j = y + n * Math.sin(A);
                b === 0 ? this.moveTo(E, O) : this.lineTo(E, O),
                this.quadraticCurveTo(x, y, M, j, c)
            }
            return this.closePath()
        }
        roundShape(e, t, r=!1, s) {
            return e.length < 3 ? this : (r ? Hy(this, e, t, s) : jy(this, e, t),
            this.closePath())
        }
        filletRect(e, t, r, s, n) {
            if (n === 0)
                return this.rect(e, t, r, s);
            let a = Math.min(r, s) / 2
              , c = Math.min(a, Math.max(-a, n))
              , l = e + r
              , u = t + s
              , d = c < 0 ? -c : 0
              , f = Math.abs(c);
            return this.moveTo(e, t + f).arcTo(e + d, t + d, e + f, t, f).lineTo(l - f, t).arcTo(l - d, t + d, l, t + f, f).lineTo(l, u - f).arcTo(l - d, u - d, e + r - f, u, f).lineTo(e + f, u).arcTo(e + d, u - d, e, u - f, f).closePath()
        }
        chamferRect(e, t, r, s, n, a) {
            if (n <= 0)
                return this.rect(e, t, r, s);
            let c = Math.min(n, Math.min(r, s) / 2)
              , l = e + r
              , u = t + s
              , d = [e + c, t, l - c, t, l, t + c, l, u - c, l - c, u, e + c, u, e, u - c, e, t + c];
            for (let f = d.length - 1; f >= 2; f -= 2)
                d[f] === d[f - 2] && d[f - 1] === d[f - 3] && d.splice(f - 1, 2);
            return this.poly(d, !0, a)
        }
        ellipse(e, t, r, s, n) {
            return this.drawShape(new fl(e,t,r,s), n),
            this
        }
        roundRect(e, t, r, s, n, a) {
            return this.drawShape(new pl(e,t,r,s,n), a),
            this
        }
        drawShape(e, t) {
            return this.endPoly(),
            this.shapePrimitives.push({
                shape: e,
                transform: t
            }),
            this
        }
        startPoly(e, t) {
            let r = this._currentPoly;
            return r && this.endPoly(),
            r = new as,
            r.points.push(e, t),
            this._currentPoly = r,
            this
        }
        endPoly(e=!1) {
            let t = this._currentPoly;
            return t && t.points.length > 2 && (t.closePath = e,
            this.shapePrimitives.push({
                shape: t
            })),
            this._currentPoly = null,
            this
        }
        _ensurePoly(e=!0) {
            if (!this._currentPoly && (this._currentPoly = new as,
            e)) {
                let t = this.shapePrimitives[this.shapePrimitives.length - 1];
                if (t) {
                    let r = t.shape.x
                      , s = t.shape.y;
                    if (t.transform && !t.transform.isIdentity()) {
                        let n = t.transform
                          , a = r;
                        r = n.a * r + n.c * s + n.tx,
                        s = n.b * a + n.d * s + n.ty
                    }
                    this._currentPoly.points.push(r, s)
                } else
                    this._currentPoly.points.push(0, 0)
            }
        }
        buildPath() {
            let e = this._graphicsPath2D;
            this.shapePrimitives.length = 0,
            this._currentPoly = null;
            for (let t = 0; t < e.instructions.length; t++) {
                let r = e.instructions[t];
                this[r.action](...r.data)
            }
            this.finish()
        }
        get bounds() {
            let e = this._bounds;
            e.clear();
            let t = this.shapePrimitives;
            for (let r = 0; r < t.length; r++) {
                let s = t[r]
                  , n = s.shape.getBounds(zy);
                s.transform ? e.addRect(n, s.transform) : e.addRect(n)
            }
            return e
        }
    }
      , mi = class i {
        constructor(e, t=!1) {
            this.instructions = [],
            this.uid = Xe("graphicsPath"),
            this._dirty = !0;
            var r;
            this.checkForHoles = t,
            typeof e == "string" ? Ay(e, this) : this.instructions = (r = e?.slice()) != null ? r : []
        }
        get shapePath() {
            return this._shapePath || (this._shapePath = new gl(this)),
            this._dirty && (this._dirty = !1,
            this._shapePath.buildPath()),
            this._shapePath
        }
        addPath(e, t) {
            return e = e.clone(),
            this.instructions.push({
                action: "addPath",
                data: [e, t]
            }),
            this._dirty = !0,
            this
        }
        arc(...e) {
            return this.instructions.push({
                action: "arc",
                data: e
            }),
            this._dirty = !0,
            this
        }
        arcTo(...e) {
            return this.instructions.push({
                action: "arcTo",
                data: e
            }),
            this._dirty = !0,
            this
        }
        arcToSvg(...e) {
            return this.instructions.push({
                action: "arcToSvg",
                data: e
            }),
            this._dirty = !0,
            this
        }
        bezierCurveTo(...e) {
            return this.instructions.push({
                action: "bezierCurveTo",
                data: e
            }),
            this._dirty = !0,
            this
        }
        bezierCurveToShort(e, t, r, s, n) {
            let a = this.instructions[this.instructions.length - 1]
              , c = this.getLastPoint(Ne.shared)
              , l = 0
              , u = 0;
            if (!a || a.action !== "bezierCurveTo")
                l = c.x,
                u = c.y;
            else {
                l = a.data[2],
                u = a.data[3];
                let d = c.x
                  , f = c.y;
                l = d + (d - l),
                u = f + (f - u)
            }
            return this.instructions.push({
                action: "bezierCurveTo",
                data: [l, u, e, t, r, s, n]
            }),
            this._dirty = !0,
            this
        }
        closePath() {
            return this.instructions.push({
                action: "closePath",
                data: []
            }),
            this._dirty = !0,
            this
        }
        ellipse(...e) {
            return this.instructions.push({
                action: "ellipse",
                data: e
            }),
            this._dirty = !0,
            this
        }
        lineTo(...e) {
            return this.instructions.push({
                action: "lineTo",
                data: e
            }),
            this._dirty = !0,
            this
        }
        moveTo(...e) {
            return this.instructions.push({
                action: "moveTo",
                data: e
            }),
            this
        }
        quadraticCurveTo(...e) {
            return this.instructions.push({
                action: "quadraticCurveTo",
                data: e
            }),
            this._dirty = !0,
            this
        }
        quadraticCurveToShort(e, t, r) {
            let s = this.instructions[this.instructions.length - 1]
              , n = this.getLastPoint(Ne.shared)
              , a = 0
              , c = 0;
            if (!s || s.action !== "quadraticCurveTo")
                a = n.x,
                c = n.y;
            else {
                a = s.data[0],
                c = s.data[1];
                let l = n.x
                  , u = n.y;
                a = l + (l - a),
                c = u + (u - c)
            }
            return this.instructions.push({
                action: "quadraticCurveTo",
                data: [a, c, e, t, r]
            }),
            this._dirty = !0,
            this
        }
        rect(e, t, r, s, n) {
            return this.instructions.push({
                action: "rect",
                data: [e, t, r, s, n]
            }),
            this._dirty = !0,
            this
        }
        circle(e, t, r, s) {
            return this.instructions.push({
                action: "circle",
                data: [e, t, r, s]
            }),
            this._dirty = !0,
            this
        }
        roundRect(...e) {
            return this.instructions.push({
                action: "roundRect",
                data: e
            }),
            this._dirty = !0,
            this
        }
        poly(...e) {
            return this.instructions.push({
                action: "poly",
                data: e
            }),
            this._dirty = !0,
            this
        }
        regularPoly(...e) {
            return this.instructions.push({
                action: "regularPoly",
                data: e
            }),
            this._dirty = !0,
            this
        }
        roundPoly(...e) {
            return this.instructions.push({
                action: "roundPoly",
                data: e
            }),
            this._dirty = !0,
            this
        }
        roundShape(...e) {
            return this.instructions.push({
                action: "roundShape",
                data: e
            }),
            this._dirty = !0,
            this
        }
        filletRect(...e) {
            return this.instructions.push({
                action: "filletRect",
                data: e
            }),
            this._dirty = !0,
            this
        }
        chamferRect(...e) {
            return this.instructions.push({
                action: "chamferRect",
                data: e
            }),
            this._dirty = !0,
            this
        }
        star(e, t, r, s, n, a, c) {
            n || (n = s / 2);
            let l = -1 * Math.PI / 2 + a
              , u = r * 2
              , d = Math.PI * 2 / u
              , f = [];
            for (let b = 0; b < u; b++) {
                let m = b % 2 ? n : s
                  , x = b * d + l;
                f.push(e + m * Math.cos(x), t + m * Math.sin(x))
            }
            return this.poly(f, !0, c),
            this
        }
        clone(e=!1) {
            let t = new i;
            if (t.checkForHoles = this.checkForHoles,
            !e)
                t.instructions = this.instructions.slice();
            else
                for (let r = 0; r < this.instructions.length; r++) {
                    let s = this.instructions[r];
                    t.instructions.push({
                        action: s.action,
                        data: s.data.slice()
                    })
                }
            return t
        }
        clear() {
            return this.instructions.length = 0,
            this._dirty = !0,
            this
        }
        transform(e) {
            if (e.isIdentity())
                return this;
            let t = e.a
              , r = e.b
              , s = e.c
              , n = e.d
              , a = e.tx
              , c = e.ty
              , l = 0
              , u = 0
              , d = 0
              , f = 0
              , b = 0
              , m = 0
              , x = 0
              , y = 0;
            for (let S = 0; S < this.instructions.length; S++) {
                let A = this.instructions[S]
                  , E = A.data;
                switch (A.action) {
                case "moveTo":
                case "lineTo":
                    l = E[0],
                    u = E[1],
                    E[0] = t * l + s * u + a,
                    E[1] = r * l + n * u + c;
                    break;
                case "bezierCurveTo":
                    d = E[0],
                    f = E[1],
                    b = E[2],
                    m = E[3],
                    l = E[4],
                    u = E[5],
                    E[0] = t * d + s * f + a,
                    E[1] = r * d + n * f + c,
                    E[2] = t * b + s * m + a,
                    E[3] = r * b + n * m + c,
                    E[4] = t * l + s * u + a,
                    E[5] = r * l + n * u + c;
                    break;
                case "quadraticCurveTo":
                    d = E[0],
                    f = E[1],
                    l = E[2],
                    u = E[3],
                    E[0] = t * d + s * f + a,
                    E[1] = r * d + n * f + c,
                    E[2] = t * l + s * u + a,
                    E[3] = r * l + n * u + c;
                    break;
                case "arcToSvg":
                    l = E[5],
                    u = E[6],
                    x = E[0],
                    y = E[1],
                    E[0] = t * x + s * y,
                    E[1] = r * x + n * y,
                    E[5] = t * l + s * u + a,
                    E[6] = r * l + n * u + c;
                    break;
                case "circle":
                    E[4] = Xr(E[3], e);
                    break;
                case "rect":
                    E[4] = Xr(E[4], e);
                    break;
                case "ellipse":
                    E[8] = Xr(E[8], e);
                    break;
                case "roundRect":
                    E[5] = Xr(E[5], e);
                    break;
                case "addPath":
                    E[0].transform(e);
                    break;
                case "poly":
                    E[2] = Xr(E[2], e);
                    break;
                default:
                    break
                }
            }
            return this._dirty = !0,
            this
        }
        get bounds() {
            return this.shapePath.bounds
        }
        getLastPoint(e) {
            let t = this.instructions.length - 1
              , r = this.instructions[t];
            if (!r)
                return e.x = 0,
                e.y = 0,
                e;
            for (; r.action === "closePath"; ) {
                if (t--,
                t < 0)
                    return e.x = 0,
                    e.y = 0,
                    e;
                r = this.instructions[t]
            }
            switch (r.action) {
            case "moveTo":
            case "lineTo":
                e.x = r.data[0],
                e.y = r.data[1];
                break;
            case "quadraticCurveTo":
                e.x = r.data[2],
                e.y = r.data[3];
                break;
            case "bezierCurveTo":
                e.x = r.data[4],
                e.y = r.data[5];
                break;
            case "arc":
            case "arcToSvg":
                e.x = r.data[5],
                e.y = r.data[6];
                break;
            case "addPath":
                r.data[0].getLastPoint(e);
                break
            }
            return e
        }
    }
    ;
    function Xr(i, e) {
        return i ? i.prepend(e) : e.clone()
    }
    var ec = 0
      , jd = 500;
    function Ti(...i) {
        ec !== jd && ec++
    }
    function $e(i, e, t) {
        let r = i.getAttribute(e);
        return r ? Number(r) : t
    }
    function Vy(i, e) {
        let t = i.querySelectorAll("defs");
        for (let r = 0; r < t.length; r++) {
            let s = t[r];
            for (let n = 0; n < s.children.length; n++) {
                let a = s.children[n];
                switch (a.nodeName.toLowerCase()) {
                case "lineargradient":
                    e.defs[a.id] = Wy(a);
                    break;
                case "radialgradient":
                    e.defs[a.id] = Yy(a);
                    break;
                default:
                    break
                }
            }
        }
    }
    function Wy(i) {
        let e = $e(i, "x1", 0)
          , t = $e(i, "y1", 0)
          , r = $e(i, "x2", 1)
          , s = $e(i, "y2", 0)
          , n = i.getAttribute("gradientUnits") || "objectBoundingBox"
          , a = new vi(e,t,r,s,n === "objectBoundingBox" ? "local" : "global");
        for (let c = 0; c < i.children.length; c++) {
            let l = i.children[c]
              , u = $e(l, "offset", 0)
              , d = Ie.shared.setValue(l.getAttribute("stop-color")).toNumber();
            a.addColorStop(u, d)
        }
        return a
    }
    function Yy(i) {
        return new vi(0,0,1,0)
    }
    function Hd(i) {
        let e = i.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
        return e ? e[1] : ""
    }
    var zd = {
        fill: {
            type: "paint",
            default: 0
        },
        "fill-opacity": {
            type: "number",
            default: 1
        },
        stroke: {
            type: "paint",
            default: 0
        },
        "stroke-width": {
            type: "number",
            default: 1
        },
        "stroke-opacity": {
            type: "number",
            default: 1
        },
        "stroke-linecap": {
            type: "string",
            default: "butt"
        },
        "stroke-linejoin": {
            type: "string",
            default: "miter"
        },
        "stroke-miterlimit": {
            type: "number",
            default: 10
        },
        "stroke-dasharray": {
            type: "string",
            default: "none"
        },
        "stroke-dashoffset": {
            type: "number",
            default: 0
        },
        opacity: {
            type: "number",
            default: 1
        }
    };
    function N0(i, e) {
        let t = i.getAttribute("style")
          , r = {}
          , s = {}
          , n = {
            strokeStyle: r,
            fillStyle: s,
            useFill: !1,
            useStroke: !1
        };
        for (let a in zd) {
            let c = i.getAttribute(a);
            c && Vd(e, n, a, c.trim())
        }
        if (t) {
            let a = t.split(";");
            for (let c = 0; c < a.length; c++) {
                let l = a[c].trim()
                  , [u,d] = l.split(":");
                zd[u] && Vd(e, n, u, d.trim())
            }
        }
        return {
            strokeStyle: n.useStroke ? r : null,
            fillStyle: n.useFill ? s : null,
            useFill: n.useFill,
            useStroke: n.useStroke
        }
    }
    function Vd(i, e, t, r) {
        switch (t) {
        case "stroke":
            if (r !== "none") {
                if (r.startsWith("url(")) {
                    let s = Hd(r);
                    e.strokeStyle.fill = i.defs[s]
                } else
                    e.strokeStyle.color = Ie.shared.setValue(r).toNumber();
                e.useStroke = !0
            }
            break;
        case "stroke-width":
            e.strokeStyle.width = Number(r);
            break;
        case "fill":
            if (r !== "none") {
                if (r.startsWith("url(")) {
                    let s = Hd(r);
                    e.fillStyle.fill = i.defs[s]
                } else
                    e.fillStyle.color = Ie.shared.setValue(r).toNumber();
                e.useFill = !0
            }
            break;
        case "fill-opacity":
            e.fillStyle.alpha = Number(r);
            break;
        case "stroke-opacity":
            e.strokeStyle.alpha = Number(r);
            break;
        case "opacity":
            e.fillStyle.alpha = Number(r),
            e.strokeStyle.alpha = Number(r);
            break
        }
    }
    function $y(i) {
        if (i.length <= 2)
            return !0;
        let e = i.map(c => c.area).sort( (c, l) => l - c)
          , [t,r] = e
          , s = e[e.length - 1]
          , n = t / r
          , a = r / s;
        return !(n > 3 && a < 2)
    }
    function Ky(i) {
        return i.split(/(?=[Mm])/).filter(e => e.trim().length > 0)
    }
    function qy(i) {
        let e = i.match(/[-+]?[0-9]*\.?[0-9]+/g);
        if (!e || e.length < 4)
            return 0;
        let t = e.map(Number)
          , r = []
          , s = [];
        for (let u = 0; u < t.length; u += 2)
            u + 1 < t.length && (r.push(t[u]),
            s.push(t[u + 1]));
        if (r.length === 0 || s.length === 0)
            return 0;
        let n = Math.min(...r)
          , a = Math.max(...r)
          , c = Math.min(...s)
          , l = Math.max(...s);
        return (a - n) * (l - c)
    }
    function Wd(i, e) {
        let t = new mi(i,!1);
        for (let r of t.instructions)
            e.instructions.push(r)
    }
    var Zy = Object.defineProperty
      , Yd = Object.getOwnPropertySymbols
      , Qy = Object.prototype.hasOwnProperty
      , Jy = Object.prototype.propertyIsEnumerable
      , $d = (i, e, t) => e in i ? Zy(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , $s = (i, e) => {
        for (var t in e || (e = {}))
            Qy.call(e, t) && $d(i, t, e[t]);
        if (Yd)
            for (var t of Yd(e))
                Jy.call(e, t) && $d(i, t, e[t]);
        return i
    }
    ;
    function e3(i, e) {
        if (typeof i == "string") {
            let a = document.createElement("div");
            a.innerHTML = i.trim(),
            i = a.querySelector("svg")
        }
        let t = {
            context: e,
            defs: {},
            path: new mi
        };
        Vy(i, t);
        let r = i.children
          , {fillStyle: s, strokeStyle: n} = N0(i, t);
        for (let a = 0; a < r.length; a++) {
            let c = r[a];
            c.nodeName.toLowerCase() !== "defs" && X0(c, t, s, n)
        }
        return e
    }
    function X0(i, e, t, r) {
        let s = i.children
          , {fillStyle: n, strokeStyle: a} = N0(i, e);
        n && t ? t = $s($s({}, t), n) : n && (t = n),
        a && r ? r = $s($s({}, r), a) : a && (r = a);
        let c = !t && !r;
        c && (t = {
            color: 0
        });
        let l, u, d, f, b, m, x, y, S, A, E, O, M, j, L, N, Y;
        switch (i.nodeName.toLowerCase()) {
        case "path":
            {
                j = i.getAttribute("d");
                let ie = i.getAttribute("fill-rule")
                  , $ = Ky(j)
                  , J = ie === "evenodd"
                  , re = $.length > 1;
                if (J && re) {
                    let Q = $.map(pe => ({
                        path: pe,
                        area: qy(pe)
                    }));
                    if (Q.sort( (pe, Be) => Be.area - pe.area),
                    $.length > 3 || !$y(Q))
                        for (let pe = 0; pe < Q.length; pe++) {
                            let Be = Q[pe]
                              , ne = pe === 0;
                            e.context.beginPath();
                            let se = new mi(void 0,!0);
                            Wd(Be.path, se),
                            e.context.path(se),
                            ne ? (t && e.context.fill(t),
                            r && e.context.stroke(r)) : e.context.cut()
                        }
                    else
                        for (let pe = 0; pe < Q.length; pe++) {
                            let Be = Q[pe]
                              , ne = pe % 2 === 1;
                            e.context.beginPath();
                            let se = new mi(void 0,!0);
                            Wd(Be.path, se),
                            e.context.path(se),
                            ne ? e.context.cut() : (t && e.context.fill(t),
                            r && e.context.stroke(r))
                        }
                } else {
                    let Q = ie ? ie === "evenodd" : !0;
                    L = new mi(j,Q),
                    e.context.path(L),
                    t && e.context.fill(t),
                    r && e.context.stroke(r)
                }
                break
            }
        case "circle":
            x = $e(i, "cx", 0),
            y = $e(i, "cy", 0),
            S = $e(i, "r", 0),
            e.context.ellipse(x, y, S, S),
            t && e.context.fill(t),
            r && e.context.stroke(r);
            break;
        case "rect":
            l = $e(i, "x", 0),
            u = $e(i, "y", 0),
            N = $e(i, "width", 0),
            Y = $e(i, "height", 0),
            A = $e(i, "rx", 0),
            E = $e(i, "ry", 0),
            A || E ? e.context.roundRect(l, u, N, Y, A || E) : e.context.rect(l, u, N, Y),
            t && e.context.fill(t),
            r && e.context.stroke(r);
            break;
        case "ellipse":
            x = $e(i, "cx", 0),
            y = $e(i, "cy", 0),
            A = $e(i, "rx", 0),
            E = $e(i, "ry", 0),
            e.context.beginPath(),
            e.context.ellipse(x, y, A, E),
            t && e.context.fill(t),
            r && e.context.stroke(r);
            break;
        case "line":
            d = $e(i, "x1", 0),
            f = $e(i, "y1", 0),
            b = $e(i, "x2", 0),
            m = $e(i, "y2", 0),
            e.context.beginPath(),
            e.context.moveTo(d, f),
            e.context.lineTo(b, m),
            r && e.context.stroke(r);
            break;
        case "polygon":
            M = i.getAttribute("points"),
            O = M.match(/\d+/g).map(ie => parseInt(ie, 10)),
            e.context.poly(O, !0),
            t && e.context.fill(t),
            r && e.context.stroke(r);
            break;
        case "polyline":
            M = i.getAttribute("points"),
            O = M.match(/\d+/g).map(ie => parseInt(ie, 10)),
            e.context.poly(O, !1),
            r && e.context.stroke(r);
            break;
        case "g":
        case "svg":
            break;
        default:
            {
                Ti(`[SVG parser] <${i.nodeName}> elements unsupported`);
                break
            }
        }
        c && (t = null);
        for (let ie = 0; ie < s.length; ie++)
            X0(s[ie], e, t, r)
    }
    var t3 = Object.defineProperty
      , Ln = Object.getOwnPropertySymbols
      , j0 = Object.prototype.hasOwnProperty
      , H0 = Object.prototype.propertyIsEnumerable
      , Kd = (i, e, t) => e in i ? t3(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Jt = (i, e) => {
        for (var t in e || (e = {}))
            j0.call(e, t) && Kd(i, t, e[t]);
        if (Ln)
            for (var t of Ln(e))
                H0.call(e, t) && Kd(i, t, e[t]);
        return i
    }
      , i3 = (i, e) => {
        var t = {};
        for (var r in i)
            j0.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && Ln)
            for (var r of Ln(i))
                e.indexOf(r) < 0 && H0.call(i, r) && (t[r] = i[r]);
        return t
    }
    ;
    function r3(i) {
        return Ie.isColorLike(i)
    }
    function qd(i) {
        return i instanceof Rr
    }
    function Zd(i) {
        return i instanceof vi
    }
    function s3(i) {
        return i instanceof Z
    }
    function n3(i, e, t) {
        let r = Ie.shared.setValue(e ?? 0);
        return i.color = r.toNumber(),
        i.alpha = r.alpha === 1 ? t.alpha : r.alpha,
        i.texture = Z.WHITE,
        Jt(Jt({}, t), i)
    }
    function a3(i, e, t) {
        return i.texture = e,
        Jt(Jt({}, t), i)
    }
    function Qd(i, e, t) {
        return i.fill = e,
        i.color = 16777215,
        i.texture = e.texture,
        i.matrix = e.transform,
        Jt(Jt({}, t), i)
    }
    function Jd(i, e, t) {
        return e.buildGradient(),
        i.fill = e,
        i.color = 16777215,
        i.texture = e.texture,
        i.matrix = e.transform,
        i.textureSpace = e.textureSpace,
        Jt(Jt({}, t), i)
    }
    function o3(i, e) {
        let t = Jt(Jt({}, e), i)
          , r = Ie.shared.setValue(t.color);
        return t.alpha *= r.alpha,
        t.color = r.toNumber(),
        t
    }
    function Qi(i, e) {
        if (i == null)
            return null;
        let t = {}
          , r = i;
        return r3(i) ? n3(t, i, e) : s3(i) ? a3(t, i, e) : qd(i) ? Qd(t, i, e) : Zd(i) ? Jd(t, i, e) : r.fill && qd(r.fill) ? Qd(r, r.fill, e) : r.fill && Zd(r.fill) ? Jd(r, r.fill, e) : o3(r, e)
    }
    function Nn(i, e) {
        let t = e
          , {width: r, alignment: s, miterLimit: n, cap: a, join: c, pixelLine: l} = t
          , u = i3(t, ["width", "alignment", "miterLimit", "cap", "join", "pixelLine"])
          , d = Qi(i, u);
        return d ? Jt({
            width: r,
            alignment: s,
            miterLimit: n,
            cap: a,
            join: c,
            pixelLine: l
        }, d) : null
    }
    var c3 = Object.defineProperty
      , ef = Object.getOwnPropertySymbols
      , l3 = Object.prototype.hasOwnProperty
      , h3 = Object.prototype.propertyIsEnumerable
      , tf = (i, e, t) => e in i ? c3(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , ur = (i, e) => {
        for (var t in e || (e = {}))
            l3.call(e, t) && tf(i, t, e[t]);
        if (ef)
            for (var t of ef(e))
                h3.call(e, t) && tf(i, t, e[t]);
        return i
    }
      , u3 = new Ne
      , rf = new ce
      , _l = class ai extends Ft {
        constructor() {
            super(...arguments),
            this.uid = Xe("graphicsContext"),
            this.dirty = !0,
            this.batchMode = "auto",
            this.instructions = [],
            this._activePath = new mi,
            this._transform = new ce,
            this._fillStyle = ur({}, ai.defaultFillStyle),
            this._strokeStyle = ur({}, ai.defaultStrokeStyle),
            this._stateStack = [],
            this._tick = 0,
            this._bounds = new at,
            this._boundsDirty = !0
        }
        clone() {
            let e = new ai;
            return e.batchMode = this.batchMode,
            e.instructions = this.instructions.slice(),
            e._activePath = this._activePath.clone(),
            e._transform = this._transform.clone(),
            e._fillStyle = ur({}, this._fillStyle),
            e._strokeStyle = ur({}, this._strokeStyle),
            e._stateStack = this._stateStack.slice(),
            e._bounds = this._bounds.clone(),
            e._boundsDirty = !0,
            e
        }
        get fillStyle() {
            return this._fillStyle
        }
        set fillStyle(e) {
            this._fillStyle = Qi(e, ai.defaultFillStyle)
        }
        get strokeStyle() {
            return this._strokeStyle
        }
        set strokeStyle(e) {
            this._strokeStyle = Nn(e, ai.defaultStrokeStyle)
        }
        setFillStyle(e) {
            return this._fillStyle = Qi(e, ai.defaultFillStyle),
            this
        }
        setStrokeStyle(e) {
            return this._strokeStyle = Qi(e, ai.defaultStrokeStyle),
            this
        }
        texture(e, t, r, s, n, a) {
            return this.instructions.push({
                action: "texture",
                data: {
                    image: e,
                    dx: r || 0,
                    dy: s || 0,
                    dw: n || e.frame.width,
                    dh: a || e.frame.height,
                    transform: this._transform.clone(),
                    alpha: this._fillStyle.alpha,
                    style: t ? Ie.shared.setValue(t).toNumber() : 16777215
                }
            }),
            this.onUpdate(),
            this
        }
        beginPath() {
            return this._activePath = new mi,
            this
        }
        fill(e, t) {
            let r, s = this.instructions[this.instructions.length - 1];
            return this._tick === 0 && s && s.action === "stroke" ? r = s.data.path : r = this._activePath.clone(),
            r ? (e != null && (t !== void 0 && typeof e == "number" && (e = {
                color: e,
                alpha: t
            }),
            this._fillStyle = Qi(e, ai.defaultFillStyle)),
            this.instructions.push({
                action: "fill",
                data: {
                    style: this.fillStyle,
                    path: r
                }
            }),
            this.onUpdate(),
            this._initNextPathLocation(),
            this._tick = 0,
            this) : this
        }
        _initNextPathLocation() {
            let {x: e, y: t} = this._activePath.getLastPoint(Ne.shared);
            this._activePath.clear(),
            this._activePath.moveTo(e, t)
        }
        stroke(e) {
            let t, r = this.instructions[this.instructions.length - 1];
            return this._tick === 0 && r && r.action === "fill" ? t = r.data.path : t = this._activePath.clone(),
            t ? (e != null && (this._strokeStyle = Nn(e, ai.defaultStrokeStyle)),
            this.instructions.push({
                action: "stroke",
                data: {
                    style: this.strokeStyle,
                    path: t
                }
            }),
            this.onUpdate(),
            this._initNextPathLocation(),
            this._tick = 0,
            this) : this
        }
        cut() {
            for (let e = 0; e < 2; e++) {
                let t = this.instructions[this.instructions.length - 1 - e]
                  , r = this._activePath.clone();
                if (t && (t.action === "stroke" || t.action === "fill"))
                    if (t.data.hole)
                        t.data.hole.addPath(r);
                    else {
                        t.data.hole = r;
                        break
                    }
            }
            return this._initNextPathLocation(),
            this
        }
        arc(e, t, r, s, n, a) {
            this._tick++;
            let c = this._transform;
            return this._activePath.arc(c.a * e + c.c * t + c.tx, c.b * e + c.d * t + c.ty, r, s, n, a),
            this
        }
        arcTo(e, t, r, s, n) {
            this._tick++;
            let a = this._transform;
            return this._activePath.arcTo(a.a * e + a.c * t + a.tx, a.b * e + a.d * t + a.ty, a.a * r + a.c * s + a.tx, a.b * r + a.d * s + a.ty, n),
            this
        }
        arcToSvg(e, t, r, s, n, a, c) {
            this._tick++;
            let l = this._transform;
            return this._activePath.arcToSvg(e, t, r, s, n, l.a * a + l.c * c + l.tx, l.b * a + l.d * c + l.ty),
            this
        }
        bezierCurveTo(e, t, r, s, n, a, c) {
            this._tick++;
            let l = this._transform;
            return this._activePath.bezierCurveTo(l.a * e + l.c * t + l.tx, l.b * e + l.d * t + l.ty, l.a * r + l.c * s + l.tx, l.b * r + l.d * s + l.ty, l.a * n + l.c * a + l.tx, l.b * n + l.d * a + l.ty, c),
            this
        }
        closePath() {
            var e;
            return this._tick++,
            (e = this._activePath) == null || e.closePath(),
            this
        }
        ellipse(e, t, r, s) {
            return this._tick++,
            this._activePath.ellipse(e, t, r, s, this._transform.clone()),
            this
        }
        circle(e, t, r) {
            return this._tick++,
            this._activePath.circle(e, t, r, this._transform.clone()),
            this
        }
        path(e) {
            return this._tick++,
            this._activePath.addPath(e, this._transform.clone()),
            this
        }
        lineTo(e, t) {
            this._tick++;
            let r = this._transform;
            return this._activePath.lineTo(r.a * e + r.c * t + r.tx, r.b * e + r.d * t + r.ty),
            this
        }
        moveTo(e, t) {
            this._tick++;
            let r = this._transform
              , s = this._activePath.instructions
              , n = r.a * e + r.c * t + r.tx
              , a = r.b * e + r.d * t + r.ty;
            return s.length === 1 && s[0].action === "moveTo" ? (s[0].data[0] = n,
            s[0].data[1] = a,
            this) : (this._activePath.moveTo(n, a),
            this)
        }
        quadraticCurveTo(e, t, r, s, n) {
            this._tick++;
            let a = this._transform;
            return this._activePath.quadraticCurveTo(a.a * e + a.c * t + a.tx, a.b * e + a.d * t + a.ty, a.a * r + a.c * s + a.tx, a.b * r + a.d * s + a.ty, n),
            this
        }
        rect(e, t, r, s) {
            return this._tick++,
            this._activePath.rect(e, t, r, s, this._transform.clone()),
            this
        }
        roundRect(e, t, r, s, n) {
            return this._tick++,
            this._activePath.roundRect(e, t, r, s, n, this._transform.clone()),
            this
        }
        poly(e, t) {
            return this._tick++,
            this._activePath.poly(e, t, this._transform.clone()),
            this
        }
        regularPoly(e, t, r, s, n=0, a) {
            return this._tick++,
            this._activePath.regularPoly(e, t, r, s, n, a),
            this
        }
        roundPoly(e, t, r, s, n, a) {
            return this._tick++,
            this._activePath.roundPoly(e, t, r, s, n, a),
            this
        }
        roundShape(e, t, r, s) {
            return this._tick++,
            this._activePath.roundShape(e, t, r, s),
            this
        }
        filletRect(e, t, r, s, n) {
            return this._tick++,
            this._activePath.filletRect(e, t, r, s, n),
            this
        }
        chamferRect(e, t, r, s, n, a) {
            return this._tick++,
            this._activePath.chamferRect(e, t, r, s, n, a),
            this
        }
        star(e, t, r, s, n=0, a=0) {
            return this._tick++,
            this._activePath.star(e, t, r, s, n, a, this._transform.clone()),
            this
        }
        svg(e) {
            return this._tick++,
            e3(e, this),
            this
        }
        restore() {
            let e = this._stateStack.pop();
            return e && (this._transform = e.transform,
            this._fillStyle = e.fillStyle,
            this._strokeStyle = e.strokeStyle),
            this
        }
        save() {
            return this._stateStack.push({
                transform: this._transform.clone(),
                fillStyle: ur({}, this._fillStyle),
                strokeStyle: ur({}, this._strokeStyle)
            }),
            this
        }
        getTransform() {
            return this._transform
        }
        resetTransform() {
            return this._transform.identity(),
            this
        }
        rotate(e) {
            return this._transform.rotate(e),
            this
        }
        scale(e, t=e) {
            return this._transform.scale(e, t),
            this
        }
        setTransform(e, t, r, s, n, a) {
            return e instanceof ce ? (this._transform.set(e.a, e.b, e.c, e.d, e.tx, e.ty),
            this) : (this._transform.set(e, t, r, s, n, a),
            this)
        }
        transform(e, t, r, s, n, a) {
            return e instanceof ce ? (this._transform.append(e),
            this) : (rf.set(e, t, r, s, n, a),
            this._transform.append(rf),
            this)
        }
        translate(e, t=e) {
            return this._transform.translate(e, t),
            this
        }
        clear() {
            return this._activePath.clear(),
            this.instructions.length = 0,
            this.resetTransform(),
            this.onUpdate(),
            this
        }
        onUpdate() {
            this.dirty || (this.emit("update", this, 16),
            this.dirty = !0,
            this._boundsDirty = !0)
        }
        get bounds() {
            if (!this._boundsDirty)
                return this._bounds;
            this._boundsDirty = !1;
            let e = this._bounds;
            e.clear();
            for (let t = 0; t < this.instructions.length; t++) {
                let r = this.instructions[t]
                  , s = r.action;
                if (s === "fill") {
                    let n = r.data;
                    e.addBounds(n.path.bounds)
                } else if (s === "texture") {
                    let n = r.data;
                    e.addFrame(n.dx, n.dy, n.dx + n.dw, n.dy + n.dh, n.transform)
                }
                if (s === "stroke") {
                    let n = r.data
                      , a = n.style.alignment
                      , c = n.style.width * (1 - a)
                      , l = n.path.bounds;
                    e.addFrame(l.minX - c, l.minY - c, l.maxX + c, l.maxY + c)
                }
            }
            return e
        }
        containsPoint(e) {
            var t;
            if (!this.bounds.containsPoint(e.x, e.y))
                return !1;
            let r = this.instructions
              , s = !1;
            for (let n = 0; n < r.length; n++) {
                let a = r[n]
                  , c = a.data
                  , l = c.path;
                if (!a.action || !l)
                    continue;
                let u = c.style
                  , d = l.shapePath.shapePrimitives;
                for (let f = 0; f < d.length; f++) {
                    let b = d[f].shape;
                    if (!u || !b)
                        continue;
                    let m = d[f].transform
                      , x = m ? m.applyInverse(e, u3) : e;
                    if (a.action === "fill")
                        s = b.contains(x.x, x.y);
                    else {
                        let S = u;
                        s = b.strokeContains(x.x, x.y, S.width, S.alignment)
                    }
                    let y = c.hole;
                    if (y) {
                        let S = (t = y.shapePath) == null ? void 0 : t.shapePrimitives;
                        if (S)
                            for (let A = 0; A < S.length; A++)
                                S[A].shape.contains(x.x, x.y) && (s = !1)
                    }
                    if (s)
                        return !0
                }
            }
            return s
        }
        destroy(e=!1) {
            if (this._stateStack.length = 0,
            this._transform = null,
            this.emit("destroy", this),
            this.removeAllListeners(),
            typeof e == "boolean" ? e : e?.texture) {
                let t = typeof e == "boolean" ? e : e?.textureSource;
                this._fillStyle.texture && (this._fillStyle.fill && "uid"in this._fillStyle.fill ? this._fillStyle.fill.destroy() : this._fillStyle.texture.destroy(t)),
                this._strokeStyle.texture && (this._strokeStyle.fill && "uid"in this._strokeStyle.fill ? this._strokeStyle.fill.destroy() : this._strokeStyle.texture.destroy(t))
            }
            this._fillStyle = null,
            this._strokeStyle = null,
            this.instructions = null,
            this._activePath = null,
            this._bounds = null,
            this._stateStack = null,
            this.customShader = null,
            this._transform = null
        }
    }
    ;
    _l.defaultFillStyle = {
        color: 16777215,
        alpha: 1,
        texture: Z.WHITE,
        matrix: null,
        fill: null,
        textureSpace: "local"
    },
    _l.defaultStrokeStyle = {
        width: 1,
        color: 16777215,
        alpha: 1,
        alignment: .5,
        miterLimit: 10,
        cap: "butt",
        join: "miter",
        texture: Z.WHITE,
        matrix: null,
        fill: null,
        textureSpace: "local",
        pixelLine: !1
    };
    var wt = _l
      , d3 = Object.defineProperty
      , f3 = Object.defineProperties
      , p3 = Object.getOwnPropertyDescriptors
      , sf = Object.getOwnPropertySymbols
      , b3 = Object.prototype.hasOwnProperty
      , m3 = Object.prototype.propertyIsEnumerable
      , nf = (i, e, t) => e in i ? d3(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Rt = (i, e) => {
        for (var t in e || (e = {}))
            b3.call(e, t) && nf(i, t, e[t]);
        if (sf)
            for (var t of sf(e))
                m3.call(e, t) && nf(i, t, e[t]);
        return i
    }
      , g3 = (i, e) => f3(i, p3(e))
      , xl = class br extends Ft {
        constructor(e={}) {
            super(),
            this.uid = Xe("textStyle"),
            this._tick = 0,
            _3(e);
            let t = Rt(Rt({}, br.defaultTextStyle), e);
            for (let r in t) {
                let s = r;
                this[s] = t[r]
            }
            this.update(),
            this._tick = 0
        }
        get align() {
            return this._align
        }
        set align(e) {
            this._align = e,
            this.update()
        }
        get breakWords() {
            return this._breakWords
        }
        set breakWords(e) {
            this._breakWords = e,
            this.update()
        }
        get dropShadow() {
            return this._dropShadow
        }
        set dropShadow(e) {
            e !== null && typeof e == "object" ? this._dropShadow = this._createProxy(Rt(Rt({}, br.defaultDropShadow), e)) : this._dropShadow = e ? this._createProxy(Rt({}, br.defaultDropShadow)) : null,
            this.update()
        }
        get fontFamily() {
            return this._fontFamily
        }
        set fontFamily(e) {
            this._fontFamily = e,
            this.update()
        }
        get fontSize() {
            return this._fontSize
        }
        set fontSize(e) {
            typeof e == "string" ? this._fontSize = parseInt(e, 10) : this._fontSize = e,
            this.update()
        }
        get fontStyle() {
            return this._fontStyle
        }
        set fontStyle(e) {
            this._fontStyle = e.toLowerCase(),
            this.update()
        }
        get fontVariant() {
            return this._fontVariant
        }
        set fontVariant(e) {
            this._fontVariant = e,
            this.update()
        }
        get fontWeight() {
            return this._fontWeight
        }
        set fontWeight(e) {
            this._fontWeight = e,
            this.update()
        }
        get leading() {
            return this._leading
        }
        set leading(e) {
            this._leading = e,
            this.update()
        }
        get letterSpacing() {
            return this._letterSpacing
        }
        set letterSpacing(e) {
            this._letterSpacing = e,
            this.update()
        }
        get lineHeight() {
            return this._lineHeight
        }
        set lineHeight(e) {
            this._lineHeight = e,
            this.update()
        }
        get padding() {
            return this._padding
        }
        set padding(e) {
            this._padding = e,
            this.update()
        }
        get filters() {
            return this._filters
        }
        set filters(e) {
            this._filters = Object.freeze(e),
            this.update()
        }
        get trim() {
            return this._trim
        }
        set trim(e) {
            this._trim = e,
            this.update()
        }
        get textBaseline() {
            return this._textBaseline
        }
        set textBaseline(e) {
            this._textBaseline = e,
            this.update()
        }
        get whiteSpace() {
            return this._whiteSpace
        }
        set whiteSpace(e) {
            this._whiteSpace = e,
            this.update()
        }
        get wordWrap() {
            return this._wordWrap
        }
        set wordWrap(e) {
            this._wordWrap = e,
            this.update()
        }
        get wordWrapWidth() {
            return this._wordWrapWidth
        }
        set wordWrapWidth(e) {
            this._wordWrapWidth = e,
            this.update()
        }
        get fill() {
            return this._originalFill
        }
        set fill(e) {
            e !== this._originalFill && (this._originalFill = e,
            this._isFillStyle(e) && (this._originalFill = this._createProxy(Rt(Rt({}, wt.defaultFillStyle), e), () => {
                this._fill = Qi(Rt({}, this._originalFill), wt.defaultFillStyle)
            }
            )),
            this._fill = Qi(e === 0 ? "black" : e, wt.defaultFillStyle),
            this.update())
        }
        get stroke() {
            return this._originalStroke
        }
        set stroke(e) {
            e !== this._originalStroke && (this._originalStroke = e,
            this._isFillStyle(e) && (this._originalStroke = this._createProxy(Rt(Rt({}, wt.defaultStrokeStyle), e), () => {
                this._stroke = Nn(Rt({}, this._originalStroke), wt.defaultStrokeStyle)
            }
            )),
            this._stroke = Nn(e, wt.defaultStrokeStyle),
            this.update())
        }
        update() {
            this._tick++,
            this.emit("update", this)
        }
        reset() {
            let e = br.defaultTextStyle;
            for (let t in e)
                this[t] = e[t]
        }
        get styleKey() {
            return `${this.uid}-${this._tick}`
        }
        clone() {
            return new br({
                align: this.align,
                breakWords: this.breakWords,
                dropShadow: this._dropShadow ? Rt({}, this._dropShadow) : null,
                fill: this._fill,
                fontFamily: this.fontFamily,
                fontSize: this.fontSize,
                fontStyle: this.fontStyle,
                fontVariant: this.fontVariant,
                fontWeight: this.fontWeight,
                leading: this.leading,
                letterSpacing: this.letterSpacing,
                lineHeight: this.lineHeight,
                padding: this.padding,
                stroke: this._stroke,
                textBaseline: this.textBaseline,
                whiteSpace: this.whiteSpace,
                wordWrap: this.wordWrap,
                wordWrapWidth: this.wordWrapWidth,
                filters: this._filters ? [...this._filters] : void 0
            })
        }
        _getFinalPadding() {
            let e = 0;
            if (this._filters)
                for (let t = 0; t < this._filters.length; t++)
                    e += this._filters[t].padding;
            return Math.max(this._padding, e)
        }
        destroy(e=!1) {
            var t, r, s, n;
            if (this.removeAllListeners(),
            typeof e == "boolean" ? e : e?.texture) {
                let a = typeof e == "boolean" ? e : e?.textureSource;
                (t = this._fill) != null && t.texture && this._fill.texture.destroy(a),
                (r = this._originalFill) != null && r.texture && this._originalFill.texture.destroy(a),
                (s = this._stroke) != null && s.texture && this._stroke.texture.destroy(a),
                (n = this._originalStroke) != null && n.texture && this._originalStroke.texture.destroy(a)
            }
            this._fill = null,
            this._stroke = null,
            this.dropShadow = null,
            this._originalStroke = null,
            this._originalFill = null
        }
        _createProxy(e, t) {
            return new Proxy(e,{
                set: (r, s, n) => (r[s] = n,
                t?.(s, n),
                this.update(),
                !0)
            })
        }
        _isFillStyle(e) {
            return (e ?? null) !== null && !(Ie.isColorLike(e) || e instanceof vi || e instanceof Rr)
        }
    }
    ;
    xl.defaultDropShadow = {
        alpha: 1,
        angle: Math.PI / 6,
        blur: 0,
        color: "black",
        distance: 5
    },
    xl.defaultTextStyle = {
        align: "left",
        breakWords: !1,
        dropShadow: null,
        fill: "black",
        fontFamily: "Arial",
        fontSize: 26,
        fontStyle: "normal",
        fontVariant: "normal",
        fontWeight: "normal",
        leading: 0,
        letterSpacing: 0,
        lineHeight: 0,
        padding: 0,
        stroke: null,
        textBaseline: "alphabetic",
        trim: !1,
        whiteSpace: "pre",
        wordWrap: !1,
        wordWrapWidth: 100
    };
    var Xt = xl;
    function _3(i) {
        var e, t, r, s, n;
        let a = i;
        if (typeof a.dropShadow == "boolean" && a.dropShadow) {
            let c = Xt.defaultDropShadow;
            i.dropShadow = {
                alpha: (e = a.dropShadowAlpha) != null ? e : c.alpha,
                angle: (t = a.dropShadowAngle) != null ? t : c.angle,
                blur: (r = a.dropShadowBlur) != null ? r : c.blur,
                color: (s = a.dropShadowColor) != null ? s : c.color,
                distance: (n = a.dropShadowDistance) != null ? n : c.distance
            }
        }
        if (a.strokeThickness !== void 0) {
            let c = a.stroke
              , l = {};
            if (Ie.isColorLike(c))
                l.color = c;
            else if (c instanceof vi || c instanceof Rr)
                l.fill = c;
            else if (Object.hasOwnProperty.call(c, "color") || Object.hasOwnProperty.call(c, "fill"))
                l = c;
            else
                throw new Error("Invalid stroke value.");
            i.stroke = g3(Rt({}, l), {
                width: a.strokeThickness
            })
        }
        if (Array.isArray(a.fillGradientStops)) {
            if (!Array.isArray(a.fill) || a.fill.length === 0)
                throw new Error("Invalid fill value. Expected an array of colors for gradient fill.");
            a.fill.length,
            a.fillGradientStops.length;
            let c = new vi({
                start: {
                    x: 0,
                    y: 0
                },
                end: {
                    x: 0,
                    y: 1
                },
                textureSpace: "local"
            })
              , l = a.fillGradientStops.slice()
              , u = a.fill.map(d => Ie.shared.setValue(d).toNumber());
            l.forEach( (d, f) => {
                c.addColorStop(d, u[f])
            }
            ),
            i.fill = {
                fill: c
            }
        }
    }
    var x3 = new at;
    function z0(i, e, t, r) {
        let s = x3;
        s.minX = 0,
        s.minY = 0,
        s.maxX = i.width / r | 0,
        s.maxY = i.height / r | 0;
        let n = Qe.getOptimalTexture(s.width, s.height, r, !1);
        return n.source.uploadMethodId = "image",
        n.source.resource = i,
        n.source.alphaMode = "premultiply-alpha-on-upload",
        n.frame.width = e / r,
        n.frame.height = t / r,
        n.source.emit("update", n.source),
        n.updateUvs(),
        n
    }
    var yl = class {
        constructor(e) {
            this._canvasPool = Object.create(null),
            this.canvasOptions = e || {},
            this.enableFullScreen = !1
        }
        _createCanvasAndContext(e, t) {
            let r = xe.get().createCanvas();
            r.width = e,
            r.height = t;
            let s = r.getContext("2d");
            return {
                canvas: r,
                context: s
            }
        }
        getOptimalCanvasAndContext(e, t, r=1) {
            e = Math.ceil(e * r - 1e-6),
            t = Math.ceil(t * r - 1e-6),
            e = Sr(e),
            t = Sr(t);
            let s = (e << 17) + (t << 1);
            this._canvasPool[s] || (this._canvasPool[s] = []);
            let n = this._canvasPool[s].pop();
            return n || (n = this._createCanvasAndContext(e, t)),
            n
        }
        returnCanvasAndContext(e) {
            let t = e.canvas
              , {width: r, height: s} = t
              , n = (r << 17) + (s << 1);
            e.context.resetTransform(),
            e.context.clearRect(0, 0, r, s),
            this._canvasPool[n].push(e)
        }
        clear() {
            this._canvasPool = {}
        }
    }
      , Si = new yl;
    Cr.register(Si);
    var zi = null
      , pi = null;
    function y3(i, e) {
        zi || (zi = xe.get().createCanvas(256, 128),
        pi = zi.getContext("2d", {
            willReadFrequently: !0
        }),
        pi.globalCompositeOperation = "copy",
        pi.globalAlpha = 1),
        (zi.width < i || zi.height < e) && (zi.width = Sr(i),
        zi.height = Sr(e))
    }
    function af(i, e, t) {
        for (let r = 0, s = 4 * t * e; r < e; ++r,
        s += 4)
            if (i[s + 3] !== 0)
                return !1;
        return !0
    }
    function of(i, e, t, r, s) {
        let n = 4 * e;
        for (let a = r, c = r * n + 4 * t; a <= s; ++a,
        c += n)
            if (i[c + 3] !== 0)
                return !1;
        return !0
    }
    function v3(...i) {
        var e, t, r;
        let s = i[0];
        s.canvas || (s = {
            canvas: i[0],
            resolution: i[1]
        });
        let {canvas: n} = s
          , a = Math.min((e = s.resolution) != null ? e : 1, 1)
          , c = (t = s.width) != null ? t : n.width
          , l = (r = s.height) != null ? r : n.height
          , u = s.output;
        if (y3(c, l),
        !pi)
            throw new TypeError("Failed to get canvas 2D context");
        pi.drawImage(n, 0, 0, c, l, 0, 0, c * a, l * a);
        let d = pi.getImageData(0, 0, c, l).data
          , f = 0
          , b = 0
          , m = c - 1
          , x = l - 1;
        for (; b < l && af(d, c, b); )
            ++b;
        if (b === l)
            return Re.EMPTY;
        for (; af(d, c, x); )
            --x;
        for (; of(d, c, f, b, x); )
            ++f;
        for (; of(d, c, m, b, x); )
            --m;
        return ++m,
        ++x,
        pi.globalCompositeOperation = "source-over",
        pi.strokeRect(f, b, m - f, x - b),
        pi.globalCompositeOperation = "copy",
        u != null || (u = new Re),
        u.set(f / a, b / a, (m - f) / a, (x - b) / a),
        u
    }
    var vl = class {
        constructor(e=0, t=0, r=!1) {
            this.first = null,
            this.items = Object.create(null),
            this.last = null,
            this.max = e,
            this.resetTtl = r,
            this.size = 0,
            this.ttl = t
        }
        clear() {
            return this.first = null,
            this.items = Object.create(null),
            this.last = null,
            this.size = 0,
            this
        }
        delete(e) {
            if (this.has(e)) {
                let t = this.items[e];
                delete this.items[e],
                this.size--,
                t.prev !== null && (t.prev.next = t.next),
                t.next !== null && (t.next.prev = t.prev),
                this.first === t && (this.first = t.next),
                this.last === t && (this.last = t.prev)
            }
            return this
        }
        entries(e=this.keys()) {
            return e.map(t => [t, this.get(t)])
        }
        evict(e=!1) {
            if (e || this.size > 0) {
                let t = this.first;
                delete this.items[t.key],
                --this.size === 0 ? (this.first = null,
                this.last = null) : (this.first = t.next,
                this.first.prev = null)
            }
            return this
        }
        expiresAt(e) {
            let t;
            return this.has(e) && (t = this.items[e].expiry),
            t
        }
        get(e) {
            let t = this.items[e];
            if (t !== void 0) {
                if (this.ttl > 0 && t.expiry <= Date.now()) {
                    this.delete(e);
                    return
                }
                return this.moveToEnd(t),
                t.value
            }
        }
        has(e) {
            return e in this.items
        }
        moveToEnd(e) {
            this.last !== e && (e.prev !== null && (e.prev.next = e.next),
            e.next !== null && (e.next.prev = e.prev),
            this.first === e && (this.first = e.next),
            e.prev = this.last,
            e.next = null,
            this.last !== null && (this.last.next = e),
            this.last = e,
            this.first === null && (this.first = e))
        }
        keys() {
            let e = []
              , t = this.first;
            for (; t !== null; )
                e.push(t.key),
                t = t.next;
            return e
        }
        setWithEvicted(e, t, r=this.resetTtl) {
            let s = null;
            if (this.has(e))
                this.set(e, t, !0, r);
            else {
                this.max > 0 && this.size === this.max && (s = l1({}, this.first),
                this.evict(!0));
                let n = this.items[e] = {
                    expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
                    key: e,
                    prev: this.last,
                    next: null,
                    value: t
                };
                ++this.size === 1 ? this.first = n : this.last.next = n,
                this.last = n
            }
            return s
        }
        set(e, t, r=!1, s=this.resetTtl) {
            let n = this.items[e];
            return r || n !== void 0 ? (n.value = t,
            r === !1 && s && (n.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl),
            this.moveToEnd(n)) : (this.max > 0 && this.size === this.max && this.evict(!0),
            n = this.items[e] = {
                expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
                key: e,
                prev: this.last,
                next: null,
                value: t
            },
            ++this.size === 1 ? this.first = n : this.last.next = n,
            this.last = n),
            this
        }
        values(e=this.keys()) {
            return e.map(t => this.get(t))
        }
    }
    ;
    function V0(i=1e3, e=0, t=!1) {
        if (isNaN(i) || i < 0)
            throw new TypeError("Invalid max value");
        if (isNaN(e) || e < 0)
            throw new TypeError("Invalid ttl value");
        if (typeof t != "boolean")
            throw new TypeError("Invalid resetTtl value");
        return new vl(i,e,t)
    }
    var T3 = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"];
    function Xn(i) {
        let e = typeof i.fontSize == "number" ? `${i.fontSize}px` : i.fontSize
          , t = i.fontFamily;
        Array.isArray(i.fontFamily) || (t = i.fontFamily.split(","));
        for (let r = t.length - 1; r >= 0; r--) {
            let s = t[r].trim();
            !/([\"\'])[^\'\"]+\1/.test(s) && !T3.includes(s) && (s = `"${s}"`),
            t[r] = s
        }
        return `${i.fontStyle} ${i.fontVariant} ${i.fontWeight} ${e} ${t.join(",")}`
    }
    var tc = {
        willReadFrequently: !0
    }
      , Kt = class le {
        static get experimentalLetterSpacingSupported() {
            let e = le._experimentalLetterSpacingSupported;
            if (e === void 0) {
                let t = xe.get().getCanvasRenderingContext2D().prototype;
                e = le._experimentalLetterSpacingSupported = "letterSpacing"in t || "textLetterSpacing"in t
            }
            return e
        }
        constructor(e, t, r, s, n, a, c, l, u) {
            this.text = e,
            this.style = t,
            this.width = r,
            this.height = s,
            this.lines = n,
            this.lineWidths = a,
            this.lineHeight = c,
            this.maxLineWidth = l,
            this.fontProperties = u
        }
        static measureText(e=" ", t, r=le._canvas, s=t.wordWrap) {
            var n;
            let a = `${e}-${t.styleKey}-wordWrap-${s}`;
            if (le._measurementCache.has(a))
                return le._measurementCache.get(a);
            let c = Xn(t)
              , l = le.measureFont(c);
            l.fontSize === 0 && (l.fontSize = t.fontSize,
            l.ascent = t.fontSize);
            let u = le.__context;
            u.font = c;
            let d = (s ? le._wordWrap(e, t, r) : e).split(/(?:\r\n|\r|\n)/)
              , f = new Array(d.length)
              , b = 0;
            for (let E = 0; E < d.length; E++) {
                let O = le._measureText(d[E], t.letterSpacing, u);
                f[E] = O,
                b = Math.max(b, O)
            }
            let m = ((n = t._stroke) == null ? void 0 : n.width) || 0
              , x = b + m;
            t.dropShadow && (x += t.dropShadow.distance);
            let y = t.lineHeight || l.fontSize
              , S = Math.max(y, l.fontSize + m) + (d.length - 1) * (y + t.leading);
            t.dropShadow && (S += t.dropShadow.distance);
            let A = new le(e,t,x,S,d,f,y + t.leading,b,l);
            return le._measurementCache.set(a, A),
            A
        }
        static _measureText(e, t, r) {
            let s = !1;
            le.experimentalLetterSpacingSupported && (le.experimentalLetterSpacing ? (r.letterSpacing = `${t}px`,
            r.textLetterSpacing = `${t}px`,
            s = !0) : (r.letterSpacing = "0px",
            r.textLetterSpacing = "0px"));
            let n = r.measureText(e)
              , a = n.width
              , c = -n.actualBoundingBoxLeft
              , l = n.actualBoundingBoxRight - c;
            if (a > 0)
                if (s)
                    a -= t,
                    l -= t;
                else {
                    let u = (le.graphemeSegmenter(e).length - 1) * t;
                    a += u,
                    l += u
                }
            return Math.max(a, l)
        }
        static _wordWrap(e, t, r=le._canvas) {
            let s = r.getContext("2d", tc)
              , n = 0
              , a = ""
              , c = ""
              , l = Object.create(null)
              , {letterSpacing: u, whiteSpace: d} = t
              , f = le._collapseSpaces(d)
              , b = le._collapseNewlines(d)
              , m = !f
              , x = t.wordWrapWidth + u
              , y = le._tokenize(e);
            for (let S = 0; S < y.length; S++) {
                let A = y[S];
                if (le._isNewline(A)) {
                    if (!b) {
                        c += le._addLine(a),
                        m = !f,
                        a = "",
                        n = 0;
                        continue
                    }
                    A = " "
                }
                if (f) {
                    let O = le.isBreakingSpace(A)
                      , M = le.isBreakingSpace(a[a.length - 1]);
                    if (O && M)
                        continue
                }
                let E = le._getFromCache(A, u, l, s);
                if (E > x)
                    if (a !== "" && (c += le._addLine(a),
                    a = "",
                    n = 0),
                    le.canBreakWords(A, t.breakWords)) {
                        let O = le.wordWrapSplit(A);
                        for (let M = 0; M < O.length; M++) {
                            let j = O[M]
                              , L = j
                              , N = 1;
                            for (; O[M + N]; ) {
                                let ie = O[M + N];
                                if (!le.canBreakChars(L, ie, A, M, t.breakWords))
                                    j += ie;
                                else
                                    break;
                                L = ie,
                                N++
                            }
                            M += N - 1;
                            let Y = le._getFromCache(j, u, l, s);
                            Y + n > x && (c += le._addLine(a),
                            m = !1,
                            a = "",
                            n = 0),
                            a += j,
                            n += Y
                        }
                    } else {
                        a.length > 0 && (c += le._addLine(a),
                        a = "",
                        n = 0);
                        let O = S === y.length - 1;
                        c += le._addLine(A, !O),
                        m = !1,
                        a = "",
                        n = 0
                    }
                else
                    E + n > x && (m = !1,
                    c += le._addLine(a),
                    a = "",
                    n = 0),
                    (a.length > 0 || !le.isBreakingSpace(A) || m) && (a += A,
                    n += E)
            }
            return c += le._addLine(a, !1),
            c
        }
        static _addLine(e, t=!0) {
            return e = le._trimRight(e),
            e = t ? `${e}
` : e,
            e
        }
        static _getFromCache(e, t, r, s) {
            let n = r[e];
            return typeof n != "number" && (n = le._measureText(e, t, s) + t,
            r[e] = n),
            n
        }
        static _collapseSpaces(e) {
            return e === "normal" || e === "pre-line"
        }
        static _collapseNewlines(e) {
            return e === "normal"
        }
        static _trimRight(e) {
            if (typeof e != "string")
                return "";
            for (let t = e.length - 1; t >= 0; t--) {
                let r = e[t];
                if (!le.isBreakingSpace(r))
                    break;
                e = e.slice(0, -1)
            }
            return e
        }
        static _isNewline(e) {
            return typeof e != "string" ? !1 : le._newlines.includes(e.charCodeAt(0))
        }
        static isBreakingSpace(e, t) {
            return typeof e != "string" ? !1 : le._breakingSpaces.includes(e.charCodeAt(0))
        }
        static _tokenize(e) {
            let t = []
              , r = "";
            if (typeof e != "string")
                return t;
            for (let s = 0; s < e.length; s++) {
                let n = e[s]
                  , a = e[s + 1];
                if (le.isBreakingSpace(n, a) || le._isNewline(n)) {
                    r !== "" && (t.push(r),
                    r = ""),
                    n === "\r" && a === `
` ? (t.push(`\r
`),
                    s++) : t.push(n);
                    continue
                }
                r += n
            }
            return r !== "" && t.push(r),
            t
        }
        static canBreakWords(e, t) {
            return t
        }
        static canBreakChars(e, t, r, s, n) {
            return !0
        }
        static wordWrapSplit(e) {
            return le.graphemeSegmenter(e)
        }
        static measureFont(e) {
            if (le._fonts[e])
                return le._fonts[e];
            let t = le._context;
            t.font = e;
            let r = t.measureText(le.METRICS_STRING + le.BASELINE_SYMBOL)
              , s = {
                ascent: r.actualBoundingBoxAscent,
                descent: r.actualBoundingBoxDescent,
                fontSize: r.actualBoundingBoxAscent + r.actualBoundingBoxDescent
            };
            return le._fonts[e] = s,
            s
        }
        static clearMetrics(e="") {
            e ? delete le._fonts[e] : le._fonts = {}
        }
        static get _canvas() {
            if (!le.__canvas) {
                let e;
                try {
                    let t = new OffscreenCanvas(0,0)
                      , r = t.getContext("2d", tc);
                    if (r != null && r.measureText)
                        return le.__canvas = t,
                        t;
                    e = xe.get().createCanvas()
                } catch {
                    e = xe.get().createCanvas()
                }
                e.width = e.height = 10,
                le.__canvas = e
            }
            return le.__canvas
        }
        static get _context() {
            return le.__context || (le.__context = le._canvas.getContext("2d", tc)),
            le.__context
        }
    }
    ;
    Kt.METRICS_STRING = "|\xC9q\xC5",
    Kt.BASELINE_SYMBOL = "M",
    Kt.BASELINE_MULTIPLIER = 1.4,
    Kt.HEIGHT_MULTIPLIER = 2,
    Kt.graphemeSegmenter = ( () => {
        if (typeof Intl?.Segmenter == "function") {
            let i = new Intl.Segmenter;
            return e => {
                let t = i.segment(e)
                  , r = []
                  , s = 0;
                for (let n of t)
                    r[s++] = n.segment;
                return r
            }
        }
        return i => [...i]
    }
    )(),
    Kt.experimentalLetterSpacing = !1,
    Kt._fonts = {},
    Kt._newlines = [10, 13],
    Kt._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288],
    Kt._measurementCache = V0(1e3);
    var bt = Kt
      , cf = 1e5;
    function jn(i, e, t, r=0) {
        var s;
        if (i.texture === Z.WHITE && !i.fill)
            return Ie.shared.setValue(i.color).setAlpha((s = i.alpha) != null ? s : 1).toHexa();
        if (i.fill) {
            if (i.fill instanceof Rr) {
                let n = i.fill
                  , a = e.createPattern(n.texture.source.resource, "repeat")
                  , c = n.transform.copyTo(ce.shared);
                return c.scale(n.texture.frame.width, n.texture.frame.height),
                a.setTransform(c),
                a
            } else if (i.fill instanceof vi) {
                let n = i.fill
                  , a = n.type === "linear"
                  , c = n.textureSpace === "local"
                  , l = 1
                  , u = 1;
                c && t && (l = t.width + r,
                u = t.height + r);
                let d, f = !1;
                if (a) {
                    let {start: b, end: m} = n;
                    d = e.createLinearGradient(b.x * l, b.y * u, m.x * l, m.y * u),
                    f = Math.abs(m.x - b.x) < Math.abs((m.y - b.y) * .1)
                } else {
                    let {center: b, innerRadius: m, outerCenter: x, outerRadius: y} = n;
                    d = e.createRadialGradient(b.x * l, b.y * u, m * l, x.x * l, x.y * u, y * l)
                }
                if (f && c && t) {
                    let b = t.lineHeight / u;
                    for (let m = 0; m < t.lines.length; m++) {
                        let x = (m * t.lineHeight + r / 2) / u;
                        n.colorStops.forEach(y => {
                            let S = x + y.offset * b;
                            d.addColorStop(Math.floor(S * cf) / cf, Ie.shared.setValue(y.color).toHex())
                        }
                        )
                    }
                } else
                    n.colorStops.forEach(b => {
                        d.addColorStop(b.offset, Ie.shared.setValue(b.color).toHex())
                    }
                    );
                return d
            }
        } else {
            let n = e.createPattern(i.texture.source.resource, "repeat")
              , a = i.matrix.copyTo(ce.shared);
            return a.scale(i.texture.frame.width, i.texture.frame.height),
            n.setTransform(a),
            n
        }
        return "red"
    }
    var lf = new Re
      , S3 = class {
        getCanvasAndContext(i) {
            let {text: e, style: t, resolution: r=1} = i
              , s = t._getFinalPadding()
              , n = bt.measureText(e || " ", t)
              , a = Math.ceil(Math.ceil(Math.max(1, n.width) + s * 2) * r)
              , c = Math.ceil(Math.ceil(Math.max(1, n.height) + s * 2) * r)
              , l = Si.getOptimalCanvasAndContext(a, c);
            this._renderTextToCanvas(e, t, s, r, l);
            let u = t.trim ? v3({
                canvas: l.canvas,
                width: a,
                height: c,
                resolution: 1,
                output: lf
            }) : lf.set(0, 0, a, c);
            return {
                canvasAndContext: l,
                frame: u
            }
        }
        returnCanvasAndContext(i) {
            Si.returnCanvasAndContext(i)
        }
        _renderTextToCanvas(i, e, t, r, s) {
            var n, a, c, l, u;
            let {canvas: d, context: f} = s
              , b = Xn(e)
              , m = bt.measureText(i || " ", e)
              , x = m.lines
              , y = m.lineHeight
              , S = m.lineWidths
              , A = m.maxLineWidth
              , E = m.fontProperties
              , O = d.height;
            if (f.resetTransform(),
            f.scale(r, r),
            f.textBaseline = e.textBaseline,
            (n = e._stroke) != null && n.width) {
                let N = e._stroke;
                f.lineWidth = N.width,
                f.miterLimit = N.miterLimit,
                f.lineJoin = N.join,
                f.lineCap = N.cap
            }
            f.font = b;
            let M, j, L = e.dropShadow ? 2 : 1;
            for (let N = 0; N < L; ++N) {
                let Y = e.dropShadow && N === 0
                  , ie = Y ? Math.ceil(Math.max(1, O) + t * 2) : 0
                  , $ = ie * r;
                if (Y) {
                    f.fillStyle = "black",
                    f.strokeStyle = "black";
                    let Q = e.dropShadow
                      , pe = Q.color
                      , Be = Q.alpha;
                    f.shadowColor = Ie.shared.setValue(pe).setAlpha(Be).toRgbaString();
                    let ne = Q.blur * r
                      , se = Q.distance * r;
                    f.shadowBlur = ne,
                    f.shadowOffsetX = Math.cos(Q.angle) * se,
                    f.shadowOffsetY = Math.sin(Q.angle) * se + $
                } else {
                    if (f.fillStyle = e._fill ? jn(e._fill, f, m, t * 2) : null,
                    (a = e._stroke) != null && a.width) {
                        let Q = e._stroke.width * .5 + t * 2;
                        f.strokeStyle = jn(e._stroke, f, m, Q)
                    }
                    f.shadowColor = "black"
                }
                let J = (y - E.fontSize) / 2;
                y - E.fontSize < 0 && (J = 0);
                let re = (l = (c = e._stroke) == null ? void 0 : c.width) != null ? l : 0;
                for (let Q = 0; Q < x.length; Q++)
                    M = re / 2,
                    j = re / 2 + Q * y + E.ascent + J,
                    e.align === "right" ? M += A - S[Q] : e.align === "center" && (M += (A - S[Q]) / 2),
                    (u = e._stroke) != null && u.width && this._drawLetterSpacing(x[Q], e, s, M + t, j + t - ie, !0),
                    e._fill !== void 0 && this._drawLetterSpacing(x[Q], e, s, M + t, j + t - ie)
            }
        }
        _drawLetterSpacing(i, e, t, r, s, n=!1) {
            let {context: a} = t
              , c = e.letterSpacing
              , l = !1;
            if (bt.experimentalLetterSpacingSupported && (bt.experimentalLetterSpacing ? (a.letterSpacing = `${c}px`,
            a.textLetterSpacing = `${c}px`,
            l = !0) : (a.letterSpacing = "0px",
            a.textLetterSpacing = "0px")),
            c === 0 || l) {
                n ? a.strokeText(i, r, s) : a.fillText(i, r, s);
                return
            }
            let u = r
              , d = bt.graphemeSegmenter(i)
              , f = a.measureText(i).width
              , b = 0;
            for (let m = 0; m < d.length; ++m) {
                let x = d[m];
                n ? a.strokeText(x, u, s) : a.fillText(x, u, s);
                let y = "";
                for (let S = m + 1; S < d.length; ++S)
                    y += d[S];
                b = a.measureText(y).width,
                u += f - b + c,
                f = b
            }
        }
    }
      , cs = new S3
      , Hn = class {
        constructor(e) {
            this._activeTextures = {},
            this._renderer = e
        }
        getTexture(e, t, r, s) {
            var n;
            typeof e == "string" && (e = {
                text: e,
                style: r,
                resolution: t
            }),
            e.style instanceof Xt || (e.style = new Xt(e.style)),
            e.textureStyle instanceof Lt || (e.textureStyle = new Lt(e.textureStyle)),
            typeof e.text != "string" && (e.text = e.text.toString());
            let {text: a, style: c, textureStyle: l} = e
              , u = (n = e.resolution) != null ? n : this._renderer.resolution
              , {frame: d, canvasAndContext: f} = cs.getCanvasAndContext({
                text: a,
                style: c,
                resolution: u
            })
              , b = z0(f.canvas, d.width, d.height, u);
            if (l && (b.source.style = l),
            c.trim && (d.pad(c.padding),
            b.frame.copyFrom(d),
            b.frame.scale(1 / u),
            b.updateUvs()),
            c.filters) {
                let m = this._applyFilters(b, c.filters);
                return this.returnTexture(b),
                cs.returnCanvasAndContext(f),
                m
            }
            return this._renderer.texture.initSource(b._source),
            cs.returnCanvasAndContext(f),
            b
        }
        returnTexture(e) {
            let t = e.source;
            t.resource = null,
            t.uploadMethodId = "unknown",
            t.alphaMode = "no-premultiply-alpha",
            Qe.returnTexture(e, !0)
        }
        renderTextToCanvas() {}
        getManagedTexture(e) {
            e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution;
            let t = e.styleKey;
            if (this._activeTextures[t])
                return this._increaseReferenceCount(t),
                this._activeTextures[t].texture;
            let r = this.getTexture({
                text: e.text,
                style: e.style,
                resolution: e._resolution,
                textureStyle: e.textureStyle
            });
            return this._activeTextures[t] = {
                texture: r,
                usageCount: 1
            },
            r
        }
        decreaseReferenceCount(e) {
            let t = this._activeTextures[e];
            t.usageCount--,
            t.usageCount === 0 && (this.returnTexture(t.texture),
            this._activeTextures[e] = null)
        }
        getReferenceCount(e) {
            var t, r;
            return (r = (t = this._activeTextures[e]) == null ? void 0 : t.usageCount) != null ? r : null
        }
        _increaseReferenceCount(e) {
            this._activeTextures[e].usageCount++
        }
        _applyFilters(e, t) {
            let r = this._renderer.renderTarget.renderTarget
              , s = this._renderer.filter.generateFilteredTexture({
                texture: e,
                filters: t
            });
            return this._renderer.renderTarget.bind(r, !1),
            s
        }
        destroy() {
            this._renderer = null;
            for (let e in this._activeTextures)
                this._activeTextures[e] && this.returnTexture(this._activeTextures[e].texture);
            this._activeTextures = null
        }
    }
    ;
    Hn.extension = {
        type: [B.WebGLSystem, B.WebGPUSystem, B.CanvasSystem],
        name: "canvasText"
    },
    be.add(Hn),
    be.add(Un);
    var w3 = Object.defineProperty, zn = Object.getOwnPropertySymbols, W0 = Object.prototype.hasOwnProperty, Y0 = Object.prototype.propertyIsEnumerable, hf = (i, e, t) => e in i ? w3(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t, A3 = (i, e) => {
        for (var t in e || (e = {}))
            W0.call(e, t) && hf(i, t, e[t]);
        if (zn)
            for (var t of zn(e))
                Y0.call(e, t) && hf(i, t, e[t]);
        return i
    }
    , E3 = (i, e) => {
        var t = {};
        for (var r in i)
            W0.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && zn)
            for (var r of zn(i))
                e.indexOf(r) < 0 && Y0.call(i, r) && (t[r] = i[r]);
        return t
    }
    , Ke = class i extends _i {
        constructor(e) {
            e instanceof wt && (e = {
                context: e
            });
            let t = e || {}
              , {context: r, roundPixels: s} = t
              , n = E3(t, ["context", "roundPixels"]);
            super(A3({
                label: "Graphics"
            }, n)),
            this.renderPipeId = "graphics",
            r ? this._context = r : this._context = this._ownedContext = new wt,
            this._context.on("update", this.onViewUpdate, this),
            this.didViewUpdate = !0,
            this.allowChildren = !1,
            this.roundPixels = s ?? !1
        }
        set context(e) {
            e !== this._context && (this._context.off("update", this.onViewUpdate, this),
            this._context = e,
            this._context.on("update", this.onViewUpdate, this),
            this.onViewUpdate())
        }
        get context() {
            return this._context
        }
        get bounds() {
            return this._context.bounds
        }
        updateBounds() {}
        containsPoint(e) {
            return this._context.containsPoint(e)
        }
        destroy(e) {
            this._ownedContext && !e ? this._ownedContext.destroy(e) : (e === !0 || e?.context === !0) && this._context.destroy(e),
            this._ownedContext = null,
            this._context = null,
            super.destroy(e)
        }
        _callContextMethod(e, t) {
            return this.context[e](...t),
            this
        }
        setFillStyle(...e) {
            return this._callContextMethod("setFillStyle", e)
        }
        setStrokeStyle(...e) {
            return this._callContextMethod("setStrokeStyle", e)
        }
        fill(...e) {
            return this._callContextMethod("fill", e)
        }
        stroke(...e) {
            return this._callContextMethod("stroke", e)
        }
        texture(...e) {
            return this._callContextMethod("texture", e)
        }
        beginPath() {
            return this._callContextMethod("beginPath", [])
        }
        cut() {
            return this._callContextMethod("cut", [])
        }
        arc(...e) {
            return this._callContextMethod("arc", e)
        }
        arcTo(...e) {
            return this._callContextMethod("arcTo", e)
        }
        arcToSvg(...e) {
            return this._callContextMethod("arcToSvg", e)
        }
        bezierCurveTo(...e) {
            return this._callContextMethod("bezierCurveTo", e)
        }
        closePath() {
            return this._callContextMethod("closePath", [])
        }
        ellipse(...e) {
            return this._callContextMethod("ellipse", e)
        }
        circle(...e) {
            return this._callContextMethod("circle", e)
        }
        path(...e) {
            return this._callContextMethod("path", e)
        }
        lineTo(...e) {
            return this._callContextMethod("lineTo", e)
        }
        moveTo(...e) {
            return this._callContextMethod("moveTo", e)
        }
        quadraticCurveTo(...e) {
            return this._callContextMethod("quadraticCurveTo", e)
        }
        rect(...e) {
            return this._callContextMethod("rect", e)
        }
        roundRect(...e) {
            return this._callContextMethod("roundRect", e)
        }
        poly(...e) {
            return this._callContextMethod("poly", e)
        }
        regularPoly(...e) {
            return this._callContextMethod("regularPoly", e)
        }
        roundPoly(...e) {
            return this._callContextMethod("roundPoly", e)
        }
        roundShape(...e) {
            return this._callContextMethod("roundShape", e)
        }
        filletRect(...e) {
            return this._callContextMethod("filletRect", e)
        }
        chamferRect(...e) {
            return this._callContextMethod("chamferRect", e)
        }
        star(...e) {
            return this._callContextMethod("star", e)
        }
        svg(...e) {
            return this._callContextMethod("svg", e)
        }
        restore(...e) {
            return this._callContextMethod("restore", e)
        }
        save() {
            return this._callContextMethod("save", [])
        }
        getTransform() {
            return this.context.getTransform()
        }
        resetTransform() {
            return this._callContextMethod("resetTransform", [])
        }
        rotateTransform(...e) {
            return this._callContextMethod("rotate", e)
        }
        scaleTransform(...e) {
            return this._callContextMethod("scale", e)
        }
        setTransform(...e) {
            return this._callContextMethod("setTransform", e)
        }
        transform(...e) {
            return this._callContextMethod("transform", e)
        }
        translateTransform(...e) {
            return this._callContextMethod("translate", e)
        }
        clear() {
            return this._callContextMethod("clear", [])
        }
        get fillStyle() {
            return this._context.fillStyle
        }
        set fillStyle(e) {
            this._context.fillStyle = e
        }
        get strokeStyle() {
            return this._context.strokeStyle
        }
        set strokeStyle(e) {
            this._context.strokeStyle = e
        }
        clone(e=!1) {
            return e ? new i(this._context.clone()) : (this._ownedContext = null,
            new i(this._context))
        }
        lineStyle(e, t, r) {
            let s = {};
            return e && (s.width = e),
            t && (s.color = t),
            r && (s.alpha = r),
            this.context.strokeStyle = s,
            this
        }
        beginFill(e, t) {
            let r = {};
            return e !== void 0 && (r.color = e),
            t !== void 0 && (r.alpha = t),
            this.context.fillStyle = r,
            this
        }
        endFill() {
            this.context.fill();
            let e = this.context.strokeStyle;
            return (e.width !== wt.defaultStrokeStyle.width || e.color !== wt.defaultStrokeStyle.color || e.alpha !== wt.defaultStrokeStyle.alpha) && this.context.stroke(),
            this
        }
        drawCircle(...e) {
            return this._callContextMethod("circle", e)
        }
        drawEllipse(...e) {
            return this._callContextMethod("ellipse", e)
        }
        drawPolygon(...e) {
            return this._callContextMethod("poly", e)
        }
        drawRect(...e) {
            return this._callContextMethod("rect", e)
        }
        drawRoundedRect(...e) {
            return this._callContextMethod("roundRect", e)
        }
        drawStar(...e) {
            return this._callContextMethod("star", e)
        }
    }
    , P3 = {
        name: "local-uniform-msdf-bit",
        vertex: {
            header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
            main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
            end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        },
        fragment: {
            header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,
            main: `
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `
        }
    }, R3 = {
        name: "local-uniform-msdf-bit",
        vertex: {
            header: `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
            main: `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,
            end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        },
        fragment: {
            header: `
            uniform float uDistance;
         `,
            main: `
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `
        }
    }, M3 = {
        name: "msdf-bit",
        fragment: {
            header: `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {

                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;

            }
        `
        }
    }, C3 = {
        name: "msdf-bit",
        fragment: {
            header: `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {

                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);

                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);

                return coverage;
            }
        `
        }
    }, ic, rc, Tl = class extends At {
        constructor(e) {
            let t = new ct({
                uColor: {
                    value: new Float32Array([1, 1, 1, 1]),
                    type: "vec4<f32>"
                },
                uTransformMatrix: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uDistance: {
                    value: 4,
                    type: "f32"
                },
                uRound: {
                    value: 0,
                    type: "f32"
                }
            });
            ic != null || (ic = Ps({
                name: "sdf-shader",
                bits: [Rh, Ch(e), P3, M3, Ms]
            })),
            rc != null || (rc = Rs({
                name: "sdf-shader",
                bits: [Mh, Oh(e), R3, C3, Cs]
            })),
            super({
                glProgram: rc,
                gpuProgram: ic,
                resources: {
                    localUniforms: t,
                    batchSamplers: Ih(e)
                }
            })
        }
    }
    , Vn = class extends Ft {
        constructor() {
            super(...arguments),
            this.chars = Object.create(null),
            this.lineHeight = 0,
            this.fontFamily = "",
            this.fontMetrics = {
                fontSize: 0,
                ascent: 0,
                descent: 0
            },
            this.baseLineOffset = 0,
            this.distanceField = {
                type: "none",
                range: 0
            },
            this.pages = [],
            this.applyFillAsTint = !0,
            this.baseMeasurementFontSize = 100,
            this.baseRenderedFontSize = 100
        }
        get font() {
            return this.fontFamily
        }
        get pageTextures() {
            return this.pages
        }
        get size() {
            return this.fontMetrics.fontSize
        }
        get distanceFieldRange() {
            return this.distanceField.range
        }
        get distanceFieldType() {
            return this.distanceField.type
        }
        destroy(e=!1) {
            var t;
            this.emit("destroy", this),
            this.removeAllListeners();
            for (let r in this.chars)
                (t = this.chars[r].texture) == null || t.destroy();
            this.chars = null,
            e && (this.pages.forEach(r => r.texture.destroy(!0)),
            this.pages = null)
        }
    }
    , O3 = Object.defineProperty, uf = Object.getOwnPropertySymbols, I3 = Object.prototype.hasOwnProperty, G3 = Object.prototype.propertyIsEnumerable, df = (i, e, t) => e in i ? O3(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t, ff = (i, e) => {
        for (var t in e || (e = {}))
            I3.call(e, t) && df(i, t, e[t]);
        if (uf)
            for (var t of uf(e))
                G3.call(e, t) && df(i, t, e[t]);
        return i
    }
    , $0 = class K0 extends Vn {
        constructor(e) {
            var t, r, s;
            super(),
            this.resolution = 1,
            this.pages = [],
            this._padding = 0,
            this._measureCache = Object.create(null),
            this._currentChars = [],
            this._currentX = 0,
            this._currentY = 0,
            this._currentMaxCharHeight = 0,
            this._currentPageIndex = -1,
            this._skipKerning = !1;
            let n = ff(ff({}, K0.defaultOptions), e);
            this._textureSize = n.textureSize,
            this._mipmap = n.mipmap;
            let a = n.style.clone();
            n.overrideFill && (a._fill.color = 16777215,
            a._fill.alpha = 1,
            a._fill.texture = Z.WHITE,
            a._fill.fill = null),
            this.applyFillAsTint = n.overrideFill;
            let c = a.fontSize;
            a.fontSize = this.baseMeasurementFontSize;
            let l = Xn(a);
            n.overrideSize ? a._stroke && (a._stroke.width *= this.baseRenderedFontSize / c) : a.fontSize = this.baseRenderedFontSize = c,
            this._style = a,
            this._skipKerning = (t = n.skipKerning) != null ? t : !1,
            this.resolution = (r = n.resolution) != null ? r : 1,
            this._padding = (s = n.padding) != null ? s : 4,
            n.textureStyle && (this._textureStyle = n.textureStyle instanceof Lt ? n.textureStyle : new Lt(n.textureStyle)),
            this.fontMetrics = bt.measureFont(l),
            this.lineHeight = a.lineHeight || this.fontMetrics.fontSize || a.fontSize
        }
        ensureCharacters(e) {
            var t, r, s, n;
            let a = bt.graphemeSegmenter(e).filter(M => !this._currentChars.includes(M)).filter( (M, j, L) => L.indexOf(M) === j);
            if (!a.length)
                return;
            this._currentChars = [...this._currentChars, ...a];
            let c;
            this._currentPageIndex === -1 ? c = this._nextPage() : c = this.pages[this._currentPageIndex];
            let {canvas: l, context: u} = c.canvasAndContext
              , d = c.texture.source
              , f = this._style
              , b = this._currentX
              , m = this._currentY
              , x = this._currentMaxCharHeight
              , y = this.baseRenderedFontSize / this.baseMeasurementFontSize
              , S = this._padding * y
              , A = !1
              , E = l.width / this.resolution
              , O = l.height / this.resolution;
            for (let M = 0; M < a.length; M++) {
                let j = a[M]
                  , L = bt.measureText(j, f, l, !1);
                L.lineHeight = L.height;
                let N = L.width * y
                  , Y = Math.ceil((f.fontStyle === "italic" ? 2 : 1) * N)
                  , ie = L.height * y
                  , $ = Y + S * 2
                  , J = ie + S * 2;
                if (A = !1,
                j !== `
` && j !== "\r" && j !== "	" && j !== " " && (A = !0,
                x = Math.ceil(Math.max(J, x))),
                b + $ > E && (m += x,
                x = J,
                b = 0,
                m + x > O)) {
                    d.update();
                    let Q = this._nextPage();
                    l = Q.canvasAndContext.canvas,
                    u = Q.canvasAndContext.context,
                    d = Q.texture.source,
                    b = 0,
                    m = 0,
                    x = 0
                }
                let re = N / y - ((r = (t = f.dropShadow) == null ? void 0 : t.distance) != null ? r : 0) - ((n = (s = f._stroke) == null ? void 0 : s.width) != null ? n : 0);
                if (this.chars[j] = {
                    id: j.codePointAt(0),
                    xOffset: -this._padding,
                    yOffset: -this._padding,
                    xAdvance: re,
                    kerning: {}
                },
                A) {
                    this._drawGlyph(u, L, b + S, m + S, y, f);
                    let Q = d.width * y
                      , pe = d.height * y
                      , Be = new Re(b / Q * d.width,m / pe * d.height,$ / Q * d.width,J / pe * d.height);
                    this.chars[j].texture = new Z({
                        source: d,
                        frame: Be
                    }),
                    b += Math.ceil($)
                }
            }
            d.update(),
            this._currentX = b,
            this._currentY = m,
            this._currentMaxCharHeight = x,
            this._skipKerning && this._applyKerning(a, u)
        }
        get pageTextures() {
            return this.pages
        }
        _applyKerning(e, t) {
            let r = this._measureCache;
            for (let s = 0; s < e.length; s++) {
                let n = e[s];
                for (let a = 0; a < this._currentChars.length; a++) {
                    let c = this._currentChars[a]
                      , l = r[n];
                    l || (l = r[n] = t.measureText(n).width);
                    let u = r[c];
                    u || (u = r[c] = t.measureText(c).width);
                    let d = t.measureText(n + c).width
                      , f = d - (l + u);
                    f && (this.chars[n].kerning[c] = f),
                    d = t.measureText(n + c).width,
                    f = d - (l + u),
                    f && (this.chars[c].kerning[n] = f)
                }
            }
        }
        _nextPage() {
            this._currentPageIndex++;
            let e = this.resolution
              , t = Si.getOptimalCanvasAndContext(this._textureSize, this._textureSize, e);
            this._setupContext(t.context, this._style, e);
            let r = e * (this.baseRenderedFontSize / this.baseMeasurementFontSize)
              , s = new Z({
                source: new yi({
                    resource: t.canvas,
                    resolution: r,
                    alphaMode: "premultiply-alpha-on-upload",
                    autoGenerateMipmaps: this._mipmap
                })
            });
            this._textureStyle && (s.source.style = this._textureStyle);
            let n = {
                canvasAndContext: t,
                texture: s
            };
            return this.pages[this._currentPageIndex] = n,
            n
        }
        _setupContext(e, t, r) {
            var s;
            t.fontSize = this.baseRenderedFontSize,
            e.scale(r, r),
            e.font = Xn(t),
            t.fontSize = this.baseMeasurementFontSize,
            e.textBaseline = t.textBaseline;
            let n = t._stroke
              , a = (s = n?.width) != null ? s : 0;
            if (n && (e.lineWidth = a,
            e.lineJoin = n.join,
            e.miterLimit = n.miterLimit,
            e.strokeStyle = jn(n, e)),
            t._fill && (e.fillStyle = jn(t._fill, e)),
            t.dropShadow) {
                let c = t.dropShadow
                  , l = Ie.shared.setValue(c.color).toArray()
                  , u = c.blur * r
                  , d = c.distance * r;
                e.shadowColor = `rgba(${l[0] * 255},${l[1] * 255},${l[2] * 255},${c.alpha})`,
                e.shadowBlur = u,
                e.shadowOffsetX = Math.cos(c.angle) * d,
                e.shadowOffsetY = Math.sin(c.angle) * d
            } else
                e.shadowColor = "black",
                e.shadowBlur = 0,
                e.shadowOffsetX = 0,
                e.shadowOffsetY = 0
        }
        _drawGlyph(e, t, r, s, n, a) {
            var c;
            let l = t.text
              , u = t.fontProperties
              , d = a._stroke
              , f = ((c = d?.width) != null ? c : 0) * n
              , b = r + f / 2
              , m = s - f / 2
              , x = u.descent * n
              , y = t.lineHeight * n
              , S = !1;
            a.stroke && f && (S = !0,
            e.strokeText(l, b, m + y - x));
            let {shadowBlur: A, shadowOffsetX: E, shadowOffsetY: O} = e;
            a._fill && (S && (e.shadowBlur = 0,
            e.shadowOffsetX = 0,
            e.shadowOffsetY = 0),
            e.fillText(l, b, m + y - x)),
            S && (e.shadowBlur = A,
            e.shadowOffsetX = E,
            e.shadowOffsetY = O)
        }
        destroy() {
            super.destroy();
            for (let e = 0; e < this.pages.length; e++) {
                let {canvasAndContext: t, texture: r} = this.pages[e];
                Si.returnCanvasAndContext(t),
                r.destroy(!0)
            }
            this.pages = null
        }
    }
    ;
    $0.defaultOptions = {
        textureSize: 512,
        style: new Xt,
        mipmap: !0
    };
    var pf = $0;
    function Fh(i, e, t, r) {
        let s = {
            width: 0,
            height: 0,
            offsetY: 0,
            scale: e.fontSize / t.baseMeasurementFontSize,
            lines: [{
                width: 0,
                charPositions: [],
                spaceWidth: 0,
                spacesIndex: [],
                chars: []
            }]
        };
        s.offsetY = t.baseLineOffset;
        let n = s.lines[0]
          , a = null
          , c = !0
          , l = {
            spaceWord: !1,
            width: 0,
            start: 0,
            index: 0,
            positions: [],
            chars: []
        }
          , u = t.baseMeasurementFontSize / e.fontSize
          , d = e.letterSpacing * u
          , f = e.wordWrapWidth * u
          , b = e.lineHeight ? e.lineHeight * u : t.lineHeight
          , m = e.wordWrap && e.breakWords
          , x = A => {
            let E = n.width;
            for (let O = 0; O < l.index; O++) {
                let M = A.positions[O];
                n.chars.push(A.chars[O]),
                n.charPositions.push(M + E)
            }
            n.width += A.width,
            c = !1,
            l.width = 0,
            l.index = 0,
            l.chars.length = 0
        }
          , y = () => {
            let A = n.chars.length - 1;
            if (r) {
                let E = n.chars[A];
                for (; E === " "; )
                    n.width -= t.chars[E].xAdvance,
                    E = n.chars[--A]
            }
            s.width = Math.max(s.width, n.width),
            n = {
                width: 0,
                charPositions: [],
                chars: [],
                spaceWidth: 0,
                spacesIndex: []
            },
            c = !0,
            s.lines.push(n),
            s.height += b
        }
          , S = A => A - d > f;
        for (let A = 0; A < i.length + 1; A++) {
            let E, O = A === i.length;
            O || (E = i[A]);
            let M = t.chars[E] || t.chars[" "];
            if (/(?:\s)/.test(E) || E === "\r" || E === `
` || O) {
                if (!c && e.wordWrap && S(n.width + l.width) ? (y(),
                x(l),
                O || n.charPositions.push(0)) : (l.start = n.width,
                x(l),
                O || n.charPositions.push(0)),
                E === "\r" || E === `
`)
                    y();
                else if (!O) {
                    let j = M.xAdvance + (M.kerning[a] || 0) + d;
                    n.width += j,
                    n.spaceWidth = j,
                    n.spacesIndex.push(n.charPositions.length),
                    n.chars.push(E)
                }
            } else {
                let j = M.kerning[a] || 0
                  , L = M.xAdvance + j + d;
                m && S(n.width + l.width + L) && (x(l),
                y()),
                l.positions[l.index++] = l.width + j,
                l.chars.push(E),
                l.width += L
            }
            a = E
        }
        return y(),
        e.align === "center" ? B3(s) : e.align === "right" ? F3(s) : e.align === "justify" && D3(s),
        s
    }
    function B3(i) {
        for (let e = 0; e < i.lines.length; e++) {
            let t = i.lines[e]
              , r = i.width / 2 - t.width / 2;
            for (let s = 0; s < t.charPositions.length; s++)
                t.charPositions[s] += r
        }
    }
    function F3(i) {
        for (let e = 0; e < i.lines.length; e++) {
            let t = i.lines[e]
              , r = i.width - t.width;
            for (let s = 0; s < t.charPositions.length; s++)
                t.charPositions[s] += r
        }
    }
    function D3(i) {
        let e = i.width;
        for (let t = 0; t < i.lines.length; t++) {
            let r = i.lines[t]
              , s = 0
              , n = r.spacesIndex[s++]
              , a = 0
              , c = r.spacesIndex.length
              , l = (e - r.width) / c;
            for (let u = 0; u < r.charPositions.length; u++)
                u === n && (n = r.spacesIndex[s++],
                a += l),
                r.charPositions[u] += a
        }
    }
    function k3(i) {
        if (i === "")
            return [];
        typeof i == "string" && (i = [i]);
        let e = [];
        for (let t = 0, r = i.length; t < r; t++) {
            let s = i[t];
            if (Array.isArray(s)) {
                if (s.length !== 2)
                    throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${s.length}.`);
                if (s[0].length === 0 || s[1].length === 0)
                    throw new Error("[BitmapFont]: Invalid character delimiter.");
                let n = s[0].charCodeAt(0)
                  , a = s[1].charCodeAt(0);
                if (a < n)
                    throw new Error("[BitmapFont]: Invalid character range.");
                for (let c = n, l = a; c <= l; c++)
                    e.push(String.fromCharCode(c))
            } else
                e.push(...Array.from(s))
        }
        if (e.length === 0)
            throw new Error("[BitmapFont]: Empty set when resolving characters.");
        return e
    }
    var U3 = Object.defineProperty
      , bf = Object.getOwnPropertySymbols
      , L3 = Object.prototype.hasOwnProperty
      , N3 = Object.prototype.propertyIsEnumerable
      , mf = (i, e, t) => e in i ? U3(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , sc = (i, e) => {
        for (var t in e || (e = {}))
            L3.call(e, t) && mf(i, t, e[t]);
        if (bf)
            for (var t of bf(e))
                N3.call(e, t) && mf(i, t, e[t]);
        return i
    }
      , Ks = 0
      , X3 = class {
        constructor() {
            this.ALPHA = [["a", "z"], ["A", "Z"], " "],
            this.NUMERIC = [["0", "9"]],
            this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "],
            this.ASCII = [[" ", "~"]],
            this.defaultOptions = {
                chars: this.ALPHANUMERIC,
                resolution: 1,
                padding: 4,
                skipKerning: !1,
                textureStyle: null
            },
            this.measureCache = V0(1e3)
        }
        getFont(i, e) {
            var t;
            let r = `${e.fontFamily}-bitmap`
              , s = !0;
            if (e._fill.fill && !e._stroke ? (r += e._fill.fill.styleKey,
            s = !1) : (e._stroke || e.dropShadow) && (r = `${e.styleKey}-bitmap`,
            s = !1),
            !Oe.has(r)) {
                let a = Object.create(e);
                a.lineHeight = 0;
                let c = new pf(sc({
                    style: a,
                    overrideFill: s,
                    overrideSize: !0
                }, this.defaultOptions));
                Ks++,
                Ks > 50 && Ti("BitmapText", `You have dynamically created ${Ks} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``),
                c.once("destroy", () => {
                    Ks--,
                    Oe.remove(r)
                }
                ),
                Oe.set(r, c)
            }
            let n = Oe.get(r);
            return (t = n.ensureCharacters) == null || t.call(n, i),
            n
        }
        getLayout(i, e, t=!0) {
            let r = this.getFont(i, e)
              , s = `${i}-${e.styleKey}-${t}`;
            if (this.measureCache.has(s))
                return this.measureCache.get(s);
            let n = bt.graphemeSegmenter(i)
              , a = Fh(n, e, r, t);
            return this.measureCache.set(s, a),
            a
        }
        measureText(i, e, t=!0) {
            return this.getLayout(i, e, t)
        }
        install(...i) {
            var e, t, r, s, n;
            let a = i[0];
            typeof a == "string" && (a = {
                name: a,
                style: i[1],
                chars: (e = i[2]) == null ? void 0 : e.chars,
                resolution: (t = i[2]) == null ? void 0 : t.resolution,
                padding: (r = i[2]) == null ? void 0 : r.padding,
                skipKerning: (s = i[2]) == null ? void 0 : s.skipKerning
            });
            let c = a?.name;
            if (!c)
                throw new Error("[BitmapFontManager] Property `name` is required.");
            a = sc(sc({}, this.defaultOptions), a);
            let l = a.style
              , u = l instanceof Xt ? l : new Xt(l)
              , d = (n = a.dynamicFill) != null ? n : this._canUseTintForStyle(u)
              , f = new pf({
                style: u,
                overrideFill: d,
                skipKerning: a.skipKerning,
                padding: a.padding,
                resolution: a.resolution,
                overrideSize: !1,
                textureStyle: a.textureStyle
            })
              , b = k3(a.chars);
            return f.ensureCharacters(b.join("")),
            Oe.set(`${c}-bitmap`, f),
            f.once("destroy", () => Oe.remove(`${c}-bitmap`)),
            f
        }
        uninstall(i) {
            let e = `${i}-bitmap`
              , t = Oe.get(e);
            t && t.destroy()
        }
        _canUseTintForStyle(i) {
            return !i._stroke && (!i.dropShadow || i.dropShadow.color === 0) && !i._fill.fill && i._fill.color === 16777215
        }
    }
      , Ts = new X3
      , Sl = class extends Ke {
        destroy() {
            this.context.customShader && this.context.customShader.destroy(),
            super.destroy()
        }
    }
      , Wn = class {
        constructor(e) {
            this._renderer = e
        }
        validateRenderable(e) {
            let t = this._getGpuBitmapText(e);
            return this._renderer.renderPipes.graphics.validateRenderable(t)
        }
        addRenderable(e, t) {
            let r = this._getGpuBitmapText(e);
            gf(e, r),
            e._didTextUpdate && (e._didTextUpdate = !1,
            this._updateContext(e, r)),
            this._renderer.renderPipes.graphics.addRenderable(r, t),
            r.context.customShader && this._updateDistanceField(e)
        }
        updateRenderable(e) {
            let t = this._getGpuBitmapText(e);
            gf(e, t),
            this._renderer.renderPipes.graphics.updateRenderable(t),
            t.context.customShader && this._updateDistanceField(e)
        }
        _updateContext(e, t) {
            let {context: r} = t
              , s = Ts.getFont(e.text, e._style);
            r.clear(),
            s.distanceField.type !== "none" && (r.customShader || (r.customShader = new Tl(this._renderer.limits.maxBatchableTextures)));
            let n = bt.graphemeSegmenter(e.text)
              , a = e._style
              , c = s.baseLineOffset
              , l = Fh(n, a, s, !0)
              , u = a.padding
              , d = l.scale
              , f = l.width
              , b = l.height + l.offsetY;
            a._stroke && (f += a._stroke.width / d,
            b += a._stroke.width / d),
            r.translate(-e._anchor._x * f - u, -e._anchor._y * b - u).scale(d, d);
            let m = s.applyFillAsTint ? a._fill.color : 16777215
              , x = s.fontMetrics.fontSize
              , y = s.lineHeight;
            a.lineHeight && (x = a.fontSize / d,
            y = a.lineHeight / d);
            let S = (y - x) / 2;
            S - s.baseLineOffset < 0 && (S = 0);
            for (let A = 0; A < l.lines.length; A++) {
                let E = l.lines[A];
                for (let O = 0; O < E.charPositions.length; O++) {
                    let M = E.chars[O]
                      , j = s.chars[M];
                    if (j != null && j.texture) {
                        let L = j.texture;
                        r.texture(L, m || "black", Math.round(E.charPositions[O] + j.xOffset), Math.round(c + j.yOffset + S), L.orig.width, L.orig.height)
                    }
                }
                c += y
            }
        }
        _getGpuBitmapText(e) {
            return e._gpuData[this._renderer.uid] || this.initGpuText(e)
        }
        initGpuText(e) {
            let t = new Sl;
            return e._gpuData[this._renderer.uid] = t,
            this._updateContext(e, t),
            t
        }
        _updateDistanceField(e) {
            let t = this._getGpuBitmapText(e).context
              , r = e._style.fontFamily
              , s = Oe.get(`${r}-bitmap`)
              , {a: n, b: a, c, d: l} = e.groupTransform
              , u = Math.sqrt(n * n + a * a)
              , d = Math.sqrt(c * c + l * l)
              , f = (Math.abs(u) + Math.abs(d)) / 2
              , b = s.baseRenderedFontSize / e._style.fontSize
              , m = f * s.distanceField.range * (1 / b);
            t.customShader.resources.localUniforms.uniforms.uDistance = m
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    Wn.extension = {
        type: [B.WebGLPipes, B.WebGPUPipes, B.CanvasPipes],
        name: "bitmapText"
    };
    function gf(i, e) {
        e.groupTransform = i.groupTransform,
        e.groupColorAlpha = i.groupColorAlpha,
        e.groupColor = i.groupColor,
        e.groupBlendMode = i.groupBlendMode,
        e.globalDisplayStatus = i.globalDisplayStatus,
        e.groupTransform = i.groupTransform,
        e.localDisplayStatus = i.localDisplayStatus,
        e.groupAlpha = i.groupAlpha,
        e._roundPixels = i._roundPixels
    }
    be.add(Wn);
    var wl = class extends Pr {
        constructor(e) {
            super(),
            this.generatingTexture = !1,
            this.currentKey = "--",
            this._renderer = e,
            e.runners.resolutionChange.add(this)
        }
        resolutionChange() {
            let e = this.renderable;
            e._autoResolution && e.onViewUpdate()
        }
        destroy() {
            let {htmlText: e} = this._renderer;
            e.getReferenceCount(this.currentKey) === null ? e.returnTexturePromise(this.texturePromise) : e.decreaseReferenceCount(this.currentKey),
            this._renderer.runners.resolutionChange.remove(this),
            this.texturePromise = null,
            this._renderer = null
        }
    }
      , Yn = class {
        constructor(e) {
            this._renderer = e
        }
        validateRenderable(e) {
            let t = this._getGpuText(e)
              , r = e.styleKey;
            return t.currentKey !== r
        }
        addRenderable(e, t) {
            let r = this._getGpuText(e);
            if (e._didTextUpdate) {
                let s = e._autoResolution ? this._renderer.resolution : e.resolution;
                (r.currentKey !== e.styleKey || e.resolution !== s) && this._updateGpuText(e).catch(n => {}
                ),
                e._didTextUpdate = !1,
                hl(r, e)
            }
            this._renderer.renderPipes.batch.addToBatch(r, t)
        }
        updateRenderable(e) {
            let t = this._getGpuText(e);
            t._batcher.updateElement(t)
        }
        async _updateGpuText(e) {
            e._didTextUpdate = !1;
            let t = this._getGpuText(e);
            if (t.generatingTexture)
                return;
            let r = t.texturePromise;
            t.texturePromise = null,
            t.generatingTexture = !0,
            e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution;
            let s = this._renderer.htmlText.getTexturePromise(e);
            r && (s = s.finally( () => {
                this._renderer.htmlText.decreaseReferenceCount(t.currentKey),
                this._renderer.htmlText.returnTexturePromise(r)
            }
            )),
            t.texturePromise = s,
            t.currentKey = e.styleKey,
            t.texture = await s;
            let n = e.renderGroup || e.parentRenderGroup;
            n && (n.structureDidChange = !0),
            t.generatingTexture = !1,
            hl(t, e)
        }
        _getGpuText(e) {
            return e._gpuData[this._renderer.uid] || this.initGpuText(e)
        }
        initGpuText(e) {
            let t = new wl(this._renderer);
            return t.renderable = e,
            t.transform = e.groupTransform,
            t.texture = Z.EMPTY,
            t.bounds = {
                minX: 0,
                maxX: 1,
                minY: 0,
                maxY: 0
            },
            t.roundPixels = this._renderer._roundPixels | e._roundPixels,
            e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution,
            e._gpuData[this._renderer.uid] = t,
            t
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    Yn.extension = {
        type: [B.WebGLPipes, B.WebGPUPipes, B.CanvasPipes],
        name: "htmlText"
    };
    function j3() {
        let {userAgent: i} = xe.get().getNavigator();
        return /^((?!chrome|android).)*safari/i.test(i)
    }
    var _f = "http://www.w3.org/2000/svg"
      , xf = "http://www.w3.org/1999/xhtml"
      , $n = class {
        constructor() {
            this.svgRoot = document.createElementNS(_f, "svg"),
            this.foreignObject = document.createElementNS(_f, "foreignObject"),
            this.domElement = document.createElementNS(xf, "div"),
            this.styleElement = document.createElementNS(xf, "style");
            let {foreignObject: e, svgRoot: t, styleElement: r, domElement: s} = this;
            e.setAttribute("width", "10000"),
            e.setAttribute("height", "10000"),
            e.style.overflow = "hidden",
            t.appendChild(e),
            e.appendChild(r),
            e.appendChild(s),
            this.image = xe.get().createImage()
        }
        destroy() {
            this.svgRoot.remove(),
            this.foreignObject.remove(),
            this.styleElement.remove(),
            this.domElement.remove(),
            this.image.src = "",
            this.image.remove(),
            this.svgRoot = null,
            this.foreignObject = null,
            this.styleElement = null,
            this.domElement = null,
            this.image = null,
            this.canvasAndContext = null
        }
    }
    ;
    function H3(i, e) {
        let t = e.fontFamily
          , r = []
          , s = {}
          , n = /font-family:([^;"\s]+)/g
          , a = i.match(n);
        function c(l) {
            s[l] || (r.push(l),
            s[l] = !0)
        }
        if (Array.isArray(t))
            for (let l = 0; l < t.length; l++)
                c(t[l]);
        else
            c(t);
        a && a.forEach(l => {
            let u = l.split(":")[1].trim();
            c(u)
        }
        );
        for (let l in e.tagStyles) {
            let u = e.tagStyles[l].fontFamily;
            c(u)
        }
        return r
    }
    async function z3(i) {
        let e = await (await xe.get().fetch(i)).blob()
          , t = new FileReader;
        return await new Promise( (r, s) => {
            t.onloadend = () => r(t.result),
            t.onerror = s,
            t.readAsDataURL(e)
        }
        )
    }
    async function V3(i, e) {
        let t = await z3(e);
        return `@font-face {
        font-family: "${i.fontFamily}";
        font-weight: ${i.fontWeight};
        font-style: ${i.fontStyle};
        src: url('${t}');
    }`
    }
    var nc = new Map;
    async function W3(i) {
        let e = i.filter(t => Oe.has(`${t}-and-url`)).map(t => {
            if (!nc.has(t)) {
                let {entries: r} = Oe.get(`${t}-and-url`)
                  , s = [];
                r.forEach(n => {
                    let a = n.url
                      , c = n.faces.map(l => ({
                        weight: l.weight,
                        style: l.style
                    }));
                    s.push(...c.map(l => V3({
                        fontWeight: l.weight,
                        fontStyle: l.style,
                        fontFamily: t
                    }, a)))
                }
                ),
                nc.set(t, Promise.all(s).then(n => n.join(`
`)))
            }
            return nc.get(t)
        }
        );
        return (await Promise.all(e)).join(`
`)
    }
    function Y3(i, e, t, r, s) {
        let {domElement: n, styleElement: a, svgRoot: c} = s;
        n.innerHTML = `<style>${e.cssStyle}</style><div style='padding:0;'>${i}</div>`,
        n.setAttribute("style", `transform: scale(${t});transform-origin: top left; display: inline-block`),
        a.textContent = r;
        let {width: l, height: u} = s.image;
        return c.setAttribute("width", l.toString()),
        c.setAttribute("height", u.toString()),
        new XMLSerializer().serializeToString(c)
    }
    function $3(i, e) {
        let t = Si.getOptimalCanvasAndContext(i.width, i.height, e)
          , {context: r} = t;
        return r.clearRect(0, 0, i.width, i.height),
        r.drawImage(i, 0, 0),
        t
    }
    function K3(i, e, t) {
        return new Promise(async r => {
            t && await new Promise(s => setTimeout(s, 100)),
            i.onload = () => {
                r()
            }
            ,
            i.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(e)}`,
            i.crossOrigin = "anonymous"
        }
        )
    }
    var yf;
    function q0(i, e, t, r) {
        r || (r = yf || (yf = new $n));
        let {domElement: s, styleElement: n, svgRoot: a} = r;
        s.innerHTML = `<style>${e.cssStyle};</style><div style='padding:0'>${i}</div>`,
        s.setAttribute("style", "transform-origin: top left; display: inline-block"),
        t && (n.textContent = t),
        document.body.appendChild(a);
        let c = s.getBoundingClientRect();
        a.remove();
        let l = e.padding * 2;
        return {
            width: c.width - l,
            height: c.height - l
        }
    }
    var Kn = class {
        constructor(e) {
            this._activeTextures = {},
            this._renderer = e,
            this._createCanvas = e.type === Bt.WEBGPU
        }
        getTexture(e) {
            return this.getTexturePromise(e)
        }
        getManagedTexture(e) {
            let t = e.styleKey;
            if (this._activeTextures[t])
                return this._increaseReferenceCount(t),
                this._activeTextures[t].promise;
            let r = this._buildTexturePromise(e).then(s => (this._activeTextures[t].texture = s,
            s));
            return this._activeTextures[t] = {
                texture: null,
                promise: r,
                usageCount: 1
            },
            r
        }
        getReferenceCount(e) {
            var t, r;
            return (r = (t = this._activeTextures[e]) == null ? void 0 : t.usageCount) != null ? r : null
        }
        _increaseReferenceCount(e) {
            this._activeTextures[e].usageCount++
        }
        decreaseReferenceCount(e) {
            let t = this._activeTextures[e];
            t && (t.usageCount--,
            t.usageCount === 0 && (t.texture ? this._cleanUp(t.texture) : t.promise.then(r => {
                t.texture = r,
                this._cleanUp(t.texture)
            }
            ).catch( () => {}
            ),
            this._activeTextures[e] = null))
        }
        getTexturePromise(e) {
            return this._buildTexturePromise(e)
        }
        async _buildTexturePromise(e) {
            let {text: t, style: r, resolution: s, textureStyle: n} = e
              , a = et.get($n)
              , c = H3(t, r)
              , l = await W3(c)
              , u = q0(t, r, l, a)
              , d = Math.ceil(Math.ceil(Math.max(1, u.width) + r.padding * 2) * s)
              , f = Math.ceil(Math.ceil(Math.max(1, u.height) + r.padding * 2) * s)
              , b = a.image
              , m = 2;
            b.width = (d | 0) + m,
            b.height = (f | 0) + m;
            let x = Y3(t, r, s, l, a);
            await K3(b, x, j3() && c.length > 0);
            let y = b, S;
            this._createCanvas && (S = $3(b, s));
            let A = z0(S ? S.canvas : y, b.width - m, b.height - m, s);
            return n && (A.source.style = n),
            this._createCanvas && (this._renderer.texture.initSource(A.source),
            Si.returnCanvasAndContext(S)),
            et.return(a),
            A
        }
        returnTexturePromise(e) {
            e.then(t => {
                this._cleanUp(t)
            }
            ).catch( () => {}
            )
        }
        _cleanUp(e) {
            Qe.returnTexture(e, !0),
            e.source.resource = null,
            e.source.uploadMethodId = "unknown"
        }
        destroy() {
            this._renderer = null;
            for (let e in this._activeTextures)
                this._activeTextures[e] && this.returnTexturePromise(this._activeTextures[e].promise);
            this._activeTextures = null
        }
    }
    ;
    Kn.extension = {
        type: [B.WebGLSystem, B.WebGPUSystem, B.CanvasSystem],
        name: "htmlText"
    },
    be.add(Kn),
    be.add(Yn);
    var q3 = Object.defineProperty
      , vf = Object.getOwnPropertySymbols
      , Z3 = Object.prototype.hasOwnProperty
      , Q3 = Object.prototype.propertyIsEnumerable
      , Tf = (i, e, t) => e in i ? q3(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Sf = (i, e) => {
        for (var t in e || (e = {}))
            Z3.call(e, t) && Tf(i, t, e[t]);
        if (vf)
            for (var t of vf(e))
                Q3.call(e, t) && Tf(i, t, e[t]);
        return i
    }
      , Z0 = class Q0 extends oi {
        constructor(...e) {
            var t;
            let r = (t = e[0]) != null ? t : {};
            r instanceof Float32Array && (r = {
                positions: r,
                uvs: e[1],
                indices: e[2]
            }),
            r = Sf(Sf({}, Q0.defaultOptions), r);
            let s = r.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])
              , n = r.uvs;
            n || (r.positions ? n = new Float32Array(s.length) : n = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]));
            let a = r.indices || new Uint32Array([0, 1, 2, 0, 2, 3])
              , c = r.shrinkBuffersToFit
              , l = new gt({
                data: s,
                label: "attribute-mesh-positions",
                shrinkToFit: c,
                usage: Ae.VERTEX | Ae.COPY_DST
            })
              , u = new gt({
                data: n,
                label: "attribute-mesh-uvs",
                shrinkToFit: c,
                usage: Ae.VERTEX | Ae.COPY_DST
            })
              , d = new gt({
                data: a,
                label: "index-mesh-buffer",
                shrinkToFit: c,
                usage: Ae.INDEX | Ae.COPY_DST
            });
            super({
                attributes: {
                    aPosition: {
                        buffer: l,
                        format: "float32x2",
                        stride: 8,
                        offset: 0
                    },
                    aUV: {
                        buffer: u,
                        format: "float32x2",
                        stride: 8,
                        offset: 0
                    }
                },
                indexBuffer: d,
                topology: r.topology
            }),
            this.batchMode = "auto"
        }
        get positions() {
            return this.attributes.aPosition.buffer.data
        }
        set positions(e) {
            this.attributes.aPosition.buffer.data = e
        }
        get uvs() {
            return this.attributes.aUV.buffer.data
        }
        set uvs(e) {
            this.attributes.aUV.buffer.data = e
        }
        get indices() {
            return this.indexBuffer.data
        }
        set indices(e) {
            this.indexBuffer.data = e
        }
    }
    ;
    Z0.defaultOptions = {
        topology: "triangle-list",
        shrinkBuffersToFit: !1
    };
    var Is = Z0, J3 = Object.defineProperty, ev = Object.defineProperties, tv = Object.getOwnPropertyDescriptors, wf = Object.getOwnPropertySymbols, iv = Object.prototype.hasOwnProperty, rv = Object.prototype.propertyIsEnumerable, Af = (i, e, t) => e in i ? J3(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t, Ef = (i, e) => {
        for (var t in e || (e = {}))
            iv.call(e, t) && Af(i, t, e[t]);
        if (wf)
            for (var t of wf(e))
                rv.call(e, t) && Af(i, t, e[t]);
        return i
    }
    , Pf = (i, e) => ev(i, tv(e)), ls = {
        name: "local-uniform-bit",
        vertex: {
            header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
            main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
            end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        }
    }, sv = Pf(Ef({}, ls), {
        vertex: Pf(Ef({}, ls.vertex), {
            header: ls.vertex.header.replace("group(1)", "group(2)")
        })
    }), Dh = {
        name: "local-uniform-bit",
        vertex: {
            header: `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
            main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,
            end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        }
    }, nv = {
        name: "tiling-bit",
        vertex: {
            header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
            main: `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
        },
        fragment: {
            header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
            main: `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            }

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
        }
    }, av = {
        name: "tiling-bit",
        vertex: {
            header: `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;

        `,
            main: `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
        },
        fragment: {
            header: `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,
            main: `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0

        `
        }
    }, ac, oc, Al = class extends At {
        constructor() {
            ac != null || (ac = Ps({
                name: "tiling-sprite-shader",
                bits: [ls, nv, Ms]
            })),
            oc != null || (oc = Rs({
                name: "tiling-sprite-shader",
                bits: [Dh, av, Cs]
            }));
            let e = new ct({
                uMapCoord: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uClampFrame: {
                    value: new Float32Array([0, 0, 1, 1]),
                    type: "vec4<f32>"
                },
                uClampOffset: {
                    value: new Float32Array([0, 0]),
                    type: "vec2<f32>"
                },
                uTextureTransform: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uSizeAnchor: {
                    value: new Float32Array([100, 100, .5, .5]),
                    type: "vec4<f32>"
                }
            });
            super({
                glProgram: oc,
                gpuProgram: ac,
                resources: {
                    localUniforms: new ct({
                        uTransformMatrix: {
                            value: new ce,
                            type: "mat3x3<f32>"
                        },
                        uColor: {
                            value: new Float32Array([1, 1, 1, 1]),
                            type: "vec4<f32>"
                        },
                        uRound: {
                            value: 0,
                            type: "f32"
                        }
                    }),
                    tilingUniforms: e,
                    uTexture: Z.EMPTY.source,
                    uSampler: Z.EMPTY.source.style
                }
            })
        }
        updateUniforms(e, t, r, s, n, a) {
            let c = this.resources.tilingUniforms
              , l = a.width
              , u = a.height
              , d = a.textureMatrix
              , f = c.uniforms.uTextureTransform;
            f.set(r.a * l / e, r.b * l / t, r.c * u / e, r.d * u / t, r.tx / e, r.ty / t),
            f.invert(),
            c.uniforms.uMapCoord = d.mapCoord,
            c.uniforms.uClampFrame = d.uClampFrame,
            c.uniforms.uClampOffset = d.uClampOffset,
            c.uniforms.uTextureTransform = f,
            c.uniforms.uSizeAnchor[0] = e,
            c.uniforms.uSizeAnchor[1] = t,
            c.uniforms.uSizeAnchor[2] = s,
            c.uniforms.uSizeAnchor[3] = n,
            a && (this.resources.uTexture = a.source,
            this.resources.uSampler = a.source.style)
        }
    }
    , El = class extends Is {
        constructor() {
            super({
                positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
                uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
                indices: new Uint32Array([0, 1, 2, 0, 2, 3])
            })
        }
    }
    ;
    function ov(i, e) {
        let t = i.anchor.x
          , r = i.anchor.y;
        e[0] = -t * i.width,
        e[1] = -r * i.height,
        e[2] = (1 - t) * i.width,
        e[3] = -r * i.height,
        e[4] = (1 - t) * i.width,
        e[5] = (1 - r) * i.height,
        e[6] = -t * i.width,
        e[7] = (1 - r) * i.height
    }
    function cv(i, e, t, r) {
        let s = 0
          , n = i.length / (e || 2)
          , a = r.a
          , c = r.b
          , l = r.c
          , u = r.d
          , d = r.tx
          , f = r.ty;
        for (t *= e; s < n; ) {
            let b = i[t]
              , m = i[t + 1];
            i[t] = a * b + l * m + d,
            i[t + 1] = c * b + u * m + f,
            t += e,
            s++
        }
    }
    function lv(i, e) {
        let t = i.texture
          , r = t.frame.width
          , s = t.frame.height
          , n = 0
          , a = 0;
        i.applyAnchorToTexture && (n = i.anchor.x,
        a = i.anchor.y),
        e[0] = e[6] = -n,
        e[2] = e[4] = 1 - n,
        e[1] = e[3] = -a,
        e[5] = e[7] = 1 - a;
        let c = ce.shared;
        c.copyFrom(i._tileTransform.matrix),
        c.tx /= i.width,
        c.ty /= i.height,
        c.invert(),
        c.scale(i.width / r, i.height / s),
        cv(e, 2, 0, c)
    }
    var cn = new El
      , Pl = class {
        constructor() {
            this.canBatch = !0,
            this.geometry = new Is({
                indices: cn.indices.slice(),
                positions: cn.positions.slice(),
                uvs: cn.uvs.slice()
            })
        }
        destroy() {
            var e;
            this.geometry.destroy(),
            (e = this.shader) == null || e.destroy()
        }
    }
      , qn = class {
        constructor(e) {
            this._state = Nt.default2d,
            this._renderer = e
        }
        validateRenderable(e) {
            let t = this._getTilingSpriteData(e)
              , r = t.canBatch;
            this._updateCanBatch(e);
            let s = t.canBatch;
            if (s && s === r) {
                let {batchableMesh: n} = t;
                return !n._batcher.checkAndUpdateTexture(n, e.texture)
            }
            return r !== s
        }
        addRenderable(e, t) {
            let r = this._renderer.renderPipes.batch;
            this._updateCanBatch(e);
            let s = this._getTilingSpriteData(e)
              , {geometry: n, canBatch: a} = s;
            if (a) {
                s.batchableMesh || (s.batchableMesh = new vs);
                let c = s.batchableMesh;
                e.didViewUpdate && (this._updateBatchableMesh(e),
                c.geometry = n,
                c.renderable = e,
                c.transform = e.groupTransform,
                c.setTexture(e._texture)),
                c.roundPixels = this._renderer._roundPixels | e._roundPixels,
                r.addToBatch(c, t)
            } else
                r.break(t),
                s.shader || (s.shader = new Al),
                this.updateRenderable(e),
                t.add(e)
        }
        execute(e) {
            let {shader: t} = this._getTilingSpriteData(e);
            t.groups[0] = this._renderer.globalUniforms.bindGroup;
            let r = t.resources.localUniforms.uniforms;
            r.uTransformMatrix = e.groupTransform,
            r.uRound = this._renderer._roundPixels | e._roundPixels,
            Os(e.groupColorAlpha, r.uColor, 0),
            this._state.blendMode = ps(e.groupBlendMode, e.texture._source),
            this._renderer.encoder.draw({
                geometry: cn,
                shader: t,
                state: this._state
            })
        }
        updateRenderable(e) {
            let t = this._getTilingSpriteData(e)
              , {canBatch: r} = t;
            if (r) {
                let {batchableMesh: s} = t;
                e.didViewUpdate && this._updateBatchableMesh(e),
                s._batcher.updateElement(s)
            } else if (e.didViewUpdate) {
                let {shader: s} = t;
                s.updateUniforms(e.width, e.height, e._tileTransform.matrix, e.anchor.x, e.anchor.y, e.texture)
            }
        }
        _getTilingSpriteData(e) {
            return e._gpuData[this._renderer.uid] || this._initTilingSpriteData(e)
        }
        _initTilingSpriteData(e) {
            let t = new Pl;
            return t.renderable = e,
            e._gpuData[this._renderer.uid] = t,
            t
        }
        _updateBatchableMesh(e) {
            let t = this._getTilingSpriteData(e)
              , {geometry: r} = t
              , s = e.texture.source.style;
            s.addressMode !== "repeat" && (s.addressMode = "repeat",
            s.update()),
            lv(e, r.uvs),
            ov(e, r.positions)
        }
        destroy() {
            this._renderer = null
        }
        _updateCanBatch(e) {
            let t = this._getTilingSpriteData(e)
              , r = e.texture
              , s = !0;
            return this._renderer.type === Bt.WEBGL && (s = this._renderer.context.supports.nonPowOf2wrapping),
            t.canBatch = r.textureMatrix.isSimple && (s || r.source.isPowerOfTwo),
            t.canBatch
        }
    }
    ;
    qn.extension = {
        type: [B.WebGLPipes, B.WebGPUPipes, B.CanvasPipes],
        name: "tilingSprite"
    },
    be.add(qn);
    var hv = Object.defineProperty
      , Rf = Object.getOwnPropertySymbols
      , uv = Object.prototype.hasOwnProperty
      , dv = Object.prototype.propertyIsEnumerable
      , Mf = (i, e, t) => e in i ? hv(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Cf = (i, e) => {
        for (var t in e || (e = {}))
            uv.call(e, t) && Mf(i, t, e[t]);
        if (Rf)
            for (var t of Rf(e))
                dv.call(e, t) && Mf(i, t, e[t]);
        return i
    }
      , J0 = class em extends Is {
        constructor(...e) {
            var t;
            super({});
            let r = (t = e[0]) != null ? t : {};
            typeof r == "number" && (r = {
                width: r,
                height: e[1],
                verticesX: e[2],
                verticesY: e[3]
            }),
            this.build(r)
        }
        build(e) {
            var t, r, s, n;
            e = Cf(Cf({}, em.defaultOptions), e),
            this.verticesX = (t = this.verticesX) != null ? t : e.verticesX,
            this.verticesY = (r = this.verticesY) != null ? r : e.verticesY,
            this.width = (s = this.width) != null ? s : e.width,
            this.height = (n = this.height) != null ? n : e.height;
            let a = this.verticesX * this.verticesY
              , c = []
              , l = []
              , u = []
              , d = this.verticesX - 1
              , f = this.verticesY - 1
              , b = this.width / d
              , m = this.height / f;
            for (let y = 0; y < a; y++) {
                let S = y % this.verticesX
                  , A = y / this.verticesX | 0;
                c.push(S * b, A * m),
                l.push(S / d, A / f)
            }
            let x = d * f;
            for (let y = 0; y < x; y++) {
                let S = y % d
                  , A = y / d | 0
                  , E = A * this.verticesX + S
                  , O = A * this.verticesX + S + 1
                  , M = (A + 1) * this.verticesX + S
                  , j = (A + 1) * this.verticesX + S + 1;
                u.push(E, O, M, O, j, M)
            }
            this.buffers[0].data = new Float32Array(c),
            this.buffers[1].data = new Float32Array(l),
            this.indexBuffer.data = new Uint32Array(u),
            this.buffers[0].update(),
            this.buffers[1].update(),
            this.indexBuffer.update()
        }
    }
    ;
    J0.defaultOptions = {
        width: 100,
        height: 100,
        verticesX: 10,
        verticesY: 10
    };
    var tm = J0
      , fv = Object.defineProperty
      , Of = Object.getOwnPropertySymbols
      , pv = Object.prototype.hasOwnProperty
      , bv = Object.prototype.propertyIsEnumerable
      , If = (i, e, t) => e in i ? fv(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Gf = (i, e) => {
        for (var t in e || (e = {}))
            pv.call(e, t) && If(i, t, e[t]);
        if (Of)
            for (var t of Of(e))
                bv.call(e, t) && If(i, t, e[t]);
        return i
    }
      , im = class rm extends tm {
        constructor(e={}) {
            e = Gf(Gf({}, rm.defaultOptions), e),
            super({
                width: e.width,
                height: e.height,
                verticesX: 4,
                verticesY: 4
            }),
            this.update(e)
        }
        update(e) {
            var t, r, s, n, a, c, l, u, d, f;
            this.width = (t = e.width) != null ? t : this.width,
            this.height = (r = e.height) != null ? r : this.height,
            this._originalWidth = (s = e.originalWidth) != null ? s : this._originalWidth,
            this._originalHeight = (n = e.originalHeight) != null ? n : this._originalHeight,
            this._leftWidth = (a = e.leftWidth) != null ? a : this._leftWidth,
            this._rightWidth = (c = e.rightWidth) != null ? c : this._rightWidth,
            this._topHeight = (l = e.topHeight) != null ? l : this._topHeight,
            this._bottomHeight = (u = e.bottomHeight) != null ? u : this._bottomHeight,
            this._anchorX = (d = e.anchor) == null ? void 0 : d.x,
            this._anchorY = (f = e.anchor) == null ? void 0 : f.y,
            this.updateUvs(),
            this.updatePositions()
        }
        updatePositions() {
            let e = this.positions
              , {width: t, height: r, _leftWidth: s, _rightWidth: n, _topHeight: a, _bottomHeight: c, _anchorX: l, _anchorY: u} = this
              , d = s + n
              , f = t > d ? 1 : t / d
              , b = a + c
              , m = r > b ? 1 : r / b
              , x = Math.min(f, m)
              , y = l * t
              , S = u * r;
            e[0] = e[8] = e[16] = e[24] = -y,
            e[2] = e[10] = e[18] = e[26] = s * x - y,
            e[4] = e[12] = e[20] = e[28] = t - n * x - y,
            e[6] = e[14] = e[22] = e[30] = t - y,
            e[1] = e[3] = e[5] = e[7] = -S,
            e[9] = e[11] = e[13] = e[15] = a * x - S,
            e[17] = e[19] = e[21] = e[23] = r - c * x - S,
            e[25] = e[27] = e[29] = e[31] = r - S,
            this.getBuffer("aPosition").update()
        }
        updateUvs() {
            let e = this.uvs;
            e[0] = e[8] = e[16] = e[24] = 0,
            e[1] = e[3] = e[5] = e[7] = 0,
            e[6] = e[14] = e[22] = e[30] = 1,
            e[25] = e[27] = e[29] = e[31] = 1;
            let t = 1 / this._originalWidth
              , r = 1 / this._originalHeight;
            e[2] = e[10] = e[18] = e[26] = t * this._leftWidth,
            e[9] = e[11] = e[13] = e[15] = r * this._topHeight,
            e[4] = e[12] = e[20] = e[28] = 1 - t * this._rightWidth,
            e[17] = e[19] = e[21] = e[23] = 1 - r * this._bottomHeight,
            this.getBuffer("aUV").update()
        }
    }
    ;
    im.defaultOptions = {
        width: 100,
        height: 100,
        leftWidth: 10,
        topHeight: 10,
        rightWidth: 10,
        bottomHeight: 10,
        originalWidth: 100,
        originalHeight: 100
    };
    var qi = im
      , Rl = class extends vs {
        constructor() {
            super(),
            this.geometry = new qi
        }
        destroy() {
            this.geometry.destroy()
        }
    }
      , Zn = class {
        constructor(e) {
            this._renderer = e
        }
        addRenderable(e, t) {
            let r = this._getGpuSprite(e);
            e.didViewUpdate && this._updateBatchableSprite(e, r),
            this._renderer.renderPipes.batch.addToBatch(r, t)
        }
        updateRenderable(e) {
            let t = this._getGpuSprite(e);
            e.didViewUpdate && this._updateBatchableSprite(e, t),
            t._batcher.updateElement(t)
        }
        validateRenderable(e) {
            let t = this._getGpuSprite(e);
            return !t._batcher.checkAndUpdateTexture(t, e._texture)
        }
        _updateBatchableSprite(e, t) {
            t.geometry.update(e),
            t.setTexture(e._texture)
        }
        _getGpuSprite(e) {
            return e._gpuData[this._renderer.uid] || this._initGPUSprite(e)
        }
        _initGPUSprite(e) {
            let t = e._gpuData[this._renderer.uid] = new Rl
              , r = t;
            return r.renderable = e,
            r.transform = e.groupTransform,
            r.texture = e._texture,
            r.roundPixels = this._renderer._roundPixels | e._roundPixels,
            e.didViewUpdate || this._updateBatchableSprite(e, r),
            t
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    Zn.extension = {
        type: [B.WebGLPipes, B.WebGPUPipes, B.CanvasPipes],
        name: "nineSliceSprite"
    },
    be.add(Zn);
    var Qn = class {
        constructor(e) {
            this._renderer = e
        }
        push(e, t, r) {
            this._renderer.renderPipes.batch.break(r),
            r.add({
                renderPipeId: "filter",
                canBundle: !1,
                action: "pushFilter",
                container: t,
                filterEffect: e
            })
        }
        pop(e, t, r) {
            this._renderer.renderPipes.batch.break(r),
            r.add({
                renderPipeId: "filter",
                action: "popFilter",
                canBundle: !1
            })
        }
        execute(e) {
            e.action === "pushFilter" ? this._renderer.filter.push(e) : e.action === "popFilter" && this._renderer.filter.pop()
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    Qn.extension = {
        type: [B.WebGLPipes, B.WebGPUPipes, B.CanvasPipes],
        name: "filter"
    };
    function Bf(i, e, t, r, s, n, a, c) {
        let l = a - t
          , u = c - r
          , d = s - t
          , f = n - r
          , b = i - t
          , m = e - r
          , x = l * l + u * u
          , y = l * d + u * f
          , S = l * b + u * m
          , A = d * d + f * f
          , E = d * b + f * m
          , O = 1 / (x * A - y * y)
          , M = (A * S - y * E) * O
          , j = (x * E - y * S) * O;
        return M >= 0 && j >= 0 && M + j < 1
    }
    var Ff = new ce;
    function mv(i, e) {
        var t;
        e.clear();
        let r = e.matrix;
        for (let s = 0; s < i.length; s++) {
            let n = i[s];
            if (n.globalDisplayStatus < 7)
                continue;
            let a = (t = n.renderGroup) != null ? t : n.parentRenderGroup;
            a != null && a.isCachedAsTexture ? e.matrix = Ff.copyFrom(a.textureOffsetInverseTransform).append(n.worldTransform) : a != null && a._parentCacheAsTextureRenderGroup ? e.matrix = Ff.copyFrom(a._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(n.groupTransform) : e.matrix = n.worldTransform,
            e.addBounds(n.bounds)
        }
        return e.matrix = r,
        e
    }
    var gv = new oi({
        attributes: {
            aPosition: {
                buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
                format: "float32x2",
                stride: 8,
                offset: 0
            }
        },
        indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
    })
      , _v = class {
        constructor() {
            this.skip = !1,
            this.inputTexture = null,
            this.backTexture = null,
            this.filters = null,
            this.bounds = new at,
            this.container = null,
            this.blendRequired = !1,
            this.outputRenderSurface = null,
            this.globalFrame = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }
        }
    }
      , Jn = class {
        constructor(e) {
            this._filterStackIndex = 0,
            this._filterStack = [],
            this._filterGlobalUniforms = new ct({
                uInputSize: {
                    value: new Float32Array(4),
                    type: "vec4<f32>"
                },
                uInputPixel: {
                    value: new Float32Array(4),
                    type: "vec4<f32>"
                },
                uInputClamp: {
                    value: new Float32Array(4),
                    type: "vec4<f32>"
                },
                uOutputFrame: {
                    value: new Float32Array(4),
                    type: "vec4<f32>"
                },
                uGlobalFrame: {
                    value: new Float32Array(4),
                    type: "vec4<f32>"
                },
                uOutputTexture: {
                    value: new Float32Array(4),
                    type: "vec4<f32>"
                }
            }),
            this._globalFilterBindGroup = new Qt({}),
            this.renderer = e
        }
        get activeBackTexture() {
            var e;
            return (e = this._activeFilterData) == null ? void 0 : e.backTexture
        }
        push(e) {
            let t = this.renderer
              , r = e.filterEffect.filters
              , s = this._pushFilterData();
            s.skip = !1,
            s.filters = r,
            s.container = e.container,
            s.outputRenderSurface = t.renderTarget.renderSurface;
            let n = t.renderTarget.renderTarget.colorTexture.source
              , a = n.resolution
              , c = n.antialias;
            if (r.length === 0) {
                s.skip = !0;
                return
            }
            let l = s.bounds;
            if (this._calculateFilterArea(e, l),
            this._calculateFilterBounds(s, t.renderTarget.rootViewPort, c, a, 1),
            s.skip)
                return;
            let u = this._getPreviousFilterData()
              , d = this._findFilterResolution(a)
              , f = 0
              , b = 0;
            u && (f = u.bounds.minX,
            b = u.bounds.minY),
            this._calculateGlobalFrame(s, f, b, d, n.width, n.height),
            this._setupFilterTextures(s, l, t, u)
        }
        generateFilteredTexture({texture: e, filters: t}) {
            let r = this._pushFilterData();
            this._activeFilterData = r,
            r.skip = !1,
            r.filters = t;
            let s = e.source
              , n = s.resolution
              , a = s.antialias;
            if (t.length === 0)
                return r.skip = !0,
                e;
            let c = r.bounds;
            if (c.addRect(e.frame),
            this._calculateFilterBounds(r, c.rectangle, a, n, 0),
            r.skip)
                return e;
            let l = n;
            this._calculateGlobalFrame(r, 0, 0, l, s.width, s.height),
            r.outputRenderSurface = Qe.getOptimalTexture(c.width, c.height, r.resolution, r.antialias),
            r.backTexture = Z.EMPTY,
            r.inputTexture = e,
            this.renderer.renderTarget.finishRenderPass(),
            this._applyFiltersToTexture(r, !0);
            let f = r.outputRenderSurface;
            return f.source.alphaMode = "premultiplied-alpha",
            f
        }
        pop() {
            let e = this.renderer
              , t = this._popFilterData();
            t.skip || (e.globalUniforms.pop(),
            e.renderTarget.finishRenderPass(),
            this._activeFilterData = t,
            this._applyFiltersToTexture(t, !1),
            t.blendRequired && Qe.returnTexture(t.backTexture),
            Qe.returnTexture(t.inputTexture))
        }
        getBackTexture(e, t, r) {
            let s = e.colorTexture.source._resolution
              , n = Qe.getOptimalTexture(t.width, t.height, s, !1)
              , a = t.minX
              , c = t.minY;
            r && (a -= r.minX,
            c -= r.minY),
            a = Math.floor(a * s),
            c = Math.floor(c * s);
            let l = Math.ceil(t.width * s)
              , u = Math.ceil(t.height * s);
            return this.renderer.renderTarget.copyToTexture(e, n, {
                x: a,
                y: c
            }, {
                width: l,
                height: u
            }, {
                x: 0,
                y: 0
            }),
            n
        }
        applyFilter(e, t, r, s) {
            let n = this.renderer
              , a = this._activeFilterData
              , c = a.outputRenderSurface === r
              , l = n.renderTarget.rootRenderTarget.colorTexture.source._resolution
              , u = this._findFilterResolution(l)
              , d = 0
              , f = 0;
            if (c) {
                let b = this._findPreviousFilterOffset();
                d = b.x,
                f = b.y
            }
            this._updateFilterUniforms(t, r, a, d, f, u, c, s),
            this._setupBindGroupsAndRender(e, t, n)
        }
        calculateSpriteMatrix(e, t) {
            let r = this._activeFilterData
              , s = e.set(r.inputTexture._source.width, 0, 0, r.inputTexture._source.height, r.bounds.minX, r.bounds.minY)
              , n = t.worldTransform.copyTo(ce.shared)
              , a = t.renderGroup || t.parentRenderGroup;
            return a && a.cacheToLocalTransform && n.prepend(a.cacheToLocalTransform),
            n.invert(),
            s.prepend(n),
            s.scale(1 / t.texture.orig.width, 1 / t.texture.orig.height),
            s.translate(t.anchor.x, t.anchor.y),
            s
        }
        destroy() {}
        _setupBindGroupsAndRender(e, t, r) {
            if (r.renderPipes.uniformBatch) {
                let s = r.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);
                this._globalFilterBindGroup.setResource(s, 0)
            } else
                this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);
            this._globalFilterBindGroup.setResource(t.source, 1),
            this._globalFilterBindGroup.setResource(t.source.style, 2),
            e.groups[0] = this._globalFilterBindGroup,
            r.encoder.draw({
                geometry: gv,
                shader: e,
                state: e._state,
                topology: "triangle-list"
            }),
            r.type === Bt.WEBGL && r.renderTarget.finishRenderPass()
        }
        _setupFilterTextures(e, t, r, s) {
            if (e.backTexture = Z.EMPTY,
            e.inputTexture = Qe.getOptimalTexture(t.width, t.height, e.resolution, e.antialias),
            e.blendRequired) {
                r.renderTarget.finishRenderPass();
                let n = r.renderTarget.getRenderTarget(e.outputRenderSurface);
                e.backTexture = this.getBackTexture(n, t, s?.bounds)
            }
            r.renderTarget.bind(e.inputTexture, !0),
            r.globalUniforms.push({
                offset: t
            })
        }
        _calculateGlobalFrame(e, t, r, s, n, a) {
            let c = e.globalFrame;
            c.x = t * s,
            c.y = r * s,
            c.width = n * s,
            c.height = a * s
        }
        _updateFilterUniforms(e, t, r, s, n, a, c, l) {
            let u = this._filterGlobalUniforms.uniforms
              , d = u.uOutputFrame
              , f = u.uInputSize
              , b = u.uInputPixel
              , m = u.uInputClamp
              , x = u.uGlobalFrame
              , y = u.uOutputTexture;
            c ? (d[0] = r.bounds.minX - s,
            d[1] = r.bounds.minY - n) : (d[0] = 0,
            d[1] = 0),
            d[2] = e.frame.width,
            d[3] = e.frame.height,
            f[0] = e.source.width,
            f[1] = e.source.height,
            f[2] = 1 / f[0],
            f[3] = 1 / f[1],
            b[0] = e.source.pixelWidth,
            b[1] = e.source.pixelHeight,
            b[2] = 1 / b[0],
            b[3] = 1 / b[1],
            m[0] = .5 * b[2],
            m[1] = .5 * b[3],
            m[2] = e.frame.width * f[2] - .5 * b[2],
            m[3] = e.frame.height * f[3] - .5 * b[3];
            let S = this.renderer.renderTarget.rootRenderTarget.colorTexture;
            x[0] = s * a,
            x[1] = n * a,
            x[2] = S.source.width * a,
            x[3] = S.source.height * a,
            t instanceof Z && (t.source.resource = null);
            let A = this.renderer.renderTarget.getRenderTarget(t);
            this.renderer.renderTarget.bind(t, !!l),
            t instanceof Z ? (y[0] = t.frame.width,
            y[1] = t.frame.height) : (y[0] = A.width,
            y[1] = A.height),
            y[2] = A.isRoot ? -1 : 1,
            this._filterGlobalUniforms.update()
        }
        _findFilterResolution(e) {
            let t = this._filterStackIndex - 1;
            for (; t > 0 && this._filterStack[t].skip; )
                --t;
            return t > 0 && this._filterStack[t].inputTexture ? this._filterStack[t].inputTexture.source._resolution : e
        }
        _findPreviousFilterOffset() {
            let e = 0
              , t = 0
              , r = this._filterStackIndex;
            for (; r > 0; ) {
                r--;
                let s = this._filterStack[r];
                if (!s.skip) {
                    e = s.bounds.minX,
                    t = s.bounds.minY;
                    break
                }
            }
            return {
                x: e,
                y: t
            }
        }
        _calculateFilterArea(e, t) {
            if (e.renderables ? mv(e.renderables, t) : e.filterEffect.filterArea ? (t.clear(),
            t.addRect(e.filterEffect.filterArea),
            t.applyMatrix(e.container.worldTransform)) : e.container.getFastGlobalBounds(!0, t),
            e.container) {
                let r = (e.container.renderGroup || e.container.parentRenderGroup).cacheToLocalTransform;
                r && t.applyMatrix(r)
            }
        }
        _applyFiltersToTexture(e, t) {
            let r = e.inputTexture
              , s = e.bounds
              , n = e.filters;
            if (this._globalFilterBindGroup.setResource(r.source.style, 2),
            this._globalFilterBindGroup.setResource(e.backTexture.source, 3),
            n.length === 1)
                n[0].apply(this, r, e.outputRenderSurface, t);
            else {
                let a = e.inputTexture
                  , c = Qe.getOptimalTexture(s.width, s.height, a.source._resolution, !1)
                  , l = c
                  , u = 0;
                for (u = 0; u < n.length - 1; ++u) {
                    n[u].apply(this, a, l, !0);
                    let d = a;
                    a = l,
                    l = d
                }
                n[u].apply(this, a, e.outputRenderSurface, t),
                Qe.returnTexture(c)
            }
        }
        _calculateFilterBounds(e, t, r, s, n) {
            var a, c;
            let l = this.renderer
              , u = e.bounds
              , d = e.filters
              , f = 1 / 0
              , b = 0
              , m = !0
              , x = !1
              , y = !1
              , S = !0;
            for (let A = 0; A < d.length; A++) {
                let E = d[A];
                if (f = Math.min(f, E.resolution === "inherit" ? s : E.resolution),
                b += E.padding,
                E.antialias === "off" ? m = !1 : E.antialias === "inherit" && m && (m = r),
                E.clipToViewport || (S = !1),
                !(E.compatibleRenderers & l.type)) {
                    y = !1;
                    break
                }
                if (E.blendRequired && !((c = (a = l.backBuffer) == null ? void 0 : a.useBackBuffer) == null || c)) {
                    y = !1;
                    break
                }
                y = E.enabled || y,
                x || (x = E.blendRequired)
            }
            if (!y) {
                e.skip = !0;
                return
            }
            if (S && u.fitBounds(0, t.width / s, 0, t.height / s),
            u.scale(f).ceil().scale(1 / f).pad((b | 0) * n),
            !u.isPositive) {
                e.skip = !0;
                return
            }
            e.antialias = m,
            e.resolution = f,
            e.blendRequired = x
        }
        _popFilterData() {
            return this._filterStackIndex--,
            this._filterStack[this._filterStackIndex]
        }
        _getPreviousFilterData() {
            let e, t = this._filterStackIndex - 1;
            for (; t > 0 && (t--,
            e = this._filterStack[t],
            !!e.skip); )
                ;
            return e
        }
        _pushFilterData() {
            let e = this._filterStack[this._filterStackIndex];
            return e || (e = this._filterStack[this._filterStackIndex] = new _v),
            this._filterStackIndex++,
            e
        }
    }
    ;
    Jn.extension = {
        type: [B.WebGLSystem, B.WebGPUSystem],
        name: "filter"
    },
    be.add(Jn),
    be.add(Qn);
    var xv = {
        __proto__: null
    }
      , Ml = [];
    be.handleByNamedList(B.Environment, Ml);
    async function yv(i) {
        if (!i)
            for (let e = 0; e < Ml.length; e++) {
                let t = Ml[e];
                if (t.value.test()) {
                    await t.value.load();
                    return
                }
            }
    }
    var jr;
    function sm() {
        if (typeof jr == "boolean")
            return jr;
        try {
            jr = new Function("param1","param2","param3","return param1[param2] === param3;")({
                a: "b"
            }, "a", "b") === !0
        } catch {
            jr = !1
        }
        return jr
    }
    var It = (i => (i[i.NONE = 0] = "NONE",
    i[i.COLOR = 16384] = "COLOR",
    i[i.STENCIL = 1024] = "STENCIL",
    i[i.DEPTH = 256] = "DEPTH",
    i[i.COLOR_DEPTH = 16640] = "COLOR_DEPTH",
    i[i.COLOR_STENCIL = 17408] = "COLOR_STENCIL",
    i[i.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL",
    i[i.ALL = 17664] = "ALL",
    i))(It || {})
      , ea = class {
        constructor(e) {
            this.items = [],
            this._name = e
        }
        emit(e, t, r, s, n, a, c, l) {
            let {name: u, items: d} = this;
            for (let f = 0, b = d.length; f < b; f++)
                d[f][u](e, t, r, s, n, a, c, l);
            return this
        }
        add(e) {
            return e[this._name] && (this.remove(e),
            this.items.push(e)),
            this
        }
        remove(e) {
            let t = this.items.indexOf(e);
            return t !== -1 && this.items.splice(t, 1),
            this
        }
        contains(e) {
            return this.items.indexOf(e) !== -1
        }
        removeAll() {
            return this.items.length = 0,
            this
        }
        destroy() {
            this.removeAll(),
            this.items = null,
            this._name = null
        }
        get empty() {
            return this.items.length === 0
        }
        get name() {
            return this._name
        }
    }
      , vv = Object.defineProperty
      , Df = Object.getOwnPropertySymbols
      , Tv = Object.prototype.hasOwnProperty
      , Sv = Object.prototype.propertyIsEnumerable
      , kf = (i, e, t) => e in i ? vv(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , qs = (i, e) => {
        for (var t in e || (e = {}))
            Tv.call(e, t) && kf(i, t, e[t]);
        if (Df)
            for (var t of Df(e))
                Sv.call(e, t) && kf(i, t, e[t]);
        return i
    }
      , wv = ["init", "destroy", "contextChange", "resolutionChange", "resetState", "renderEnd", "renderStart", "render", "update", "postrender", "prerender"]
      , nm = class am extends Ft {
        constructor(e) {
            var t;
            super(),
            this.uid = Xe("renderer"),
            this.runners = Object.create(null),
            this.renderPipes = Object.create(null),
            this._initOptions = {},
            this._systemsHash = Object.create(null),
            this.type = e.type,
            this.name = e.name,
            this.config = e;
            let r = [...wv, ...(t = this.config.runners) != null ? t : []];
            this._addRunners(...r),
            this._unsafeEvalCheck()
        }
        async init(e={}) {
            let t = e.skipExtensionImports === !0 ? !0 : e.manageImports === !1;
            await yv(t),
            this._addSystems(this.config.systems),
            this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
            for (let r in this._systemsHash) {
                let s = this._systemsHash[r].constructor.defaultOptions;
                e = qs(qs({}, s), e)
            }
            e = qs(qs({}, am.defaultOptions), e),
            this._roundPixels = e.roundPixels ? 1 : 0;
            for (let r = 0; r < this.runners.init.items.length; r++)
                await this.runners.init.items[r].init(e);
            this._initOptions = e
        }
        render(e, t) {
            var r, s;
            let n = e;
            if (n instanceof _e && (n = {
                container: n
            },
            t && (n.target = t.renderTexture)),
            n.target || (n.target = this.view.renderTarget),
            n.target === this.view.renderTarget && (this._lastObjectRendered = n.container,
            (r = n.clearColor) != null || (n.clearColor = this.background.colorRgba),
            (s = n.clear) != null || (n.clear = this.background.clearBeforeRender)),
            n.clearColor) {
                let a = Array.isArray(n.clearColor) && n.clearColor.length === 4;
                n.clearColor = a ? n.clearColor : Ie.shared.setValue(n.clearColor).toArray()
            }
            n.transform || (n.container.updateLocalTransform(),
            n.transform = n.container.localTransform),
            n.container.visible && (n.container.enableRenderGroup(),
            this.runners.prerender.emit(n),
            this.runners.renderStart.emit(n),
            this.runners.render.emit(n),
            this.runners.renderEnd.emit(n),
            this.runners.postrender.emit(n))
        }
        resize(e, t, r) {
            let s = this.view.resolution;
            this.view.resize(e, t, r),
            this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution),
            r !== void 0 && r !== s && this.runners.resolutionChange.emit(r)
        }
        clear(e={}) {
            var t;
            let r = this;
            e.target || (e.target = r.renderTarget.renderTarget),
            e.clearColor || (e.clearColor = this.background.colorRgba),
            (t = e.clear) != null || (e.clear = It.ALL);
            let {clear: s, clearColor: n, target: a} = e;
            Ie.shared.setValue(n ?? this.background.colorRgba),
            r.renderTarget.clear(a, s, Ie.shared.toArray())
        }
        get resolution() {
            return this.view.resolution
        }
        set resolution(e) {
            this.view.resolution = e,
            this.runners.resolutionChange.emit(e)
        }
        get width() {
            return this.view.texture.frame.width
        }
        get height() {
            return this.view.texture.frame.height
        }
        get canvas() {
            return this.view.canvas
        }
        get lastObjectRendered() {
            return this._lastObjectRendered
        }
        get renderingToScreen() {
            return this.renderTarget.renderingToScreen
        }
        get screen() {
            return this.view.screen
        }
        _addRunners(...e) {
            e.forEach(t => {
                this.runners[t] = new ea(t)
            }
            )
        }
        _addSystems(e) {
            let t;
            for (t in e) {
                let r = e[t];
                this._addSystem(r.value, r.name)
            }
        }
        _addSystem(e, t) {
            let r = new e(this);
            if (this[t])
                throw new Error(`Whoops! The name "${t}" is already in use`);
            this[t] = r,
            this._systemsHash[t] = r;
            for (let s in this.runners)
                this.runners[s].add(r);
            return this
        }
        _addPipes(e, t) {
            let r = t.reduce( (s, n) => (s[n.name] = n.value,
            s), {});
            e.forEach(s => {
                let n = s.value
                  , a = s.name
                  , c = r[a];
                this.renderPipes[a] = new n(this,c ? new c : null),
                this.runners.destroy.add(this.renderPipes[a])
            }
            )
        }
        destroy(e=!1) {
            this.runners.destroy.items.reverse(),
            this.runners.destroy.emit(e),
            Object.values(this.runners).forEach(t => {
                t.destroy()
            }
            ),
            (e === !0 || typeof e == "object" && e.releaseGlobalResources) && Cr.release(),
            this._systemsHash = null,
            this.renderPipes = null
        }
        generateTexture(e) {
            return this.textureGenerator.generateTexture(e)
        }
        get roundPixels() {
            return !!this._roundPixels
        }
        _unsafeEvalCheck() {
            if (!sm())
                throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")
        }
        resetState() {
            this.runners.resetState.emit()
        }
    }
    ;
    nm.defaultOptions = {
        resolution: 1,
        failIfMajorPerformanceCaveat: !1,
        roundPixels: !1
    };
    var po = nm, cc;
    function bo(i) {
        return cc !== void 0 || (cc = ( () => {
            var e;
            let t = {
                stencil: !0,
                failIfMajorPerformanceCaveat: i ?? po.defaultOptions.failIfMajorPerformanceCaveat
            };
            try {
                if (!xe.get().getWebGLRenderingContext())
                    return !1;
                let r = xe.get().createCanvas().getContext("webgl", t)
                  , s = !!((e = r?.getContextAttributes()) != null && e.stencil);
                if (r) {
                    let n = r.getExtension("WEBGL_lose_context");
                    n && n.loseContext()
                }
                return r = null,
                s
            } catch {
                return !1
            }
        }
        )()),
        cc
    }
    var lc;
    async function mo(i={}) {
        return lc !== void 0 || (lc = await (async () => {
            let e = xe.get().getNavigator().gpu;
            if (!e)
                return !1;
            try {
                return await (await e.requestAdapter(i)).requestDevice(),
                !0
            } catch {
                return !1
            }
        }
        )()),
        lc
    }
    var Av = Object.defineProperty
      , Uf = Object.getOwnPropertySymbols
      , Ev = Object.prototype.hasOwnProperty
      , Pv = Object.prototype.propertyIsEnumerable
      , Lf = (i, e, t) => e in i ? Av(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Hr = (i, e) => {
        for (var t in e || (e = {}))
            Ev.call(e, t) && Lf(i, t, e[t]);
        if (Uf)
            for (var t of Uf(e))
                Pv.call(e, t) && Lf(i, t, e[t]);
        return i
    }
      , Nf = ["webgl", "webgpu", "canvas"];
    async function go(i) {
        var e;
        let t = [];
        i.preference ? (t.push(i.preference),
        Nf.forEach(a => {
            a !== i.preference && t.push(a)
        }
        )) : t = Nf.slice();
        let r, s = {};
        for (let a = 0; a < t.length; a++) {
            let c = t[a];
            if (c === "webgpu" && await mo()) {
                let {WebGPURenderer: l} = await Promise.resolve().then(function() {
                    return oS
                });
                r = l,
                s = Hr(Hr({}, i), i.webgpu);
                break
            } else if (c === "webgl" && bo((e = i.failIfMajorPerformanceCaveat) != null ? e : po.defaultOptions.failIfMajorPerformanceCaveat)) {
                let {WebGLRenderer: l} = await Promise.resolve().then(function() {
                    return kT
                });
                r = l,
                s = Hr(Hr({}, i), i.webgl);
                break
            } else if (c === "canvas")
                throw s = Hr({}, i),
                new Error("CanvasRenderer is not yet implemented")
        }
        if (delete s.webgpu,
        delete s.webgl,
        !r)
            throw new Error("No available renderer for the current environment");
        let n = new r;
        return await n.init(s),
        n
    }
    var ta = "8.13.1"
      , ia = class {
        static init() {
            var e;
            (e = globalThis.__PIXI_APP_INIT__) == null || e.call(globalThis, this, ta)
        }
        static destroy() {}
    }
    ;
    ia.extension = B.Application;
    var ra = class {
        constructor(e) {
            this._renderer = e
        }
        init() {
            var e;
            (e = globalThis.__PIXI_RENDERER_INIT__) == null || e.call(globalThis, this._renderer, ta)
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    ra.extension = {
        type: [B.WebGLSystem, B.WebGPUSystem],
        name: "initHook",
        priority: -10
    };
    var Rv = Object.defineProperty
      , Xf = Object.getOwnPropertySymbols
      , Mv = Object.prototype.hasOwnProperty
      , Cv = Object.prototype.propertyIsEnumerable
      , jf = (i, e, t) => e in i ? Rv(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Ov = (i, e) => {
        for (var t in e || (e = {}))
            Mv.call(e, t) && jf(i, t, e[t]);
        if (Xf)
            for (var t of Xf(e))
                Cv.call(e, t) && jf(i, t, e[t]);
        return i
    }
      , om = class Cl {
        constructor(...e) {
            this.stage = new _e
        }
        async init(e) {
            e = Ov({}, e),
            this.renderer = await go(e),
            Cl._plugins.forEach(t => {
                t.init.call(this, e)
            }
            )
        }
        render() {
            this.renderer.render({
                container: this.stage
            })
        }
        get canvas() {
            return this.renderer.canvas
        }
        get view() {
            return this.renderer.canvas
        }
        get screen() {
            return this.renderer.screen
        }
        destroy(e=!1, t=!1) {
            let r = Cl._plugins.slice(0);
            r.reverse(),
            r.forEach(s => {
                s.destroy.call(this)
            }
            ),
            this.stage.destroy(t),
            this.stage = null,
            this.renderer.destroy(e),
            this.renderer = null
        }
    }
    ;
    om._plugins = [];
    var Iv = om;
    be.handleByList(B.Application, Iv._plugins),
    be.add(ia);
    var sa = class extends Vn {
        constructor(e, t) {
            var r;
            super();
            let {textures: s, data: n} = e;
            Object.keys(n.pages).forEach(a => {
                let c = n.pages[parseInt(a, 10)]
                  , l = s[c.id];
                this.pages.push({
                    texture: l
                })
            }
            ),
            Object.keys(n.chars).forEach(a => {
                var c;
                let l = n.chars[a]
                  , {frame: u, source: d, rotate: f} = s[l.page]
                  , b = De.transformRectCoords(l, u, f, new Re)
                  , m = new Z({
                    frame: b,
                    orig: new Re(0,0,l.width,l.height),
                    source: d,
                    rotate: f
                });
                this.chars[a] = {
                    id: a.codePointAt(0),
                    xOffset: l.xOffset,
                    yOffset: l.yOffset,
                    xAdvance: l.xAdvance,
                    kerning: (c = l.kerning) != null ? c : {},
                    texture: m
                }
            }
            ),
            this.baseRenderedFontSize = n.fontSize,
            this.baseMeasurementFontSize = n.fontSize,
            this.fontMetrics = {
                ascent: 0,
                descent: 0,
                fontSize: n.fontSize
            },
            this.baseLineOffset = n.baseLineOffset,
            this.lineHeight = n.lineHeight,
            this.fontFamily = n.fontFamily,
            this.distanceField = (r = n.distanceField) != null ? r : {
                type: "none",
                range: 0
            },
            this.url = t
        }
        destroy() {
            super.destroy();
            for (let e = 0; e < this.pages.length; e++) {
                let {texture: t} = this.pages[e];
                t.destroy(!0)
            }
            this.pages = null
        }
        static install(e) {
            Ts.install(e)
        }
        static uninstall(e) {
            Ts.uninstall(e)
        }
    }
      , hc = {
        test(i) {
            return typeof i == "string" && i.startsWith("info face=")
        },
        parse(i) {
            var e, t, r;
            let s = i.match(/^[a-z]+\s+.+$/gm)
              , n = {
                info: [],
                common: [],
                page: [],
                char: [],
                chars: [],
                kerning: [],
                kernings: [],
                distanceField: []
            };
            for (let x in s) {
                let y = s[x].match(/^[a-z]+/gm)[0]
                  , S = s[x].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm)
                  , A = {};
                for (let E in S) {
                    let O = S[E].split("=")
                      , M = O[0]
                      , j = O[1].replace(/"/gm, "")
                      , L = parseFloat(j)
                      , N = isNaN(L) ? j : L;
                    A[M] = N
                }
                n[y].push(A)
            }
            let a = {
                chars: {},
                pages: [],
                lineHeight: 0,
                fontSize: 0,
                fontFamily: "",
                distanceField: null,
                baseLineOffset: 0
            }
              , [c] = n.info
              , [l] = n.common
              , [u] = (e = n.distanceField) != null ? e : [];
            u && (a.distanceField = {
                range: parseInt(u.distanceRange, 10),
                type: u.fieldType
            }),
            a.fontSize = parseInt(c.size, 10),
            a.fontFamily = c.face,
            a.lineHeight = parseInt(l.lineHeight, 10);
            let d = n.page;
            for (let x = 0; x < d.length; x++)
                a.pages.push({
                    id: parseInt(d[x].id, 10) || 0,
                    file: d[x].file
                });
            let f = {};
            a.baseLineOffset = a.lineHeight - parseInt(l.base, 10);
            let b = n.char;
            for (let x = 0; x < b.length; x++) {
                let y = b[x]
                  , S = parseInt(y.id, 10)
                  , A = (r = (t = y.letter) != null ? t : y.char) != null ? r : String.fromCharCode(S);
                A === "space" && (A = " "),
                f[S] = A,
                a.chars[A] = {
                    id: S,
                    page: parseInt(y.page, 10) || 0,
                    x: parseInt(y.x, 10),
                    y: parseInt(y.y, 10),
                    width: parseInt(y.width, 10),
                    height: parseInt(y.height, 10),
                    xOffset: parseInt(y.xoffset, 10),
                    yOffset: parseInt(y.yoffset, 10),
                    xAdvance: parseInt(y.xadvance, 10),
                    kerning: {}
                }
            }
            let m = n.kerning || [];
            for (let x = 0; x < m.length; x++) {
                let y = parseInt(m[x].first, 10)
                  , S = parseInt(m[x].second, 10)
                  , A = parseInt(m[x].amount, 10);
                a.chars[f[S]].kerning[f[y]] = A
            }
            return a
        }
    }
      , Hf = {
        test(i) {
            let e = i;
            return typeof e != "string" && "getElementsByTagName"in e && e.getElementsByTagName("page").length && e.getElementsByTagName("info")[0].getAttribute("face") !== null
        },
        parse(i) {
            var e, t;
            let r = {
                chars: {},
                pages: [],
                lineHeight: 0,
                fontSize: 0,
                fontFamily: "",
                distanceField: null,
                baseLineOffset: 0
            }
              , s = i.getElementsByTagName("info")[0]
              , n = i.getElementsByTagName("common")[0]
              , a = i.getElementsByTagName("distanceField")[0];
            a && (r.distanceField = {
                type: a.getAttribute("fieldType"),
                range: parseInt(a.getAttribute("distanceRange"), 10)
            });
            let c = i.getElementsByTagName("page")
              , l = i.getElementsByTagName("char")
              , u = i.getElementsByTagName("kerning");
            r.fontSize = parseInt(s.getAttribute("size"), 10),
            r.fontFamily = s.getAttribute("face"),
            r.lineHeight = parseInt(n.getAttribute("lineHeight"), 10);
            for (let f = 0; f < c.length; f++)
                r.pages.push({
                    id: parseInt(c[f].getAttribute("id"), 10) || 0,
                    file: c[f].getAttribute("file")
                });
            let d = {};
            r.baseLineOffset = r.lineHeight - parseInt(n.getAttribute("base"), 10);
            for (let f = 0; f < l.length; f++) {
                let b = l[f]
                  , m = parseInt(b.getAttribute("id"), 10)
                  , x = (t = (e = b.getAttribute("letter")) != null ? e : b.getAttribute("char")) != null ? t : String.fromCharCode(m);
                x === "space" && (x = " "),
                d[m] = x,
                r.chars[x] = {
                    id: m,
                    page: parseInt(b.getAttribute("page"), 10) || 0,
                    x: parseInt(b.getAttribute("x"), 10),
                    y: parseInt(b.getAttribute("y"), 10),
                    width: parseInt(b.getAttribute("width"), 10),
                    height: parseInt(b.getAttribute("height"), 10),
                    xOffset: parseInt(b.getAttribute("xoffset"), 10),
                    yOffset: parseInt(b.getAttribute("yoffset"), 10),
                    xAdvance: parseInt(b.getAttribute("xadvance"), 10),
                    kerning: {}
                }
            }
            for (let f = 0; f < u.length; f++) {
                let b = parseInt(u[f].getAttribute("first"), 10)
                  , m = parseInt(u[f].getAttribute("second"), 10)
                  , x = parseInt(u[f].getAttribute("amount"), 10);
                r.chars[d[m]].kerning[d[b]] = x
            }
            return r
        }
    }
      , zf = {
        test(i) {
            return typeof i == "string" && i.includes("<font>") ? Hf.test(xe.get().parseXML(i)) : !1
        },
        parse(i) {
            return Hf.parse(xe.get().parseXML(i))
        }
    }
      , Gv = [".xml", ".fnt"]
      , Bv = {
        extension: {
            type: B.CacheParser,
            name: "cacheBitmapFont"
        },
        test: i => i instanceof sa,
        getCacheableAssets(i, e) {
            let t = {};
            return i.forEach(r => {
                t[r] = e,
                t[`${r}-bitmap`] = e
            }
            ),
            t[`${e.fontFamily}-bitmap`] = e,
            t
        }
    }
      , Fv = {
        extension: {
            type: B.LoadParser,
            priority: jt.Normal
        },
        name: "loadBitmapFont",
        id: "bitmap-font",
        test(i) {
            return Gv.includes(Gt.extname(i).toLowerCase())
        },
        async testParse(i) {
            return hc.test(i) || zf.test(i)
        },
        async parse(i, e, t) {
            let r = hc.test(i) ? hc.parse(i) : zf.parse(i)
              , {src: s} = e
              , {pages: n} = r
              , a = []
              , c = r.distanceField ? {
                scaleMode: "linear",
                alphaMode: "premultiply-alpha-on-upload",
                autoGenerateMipmaps: !1,
                resolution: 1
            } : {};
            for (let d = 0; d < n.length; ++d) {
                let f = n[d].file
                  , b = Gt.join(Gt.dirname(s), f);
                b = Xc(b, s),
                a.push({
                    src: b,
                    data: c
                })
            }
            let l = await t.load(a)
              , u = a.map(d => l[d.src]);
            return new sa({
                data: r,
                textures: u
            },s)
        },
        async load(i, e) {
            return await (await xe.get().fetch(i)).text()
        },
        async unload(i, e, t) {
            await Promise.all(i.pages.map(r => t.unload(r.texture.source._sourceOrigin))),
            i.destroy()
        }
    }
      , Ol = class {
        constructor(e, t=!1) {
            this._loader = e,
            this._assetList = [],
            this._isLoading = !1,
            this._maxConcurrent = 1,
            this.verbose = t
        }
        add(e) {
            e.forEach(t => {
                this._assetList.push(t)
            }
            ),
            this.verbose,
            this._isActive && !this._isLoading && this._next()
        }
        async _next() {
            if (this._assetList.length && this._isActive) {
                this._isLoading = !0;
                let e = []
                  , t = Math.min(this._assetList.length, this._maxConcurrent);
                for (let r = 0; r < t; r++)
                    e.push(this._assetList.pop());
                await this._loader.load(e),
                this._isLoading = !1,
                this._next()
            }
        }
        get active() {
            return this._isActive
        }
        set active(e) {
            this._isActive !== e && (this._isActive = e,
            e && !this._isLoading && this._next())
        }
    }
      , Dv = {
        extension: {
            type: B.CacheParser,
            name: "cacheTextureArray"
        },
        test: i => Array.isArray(i) && i.every(e => e instanceof Z),
        getCacheableAssets: (i, e) => {
            let t = {};
            return i.forEach(r => {
                e.forEach( (s, n) => {
                    t[r + (n === 0 ? "" : n + 1)] = s
                }
                )
            }
            ),
            t
        }
    };
    async function cm(i) {
        if ("Image"in globalThis)
            return new Promise(e => {
                let t = new Image;
                t.onload = () => {
                    e(!0)
                }
                ,
                t.onerror = () => {
                    e(!1)
                }
                ,
                t.src = i
            }
            );
        if ("createImageBitmap"in globalThis && "fetch"in globalThis) {
            try {
                let e = await (await fetch(i)).blob();
                await createImageBitmap(e)
            } catch {
                return !1
            }
            return !0
        }
        return !1
    }
    var kv = {
        extension: {
            type: B.DetectionParser,
            priority: 1
        },
        test: async () => cm("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),
        add: async i => [...i, "avif"],
        remove: async i => i.filter(e => e !== "avif")
    }
      , Vf = ["png", "jpg", "jpeg"]
      , Uv = {
        extension: {
            type: B.DetectionParser,
            priority: -1
        },
        test: () => Promise.resolve(!0),
        add: async i => [...i, ...Vf],
        remove: async i => i.filter(e => !Vf.includes(e))
    }
      , Lv = "WorkerGlobalScope"in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
    function _o(i) {
        return Lv ? !1 : document.createElement("video").canPlayType(i) !== ""
    }
    var Nv = {
        extension: {
            type: B.DetectionParser,
            priority: 0
        },
        test: async () => _o("video/mp4"),
        add: async i => [...i, "mp4", "m4v"],
        remove: async i => i.filter(e => e !== "mp4" && e !== "m4v")
    }
      , Xv = {
        extension: {
            type: B.DetectionParser,
            priority: 0
        },
        test: async () => _o("video/ogg"),
        add: async i => [...i, "ogv"],
        remove: async i => i.filter(e => e !== "ogv")
    }
      , jv = {
        extension: {
            type: B.DetectionParser,
            priority: 0
        },
        test: async () => _o("video/webm"),
        add: async i => [...i, "webm"],
        remove: async i => i.filter(e => e !== "webm")
    }
      , Hv = {
        extension: {
            type: B.DetectionParser,
            priority: 0
        },
        test: async () => cm("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),
        add: async i => [...i, "webp"],
        remove: async i => i.filter(e => e !== "webp")
    }
      , Il = class {
        constructor() {
            this._parsers = [],
            this._parsersValidated = !1,
            this.parsers = new Proxy(this._parsers,{
                set: (e, t, r) => (this._parsersValidated = !1,
                e[t] = r,
                !0)
            }),
            this.promiseCache = {}
        }
        reset() {
            this._parsersValidated = !1,
            this.promiseCache = {}
        }
        _getLoadPromiseAndParser(e, t) {
            let r = {
                promise: null,
                parser: null
            };
            return r.promise = (async () => {
                var s, n;
                let a = null
                  , c = null;
                if ((t.parser || t.loadParser) && (c = this._parserHash[t.parser || t.loadParser]),
                !c) {
                    for (let l = 0; l < this.parsers.length; l++) {
                        let u = this.parsers[l];
                        if (u.load && (s = u.test) != null && s.call(u, e, t, this)) {
                            c = u;
                            break
                        }
                    }
                    if (!c)
                        return null
                }
                a = await c.load(e, t, this),
                r.parser = c;
                for (let l = 0; l < this.parsers.length; l++) {
                    let u = this.parsers[l];
                    u.parse && u.parse && await ((n = u.testParse) == null ? void 0 : n.call(u, a, t, this)) && (a = await u.parse(a, t, this) || a,
                    r.parser = u)
                }
                return a
            }
            )(),
            r
        }
        async load(e, t) {
            this._parsersValidated || this._validateParsers();
            let r = 0
              , s = {}
              , n = Tn(e)
              , a = qt(e, u => ({
                alias: [u],
                src: u,
                data: {}
            }))
              , c = a.length
              , l = a.map(async u => {
                let d = Gt.toAbsolute(u.src);
                if (!s[u.src])
                    try {
                        this.promiseCache[d] || (this.promiseCache[d] = this._getLoadPromiseAndParser(d, u)),
                        s[u.src] = await this.promiseCache[d].promise,
                        t && t(++r / c)
                    } catch (f) {
                        throw delete this.promiseCache[d],
                        delete s[u.src],
                        new Error(`[Loader.load] Failed to load ${d}.
${f}`)
                    }
            }
            );
            return await Promise.all(l),
            n ? s[a[0].src] : s
        }
        async unload(e) {
            let t = qt(e, r => ({
                alias: [r],
                src: r
            })).map(async r => {
                var s, n;
                let a = Gt.toAbsolute(r.src)
                  , c = this.promiseCache[a];
                if (c) {
                    let l = await c.promise;
                    delete this.promiseCache[a],
                    await ((n = (s = c.parser) == null ? void 0 : s.unload) == null ? void 0 : n.call(s, l, r, this))
                }
            }
            );
            await Promise.all(t)
        }
        _validateParsers() {
            this._parsersValidated = !0,
            this._parserHash = this._parsers.filter(e => e.name || e.id).reduce( (e, t) => (!t.name && !t.id || e[t.name] || e[t.id],
            e[t.name] = t,
            t.id && (e[t.id] = t),
            e), {})
        }
    }
    ;
    function Or(i, e) {
        if (Array.isArray(e)) {
            for (let t of e)
                if (i.startsWith(`data:${t}`))
                    return !0;
            return !1
        }
        return i.startsWith(`data:${e}`)
    }
    function ei(i, e) {
        let t = i.split("?")[0]
          , r = Gt.extname(t).toLowerCase();
        return Array.isArray(e) ? e.includes(r) : r === e
    }
    var zv = ".json"
      , Vv = "application/json"
      , Wv = {
        extension: {
            type: B.LoadParser,
            priority: jt.Low
        },
        name: "loadJson",
        id: "json",
        test(i) {
            return Or(i, Vv) || ei(i, zv)
        },
        async load(i) {
            return await (await xe.get().fetch(i)).json()
        }
    }
      , Yv = ".txt"
      , $v = "text/plain"
      , Kv = {
        name: "loadTxt",
        id: "text",
        extension: {
            type: B.LoadParser,
            priority: jt.Low,
            name: "loadTxt"
        },
        test(i) {
            return Or(i, $v) || ei(i, Yv)
        },
        async load(i) {
            return await (await xe.get().fetch(i)).text()
        }
    }
      , qv = Object.defineProperty
      , Zv = Object.defineProperties
      , Qv = Object.getOwnPropertyDescriptors
      , Wf = Object.getOwnPropertySymbols
      , Jv = Object.prototype.hasOwnProperty
      , e4 = Object.prototype.propertyIsEnumerable
      , Yf = (i, e, t) => e in i ? qv(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , t4 = (i, e) => {
        for (var t in e || (e = {}))
            Jv.call(e, t) && Yf(i, t, e[t]);
        if (Wf)
            for (var t of Wf(e))
                e4.call(e, t) && Yf(i, t, e[t]);
        return i
    }
      , i4 = (i, e) => Zv(i, Qv(e))
      , r4 = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"]
      , s4 = [".ttf", ".otf", ".woff", ".woff2"]
      , n4 = ["font/ttf", "font/otf", "font/woff", "font/woff2"]
      , a4 = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
    function o4(i) {
        let e = Gt.extname(i)
          , t = Gt.basename(i, e).replace(/(-|_)/g, " ").toLowerCase().split(" ").map(n => n.charAt(0).toUpperCase() + n.slice(1))
          , r = t.length > 0;
        for (let n of t)
            if (!n.match(a4)) {
                r = !1;
                break
            }
        let s = t.join(" ");
        return r || (s = `"${s.replace(/[\\"]/g, "\\$&")}"`),
        s
    }
    var c4 = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
    function l4(i) {
        return c4.test(i) ? i : encodeURI(i)
    }
    var h4 = {
        extension: {
            type: B.LoadParser,
            priority: jt.Low
        },
        name: "loadWebFont",
        id: "web-font",
        test(i) {
            return Or(i, n4) || ei(i, s4)
        },
        async load(i, e) {
            var t, r, s, n, a, c;
            let l = xe.get().getFontFaceSet();
            if (l) {
                let u = []
                  , d = (r = (t = e.data) == null ? void 0 : t.family) != null ? r : o4(i)
                  , f = (a = (n = (s = e.data) == null ? void 0 : s.weights) == null ? void 0 : n.filter(m => r4.includes(m))) != null ? a : ["normal"]
                  , b = (c = e.data) != null ? c : {};
                for (let m = 0; m < f.length; m++) {
                    let x = f[m]
                      , y = new FontFace(d,`url(${l4(i)})`,i4(t4({}, b), {
                        weight: x
                    }));
                    await y.load(),
                    l.add(y),
                    u.push(y)
                }
                return Oe.has(`${d}-and-url`) ? Oe.get(`${d}-and-url`).entries.push({
                    url: i,
                    faces: u
                }) : Oe.set(`${d}-and-url`, {
                    entries: [{
                        url: i,
                        faces: u
                    }]
                }),
                u.length === 1 ? u[0] : u
            }
            return null
        },
        unload(i) {
            let e = Array.isArray(i) ? i : [i]
              , t = e[0].family
              , r = Oe.get(`${t}-and-url`)
              , s = r.entries.find(n => n.faces.some(a => e.indexOf(a) !== -1));
            s.faces = s.faces.filter(n => e.indexOf(n) === -1),
            s.faces.length === 0 && (r.entries = r.entries.filter(n => n !== s)),
            e.forEach(n => {
                xe.get().getFontFaceSet().delete(n)
            }
            ),
            r.entries.length === 0 && Oe.remove(`${t}-and-url`)
        }
    };
    function kh(i, e=1) {
        var t;
        let r = (t = xi.RETINA_PREFIX) == null ? void 0 : t.exec(i);
        return r ? parseFloat(r[1]) : e
    }
    function ir(i, e, t) {
        i.label = t,
        i._sourceOrigin = t;
        let r = new Z({
            source: i,
            label: t
        })
          , s = () => {
            delete e.promiseCache[t],
            Oe.has(t) && Oe.remove(t)
        }
        ;
        return r.source.once("destroy", () => {
            e.promiseCache[t] && s()
        }
        ),
        r.once("destroy", () => {
            i.destroyed || s()
        }
        ),
        r
    }
    var u4 = Object.defineProperty
      , na = Object.getOwnPropertySymbols
      , lm = Object.prototype.hasOwnProperty
      , hm = Object.prototype.propertyIsEnumerable
      , $f = (i, e, t) => e in i ? u4(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , d4 = (i, e) => {
        for (var t in e || (e = {}))
            lm.call(e, t) && $f(i, t, e[t]);
        if (na)
            for (var t of na(e))
                hm.call(e, t) && $f(i, t, e[t]);
        return i
    }
      , f4 = (i, e) => {
        var t = {};
        for (var r in i)
            lm.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && na)
            for (var r of na(i))
                e.indexOf(r) < 0 && hm.call(i, r) && (t[r] = i[r]);
        return t
    }
      , p4 = ".svg"
      , b4 = "image/svg+xml"
      , m4 = {
        extension: {
            type: B.LoadParser,
            priority: jt.Low,
            name: "loadSVG"
        },
        name: "loadSVG",
        id: "svg",
        config: {
            crossOrigin: "anonymous",
            parseAsGraphicsContext: !1
        },
        test(i) {
            return Or(i, b4) || ei(i, p4)
        },
        async load(i, e, t) {
            var r, s;
            return ((s = (r = e.data) == null ? void 0 : r.parseAsGraphicsContext) != null ? s : this.config.parseAsGraphicsContext) ? _4(i) : g4(i, e, t, this.config.crossOrigin)
        },
        unload(i) {
            i.destroy(!0)
        }
    };
    async function g4(i, e, t, r) {
        var s, n, a, c, l, u;
        let d = await xe.get().fetch(i)
          , f = xe.get().createImage();
        f.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(await d.text())}`,
        f.crossOrigin = r,
        await f.decode();
        let b = (n = (s = e.data) == null ? void 0 : s.width) != null ? n : f.width
          , m = (c = (a = e.data) == null ? void 0 : a.height) != null ? c : f.height
          , x = ((l = e.data) == null ? void 0 : l.resolution) || kh(i)
          , y = Math.ceil(b * x)
          , S = Math.ceil(m * x)
          , A = xe.get().createCanvas(y, S)
          , E = A.getContext("2d");
        E.imageSmoothingEnabled = !0,
        E.imageSmoothingQuality = "high",
        E.drawImage(f, 0, 0, b * x, m * x);
        let O = (u = e.data) != null ? u : {}
          , {parseAsGraphicsContext: M} = O
          , j = f4(O, ["parseAsGraphicsContext"])
          , L = new yi(d4({
            resource: A,
            alphaMode: "premultiply-alpha-on-upload",
            resolution: x
        }, j));
        return ir(L, t, i)
    }
    async function _4(i) {
        let e = await (await xe.get().fetch(i)).text()
          , t = new wt;
        return t.svg(e),
        t
    }
    var x4 = `(function(){"use strict";const e="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";async function a(){try{if(typeof createImageBitmap!="function")return!1;const A=await(await fetch(e)).blob(),t=await createImageBitmap(A);return t.width===1&&t.height===1}catch(A){return!1}}a().then(A=>{self.postMessage(A)})})();
`
      , _r = null
      , Gl = class {
        constructor() {
            _r || (_r = URL.createObjectURL(new Blob([x4],{
                type: "application/javascript"
            }))),
            this.worker = new Worker(_r)
        }
    }
    ;
    Gl.revokeObjectURL = function() {
        _r && (URL.revokeObjectURL(_r),
        _r = null)
    }
    ;
    var y4 = '(function(){"use strict";async function s(a,t){const e=await fetch(a);if(!e.ok)throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${a}: ${e.status} ${e.statusText}`);const i=await e.blob();return t==="premultiplied-alpha"?createImageBitmap(i,{premultiplyAlpha:"none"}):createImageBitmap(i)}self.onmessage=async a=>{try{const t=await s(a.data.data[0],a.data.data[1]);self.postMessage({data:t,uuid:a.data.uuid,id:a.data.id},[t])}catch(t){self.postMessage({error:t,uuid:a.data.uuid,id:a.data.id})}}})();\n'
      , xr = null
      , um = class {
        constructor() {
            xr || (xr = URL.createObjectURL(new Blob([y4],{
                type: "application/javascript"
            }))),
            this.worker = new Worker(xr)
        }
    }
    ;
    um.revokeObjectURL = function() {
        xr && (URL.revokeObjectURL(xr),
        xr = null)
    }
    ;
    var Kf = 0, uc, v4 = class {
        constructor() {
            this._initialized = !1,
            this._createdWorkers = 0,
            this._workerPool = [],
            this._queue = [],
            this._resolveHash = {}
        }
        isImageBitmapSupported() {
            return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise(i => {
                let {worker: e} = new Gl;
                e.addEventListener("message", t => {
                    e.terminate(),
                    Gl.revokeObjectURL(),
                    i(t.data)
                }
                )
            }
            ),
            this._isImageBitmapSupported)
        }
        loadImageBitmap(i, e) {
            var t;
            return this._run("loadImageBitmap", [i, (t = e?.data) == null ? void 0 : t.alphaMode])
        }
        async _initWorkers() {
            this._initialized || (this._initialized = !0)
        }
        _getWorker() {
            uc === void 0 && (uc = navigator.hardwareConcurrency || 4);
            let i = this._workerPool.pop();
            return !i && this._createdWorkers < uc && (this._createdWorkers++,
            i = new um().worker,
            i.addEventListener("message", e => {
                this._complete(e.data),
                this._returnWorker(e.target),
                this._next()
            }
            )),
            i
        }
        _returnWorker(i) {
            this._workerPool.push(i)
        }
        _complete(i) {
            i.error !== void 0 ? this._resolveHash[i.uuid].reject(i.error) : this._resolveHash[i.uuid].resolve(i.data),
            this._resolveHash[i.uuid] = null
        }
        async _run(i, e) {
            await this._initWorkers();
            let t = new Promise( (r, s) => {
                this._queue.push({
                    id: i,
                    arguments: e,
                    resolve: r,
                    reject: s
                })
            }
            );
            return this._next(),
            t
        }
        _next() {
            if (!this._queue.length)
                return;
            let i = this._getWorker();
            if (!i)
                return;
            let e = this._queue.pop()
              , t = e.id;
            this._resolveHash[Kf] = {
                resolve: e.resolve,
                reject: e.reject
            },
            i.postMessage({
                data: e.arguments,
                uuid: Kf++,
                id: t
            })
        }
        reset() {
            this._workerPool.forEach(i => i.terminate()),
            this._workerPool.length = 0,
            Object.values(this._resolveHash).forEach( ({reject: i}) => {
                i?.(new Error("WorkerManager destroyed"))
            }
            ),
            this._resolveHash = {},
            this._queue.length = 0,
            this._initialized = !1,
            this._createdWorkers = 0
        }
    }
    , qf = new v4, T4 = Object.defineProperty, Zf = Object.getOwnPropertySymbols, S4 = Object.prototype.hasOwnProperty, w4 = Object.prototype.propertyIsEnumerable, Qf = (i, e, t) => e in i ? T4(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t, A4 = (i, e) => {
        for (var t in e || (e = {}))
            S4.call(e, t) && Qf(i, t, e[t]);
        if (Zf)
            for (var t of Zf(e))
                w4.call(e, t) && Qf(i, t, e[t]);
        return i
    }
    , E4 = [".jpeg", ".jpg", ".png", ".webp", ".avif"], P4 = ["image/jpeg", "image/png", "image/webp", "image/avif"];
    async function R4(i, e) {
        var t;
        let r = await xe.get().fetch(i);
        if (!r.ok)
            throw new Error(`[loadImageBitmap] Failed to fetch ${i}: ${r.status} ${r.statusText}`);
        let s = await r.blob();
        return ((t = e?.data) == null ? void 0 : t.alphaMode) === "premultiplied-alpha" ? createImageBitmap(s, {
            premultiplyAlpha: "none"
        }) : createImageBitmap(s)
    }
    var dm = {
        name: "loadTextures",
        id: "texture",
        extension: {
            type: B.LoadParser,
            priority: jt.High,
            name: "loadTextures"
        },
        config: {
            preferWorkers: !0,
            preferCreateImageBitmap: !0,
            crossOrigin: "anonymous"
        },
        test(i) {
            return Or(i, P4) || ei(i, E4)
        },
        async load(i, e, t) {
            var r;
            let s = null;
            globalThis.createImageBitmap && this.config.preferCreateImageBitmap ? this.config.preferWorkers && await qf.isImageBitmapSupported() ? s = await qf.loadImageBitmap(i, e) : s = await R4(i, e) : s = await new Promise( (a, c) => {
                s = xe.get().createImage(),
                s.crossOrigin = this.config.crossOrigin,
                s.src = i,
                s.complete ? a(s) : (s.onload = () => {
                    a(s)
                }
                ,
                s.onerror = c)
            }
            );
            let n = new yi(A4({
                resource: s,
                alphaMode: "premultiply-alpha-on-upload",
                resolution: ((r = e.data) == null ? void 0 : r.resolution) || kh(i)
            }, e.data));
            return ir(n, t, i)
        },
        unload(i) {
            i.destroy(!0)
        }
    }, M4 = Object.defineProperty, C4 = Object.defineProperties, O4 = Object.getOwnPropertyDescriptors, Jf = Object.getOwnPropertySymbols, I4 = Object.prototype.hasOwnProperty, G4 = Object.prototype.propertyIsEnumerable, ep = (i, e, t) => e in i ? M4(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t, dc = (i, e) => {
        for (var t in e || (e = {}))
            I4.call(e, t) && ep(i, t, e[t]);
        if (Jf)
            for (var t of Jf(e))
                G4.call(e, t) && ep(i, t, e[t]);
        return i
    }
    , tp = (i, e) => C4(i, O4(e)), B4 = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"], fc, pc;
    function F4(i, e, t) {
        t === void 0 && !e.startsWith("data:") ? i.crossOrigin = k4(e) : t !== !1 && (i.crossOrigin = typeof t == "string" ? t : "anonymous")
    }
    function D4(i) {
        return new Promise( (e, t) => {
            i.addEventListener("canplaythrough", r),
            i.addEventListener("error", s),
            i.load();
            function r() {
                n(),
                e()
            }
            function s(a) {
                n(),
                t(a)
            }
            function n() {
                i.removeEventListener("canplaythrough", r),
                i.removeEventListener("error", s)
            }
        }
        )
    }
    function k4(i, e=globalThis.location) {
        if (i.startsWith("data:"))
            return "";
        e || (e = globalThis.location);
        let t = new URL(i,document.baseURI);
        return t.hostname !== e.hostname || t.port !== e.port || t.protocol !== e.protocol ? "anonymous" : ""
    }
    function U4() {
        let i = []
          , e = [];
        for (let t of B4) {
            let r = ss.MIME_TYPES[t.substring(1)] || `video/${t.substring(1)}`;
            _o(r) && (i.push(t),
            e.includes(r) || e.push(r))
        }
        return {
            validVideoExtensions: i,
            validVideoMime: e
        }
    }
    var L4 = {
        name: "loadVideo",
        id: "video",
        extension: {
            type: B.LoadParser,
            name: "loadVideo"
        },
        test(i) {
            if (!fc || !pc) {
                let {validVideoExtensions: r, validVideoMime: s} = U4();
                fc = r,
                pc = s
            }
            let e = Or(i, pc)
              , t = ei(i, fc);
            return e || t
        },
        async load(i, e, t) {
            var r, s;
            let n = dc(tp(dc({}, ss.defaultOptions), {
                resolution: ((r = e.data) == null ? void 0 : r.resolution) || kh(i),
                alphaMode: ((s = e.data) == null ? void 0 : s.alphaMode) || await u0()
            }), e.data)
              , a = document.createElement("video")
              , c = {
                preload: n.autoLoad !== !1 ? "auto" : void 0,
                "webkit-playsinline": n.playsinline !== !1 ? "" : void 0,
                playsinline: n.playsinline !== !1 ? "" : void 0,
                muted: n.muted === !0 ? "" : void 0,
                loop: n.loop === !0 ? "" : void 0,
                autoplay: n.autoPlay !== !1 ? "" : void 0
            };
            Object.keys(c).forEach(d => {
                let f = c[d];
                f !== void 0 && a.setAttribute(d, f)
            }
            ),
            n.muted === !0 && (a.muted = !0),
            F4(a, i, n.crossorigin);
            let l = document.createElement("source"), u;
            if (n.mime)
                u = n.mime;
            else if (i.startsWith("data:"))
                u = i.slice(5, i.indexOf(";"));
            else if (!i.startsWith("blob:")) {
                let d = i.split("?")[0].slice(i.lastIndexOf(".") + 1).toLowerCase();
                u = ss.MIME_TYPES[d] || `video/${d}`
            }
            return l.src = i,
            u && (l.type = u),
            new Promise(d => {
                let f = async () => {
                    let b = new ss(tp(dc({}, n), {
                        resource: a
                    }));
                    a.removeEventListener("canplay", f),
                    e.data.preload && await D4(a),
                    d(ir(b, t, i))
                }
                ;
                n.preload && !n.autoPlay && a.load(),
                a.addEventListener("canplay", f),
                a.appendChild(l)
            }
            )
        },
        unload(i) {
            i.destroy(!0)
        }
    }
      , fm = {
        extension: {
            type: B.ResolveParser,
            name: "resolveTexture"
        },
        test: dm.test,
        parse: i => {
            var e, t;
            return {
                resolution: parseFloat((t = (e = xi.RETINA_PREFIX.exec(i)) == null ? void 0 : e[1]) != null ? t : "1"),
                format: i.split(".").pop(),
                src: i
            }
        }
    }
      , N4 = {
        extension: {
            type: B.ResolveParser,
            priority: -2,
            name: "resolveJson"
        },
        test: i => xi.RETINA_PREFIX.test(i) && i.endsWith(".json"),
        parse: fm.parse
    }
      , Bl = class {
        constructor() {
            this._detections = [],
            this._initialized = !1,
            this.resolver = new xi,
            this.loader = new Il,
            this.cache = Oe,
            this._backgroundLoader = new Ol(this.loader),
            this._backgroundLoader.active = !0,
            this.reset()
        }
        async init(e={}) {
            var t, r, s;
            if (this._initialized)
                return;
            if (this._initialized = !0,
            e.defaultSearchParams && this.resolver.setDefaultSearchParams(e.defaultSearchParams),
            e.basePath && (this.resolver.basePath = e.basePath),
            e.bundleIdentifier && this.resolver.setBundleIdentifier(e.bundleIdentifier),
            e.manifest) {
                let l = e.manifest;
                typeof l == "string" && (l = await this.load(l)),
                this.resolver.addManifest(l)
            }
            let n = (r = (t = e.texturePreference) == null ? void 0 : t.resolution) != null ? r : 1
              , a = typeof n == "number" ? [n] : n
              , c = await this._detectFormats({
                preferredFormats: (s = e.texturePreference) == null ? void 0 : s.format,
                skipDetections: e.skipDetections,
                detections: this._detections
            });
            this.resolver.prefer({
                params: {
                    format: c,
                    resolution: a
                }
            }),
            e.preferences && this.setPreferences(e.preferences)
        }
        add(e) {
            this.resolver.add(e)
        }
        async load(e, t) {
            this._initialized || await this.init();
            let r = Tn(e)
              , s = qt(e).map(c => {
                if (typeof c != "string") {
                    let l = this.resolver.getAlias(c);
                    return l.some(u => !this.resolver.hasKey(u)) && this.add(c),
                    Array.isArray(l) ? l[0] : l
                }
                return this.resolver.hasKey(c) || this.add({
                    alias: c,
                    src: c
                }),
                c
            }
            )
              , n = this.resolver.resolve(s)
              , a = await this._mapLoadToResolve(n, t);
            return r ? a[s[0]] : a
        }
        addBundle(e, t) {
            this.resolver.addBundle(e, t)
        }
        async loadBundle(e, t) {
            this._initialized || await this.init();
            let r = !1;
            typeof e == "string" && (r = !0,
            e = [e]);
            let s = this.resolver.resolveBundle(e)
              , n = {}
              , a = Object.keys(s)
              , c = 0
              , l = 0
              , u = () => {
                t?.(++c / l)
            }
              , d = a.map(f => {
                let b = s[f]
                  , m = Object.values(b)
                  , x = [...new Set(m.flat())];
                return l += x.length,
                this._mapLoadToResolve(b, u).then(y => {
                    n[f] = y
                }
                )
            }
            );
            return await Promise.all(d),
            r ? n[e[0]] : n
        }
        async backgroundLoad(e) {
            this._initialized || await this.init(),
            typeof e == "string" && (e = [e]);
            let t = this.resolver.resolve(e);
            this._backgroundLoader.add(Object.values(t))
        }
        async backgroundLoadBundle(e) {
            this._initialized || await this.init(),
            typeof e == "string" && (e = [e]);
            let t = this.resolver.resolveBundle(e);
            Object.values(t).forEach(r => {
                this._backgroundLoader.add(Object.values(r))
            }
            )
        }
        reset() {
            this.resolver.reset(),
            this.loader.reset(),
            this.cache.reset(),
            this._initialized = !1
        }
        get(e) {
            if (typeof e == "string")
                return Oe.get(e);
            let t = {};
            for (let r = 0; r < e.length; r++)
                t[r] = Oe.get(e[r]);
            return t
        }
        async _mapLoadToResolve(e, t) {
            let r = [...new Set(Object.values(e))];
            this._backgroundLoader.active = !1;
            let s = await this.loader.load(r, t);
            this._backgroundLoader.active = !0;
            let n = {};
            return r.forEach(a => {
                let c = s[a.src]
                  , l = [a.src];
                a.alias && l.push(...a.alias),
                l.forEach(u => {
                    n[u] = c
                }
                ),
                Oe.set(l, c)
            }
            ),
            n
        }
        async unload(e) {
            this._initialized || await this.init();
            let t = qt(e).map(s => typeof s != "string" ? s.src : s)
              , r = this.resolver.resolve(t);
            await this._unloadFromResolved(r)
        }
        async unloadBundle(e) {
            this._initialized || await this.init(),
            e = qt(e);
            let t = this.resolver.resolveBundle(e)
              , r = Object.keys(t).map(s => this._unloadFromResolved(t[s]));
            await Promise.all(r)
        }
        async _unloadFromResolved(e) {
            let t = Object.values(e);
            t.forEach(r => {
                Oe.remove(r.src)
            }
            ),
            await this.loader.unload(t)
        }
        async _detectFormats(e) {
            let t = [];
            e.preferredFormats && (t = Array.isArray(e.preferredFormats) ? e.preferredFormats : [e.preferredFormats]);
            for (let r of e.detections)
                e.skipDetections || await r.test() ? t = await r.add(t) : e.skipDetections || (t = await r.remove(t));
            return t = t.filter( (r, s) => t.indexOf(r) === s),
            t
        }
        get detections() {
            return this._detections
        }
        setPreferences(e) {
            this.loader.parsers.forEach(t => {
                t.config && Object.keys(t.config).filter(r => r in e).forEach(r => {
                    t.config[r] = e[r]
                }
                )
            }
            )
        }
    }
      , Te = new Bl;
    be.handleByList(B.LoadParser, Te.loader.parsers).handleByList(B.ResolveParser, Te.resolver.parsers).handleByList(B.CacheParser, Te.cache.parsers).handleByList(B.DetectionParser, Te.detections),
    be.add(Dv, Uv, kv, Hv, Nv, Xv, jv, Wv, Kv, h4, m4, dm, L4, Fv, Bv, fm, N4);
    var ip = {
        loader: B.LoadParser,
        resolver: B.ResolveParser,
        cache: B.CacheParser,
        detection: B.DetectionParser
    };
    be.handle(B.Asset, i => {
        let e = i.ref;
        Object.entries(ip).filter( ([t]) => !!e[t]).forEach( ([t,r]) => {
            var s;
            return be.add(Object.assign(e[t], {
                extension: (s = e[t].extension) != null ? s : r
            }))
        }
        )
    }
    , i => {
        let e = i.ref;
        Object.keys(ip).filter(t => !!e[t]).forEach(t => be.remove(e[t]))
    }
    );
    var Tw = {
        extension: {
            type: B.DetectionParser,
            priority: 3
        },
        test: async () => !!(await mo() || bo()),
        add: async i => [...i, "basis"],
        remove: async i => i.filter(e => e !== "basis")
    }, Mr = class extends He {
        constructor(e) {
            super(e),
            this.uploadMethodId = "compressed",
            this.resource = e.resource,
            this.mipLevelCount = this.resource.length
        }
    }
    , Zs;
    function rp() {
        if (Zs)
            return Zs;
        let i = xe.get().createCanvas(1, 1).getContext("webgl");
        return i ? (Zs = [...i.getExtension("EXT_texture_compression_bptc") ? ["bc6h-rgb-ufloat", "bc6h-rgb-float", "bc7-rgba-unorm", "bc7-rgba-unorm-srgb"] : [], ...i.getExtension("WEBGL_compressed_texture_s3tc") ? ["bc1-rgba-unorm", "bc2-rgba-unorm", "bc3-rgba-unorm"] : [], ...i.getExtension("WEBGL_compressed_texture_s3tc_srgb") ? ["bc1-rgba-unorm-srgb", "bc2-rgba-unorm-srgb", "bc3-rgba-unorm-srgb"] : [], ...i.getExtension("EXT_texture_compression_rgtc") ? ["bc4-r-unorm", "bc4-r-snorm", "bc5-rg-unorm", "bc5-rg-snorm"] : [], ...i.getExtension("WEBGL_compressed_texture_etc") ? ["etc2-rgb8unorm", "etc2-rgb8unorm-srgb", "etc2-rgba8unorm", "etc2-rgba8unorm-srgb", "etc2-rgb8a1unorm", "etc2-rgb8a1unorm-srgb", "eac-r11unorm", "eac-rg11unorm"] : [], ...i.getExtension("WEBGL_compressed_texture_astc") ? ["astc-4x4-unorm", "astc-4x4-unorm-srgb", "astc-5x4-unorm", "astc-5x4-unorm-srgb", "astc-5x5-unorm", "astc-5x5-unorm-srgb", "astc-6x5-unorm", "astc-6x5-unorm-srgb", "astc-6x6-unorm", "astc-6x6-unorm-srgb", "astc-8x5-unorm", "astc-8x5-unorm-srgb", "astc-8x6-unorm", "astc-8x6-unorm-srgb", "astc-8x8-unorm", "astc-8x8-unorm-srgb", "astc-10x5-unorm", "astc-10x5-unorm-srgb", "astc-10x6-unorm", "astc-10x6-unorm-srgb", "astc-10x8-unorm", "astc-10x8-unorm-srgb", "astc-10x10-unorm", "astc-10x10-unorm-srgb", "astc-12x10-unorm", "astc-12x10-unorm-srgb", "astc-12x12-unorm", "astc-12x12-unorm-srgb"] : []],
        Zs) : []
    }
    var Qs;
    async function sp() {
        if (Qs)
            return Qs;
        let i = await xe.get().getNavigator().gpu.requestAdapter();
        return Qs = [...i.features.has("texture-compression-bc") ? ["bc1-rgba-unorm", "bc1-rgba-unorm-srgb", "bc2-rgba-unorm", "bc2-rgba-unorm-srgb", "bc3-rgba-unorm", "bc3-rgba-unorm-srgb", "bc4-r-unorm", "bc4-r-snorm", "bc5-rg-unorm", "bc5-rg-snorm", "bc6h-rgb-ufloat", "bc6h-rgb-float", "bc7-rgba-unorm", "bc7-rgba-unorm-srgb"] : [], ...i.features.has("texture-compression-etc2") ? ["etc2-rgb8unorm", "etc2-rgb8unorm-srgb", "etc2-rgb8a1unorm", "etc2-rgb8a1unorm-srgb", "etc2-rgba8unorm", "etc2-rgba8unorm-srgb", "eac-r11unorm", "eac-r11snorm", "eac-rg11unorm", "eac-rg11snorm"] : [], ...i.features.has("texture-compression-astc") ? ["astc-4x4-unorm", "astc-4x4-unorm-srgb", "astc-5x4-unorm", "astc-5x4-unorm-srgb", "astc-5x5-unorm", "astc-5x5-unorm-srgb", "astc-6x5-unorm", "astc-6x5-unorm-srgb", "astc-6x6-unorm", "astc-6x6-unorm-srgb", "astc-8x5-unorm", "astc-8x5-unorm-srgb", "astc-8x6-unorm", "astc-8x6-unorm-srgb", "astc-8x8-unorm", "astc-8x8-unorm-srgb", "astc-10x5-unorm", "astc-10x5-unorm-srgb", "astc-10x6-unorm", "astc-10x6-unorm-srgb", "astc-10x8-unorm", "astc-10x8-unorm-srgb", "astc-10x10-unorm", "astc-10x10-unorm-srgb", "astc-12x10-unorm", "astc-12x10-unorm-srgb", "astc-12x12-unorm", "astc-12x12-unorm-srgb"] : []],
        Qs
    }
    var bc;
    async function pm() {
        return bc !== void 0 || (bc = await (async () => {
            let i = await mo()
              , e = bo();
            if (i && e) {
                let t = await sp()
                  , r = rp();
                return t.filter(s => r.includes(s))
            } else {
                if (i)
                    return await sp();
                if (e)
                    return rp()
            }
            return []
        }
        )()),
        bc
    }
    var X4 = ["r8unorm", "r8snorm", "r8uint", "r8sint", "r16uint", "r16sint", "r16float", "rg8unorm", "rg8snorm", "rg8uint", "rg8sint", "r32uint", "r32sint", "r32float", "rg16uint", "rg16sint", "rg16float", "rgba8unorm", "rgba8unorm-srgb", "rgba8snorm", "rgba8uint", "rgba8sint", "bgra8unorm", "bgra8unorm-srgb", "rgb9e5ufloat", "rgb10a2unorm", "rg11b10ufloat", "rg32uint", "rg32sint", "rg32float", "rgba16uint", "rgba16sint", "rgba16float", "rgba32uint", "rgba32sint", "rgba32float", "stencil8", "depth16unorm", "depth24plus", "depth24plus-stencil8", "depth32float", "depth32float-stencil8"], Js;
    async function xo() {
        if (Js !== void 0)
            return Js;
        let i = await pm();
        return Js = [...X4, ...i],
        Js
    }
    var j4 = '(function(){"use strict";function g(r,a){const t=r.getNumImages(),s=r.getNumLevels(0);if(!r.startTranscoding())throw new Error("startTranscoding failed");const m=[];for(let e=0;e<s;++e)for(let o=0;o<t;++o){const B=r.getImageTranscodedSizeInBytes(o,e,a),f=new Uint8Array(B);if(!r.transcodeImage(f,o,e,a,1,0))throw new Error("transcodeImage failed");m.push(f)}return m}const w={"bc3-rgba-unorm":3,"bc7-rgba-unorm":6,"etc2-rgba8unorm":1,"astc-4x4-unorm":10,rgba8unorm:13,rgba4unorm:16};function d(r){const a=w[r];if(a)return a;throw new Error(`Unsupported transcoderFormat: ${r}`)}const n={jsUrl:"basis/basis_transcoder.js",wasmUrl:"basis/basis_transcoder.wasm"};let u,i,c;async function l(){if(!c){const r=new URL(n.jsUrl,location.origin).href,a=new URL(n.wasmUrl,location.origin).href;importScripts(r),c=new Promise(t=>{BASIS({locateFile:s=>a}).then(s=>{s.initializeBasis(),t(s.BasisFile)})})}return c}async function b(r,a){const t=await fetch(r);if(t.ok){const s=await t.arrayBuffer();return new a(new Uint8Array(s))}throw new Error(`Failed to load Basis texture: ${r}`)}const h=["bc7-rgba-unorm","astc-4x4-unorm","etc2-rgba8unorm","bc3-rgba-unorm","rgba8unorm"];async function p(r){const a=await l(),t=await b(r,a),s=g(t,u);return{width:t.getImageWidth(0,0),height:t.getImageHeight(0,0),format:i,resource:s,alphaMode:"no-premultiply-alpha"}}async function y(r,a,t){r&&(n.jsUrl=r),a&&(n.wasmUrl=a),i=h.filter(s=>t.includes(s))[0],u=d(i),await l()}const U={init:async r=>{const{jsUrl:a,wasmUrl:t,supportedTextures:s}=r;await y(a,t,s)},load:async r=>{var a;try{const t=await p(r.url);return{type:"load",url:r.url,success:!0,textureOptions:t,transferables:(a=t.resource)==null?void 0:a.map(s=>s.buffer)}}catch(t){throw t}}};self.onmessage=async r=>{const a=r.data,t=await U[a.type](a);t&&self.postMessage(t,t.transferables)}})();\n'
      , yr = null
      , bm = class {
        constructor() {
            yr || (yr = URL.createObjectURL(new Blob([j4],{
                type: "application/javascript"
            }))),
            this.worker = new Worker(yr)
        }
    }
    ;
    bm.revokeObjectURL = function() {
        yr && (URL.revokeObjectURL(yr),
        yr = null)
    }
    ;
    var np = {
        jsUrl: "https://files.pixijs.download/transcoders/basis/basis_transcoder.js",
        wasmUrl: "https://files.pixijs.download/transcoders/basis/basis_transcoder.wasm"
    };
    var zr, mm = {};
    function H4(i) {
        return zr || (zr = new bm().worker,
        zr.onmessage = e => {
            let {success: t, url: r, textureOptions: s} = e.data;
            mm[r](s)
        }
        ,
        zr.postMessage({
            type: "init",
            jsUrl: np.jsUrl,
            wasmUrl: np.wasmUrl,
            supportedTextures: i
        })),
        zr
    }
    function z4(i, e) {
        let t = H4(e);
        return new Promise(r => {
            mm[i] = r,
            t.postMessage({
                type: "load",
                url: i
            })
        }
        )
    }
    var Sw = {
        extension: {
            type: B.LoadParser,
            priority: jt.High,
            name: "loadBasis"
        },
        name: "loadBasis",
        id: "basis",
        test(i) {
            return ei(i, [".basis"])
        },
        async load(i, e, t) {
            let r = await xo()
              , s = await z4(i, r)
              , n = new Mr(s);
            return ir(n, t, i)
        },
        unload(i) {
            Array.isArray(i) ? i.forEach(e => e.destroy(!0)) : i.destroy(!0)
        }
    };
    var V4 = {
        MAGIC: 0,
        SIZE: 1,
        FLAGS: 2,
        HEIGHT: 3,
        WIDTH: 4,
        MIPMAP_COUNT: 7,
        PIXEL_FORMAT: 19,
        PF_FLAGS: 20,
        FOURCC: 21,
        RGB_BITCOUNT: 22,
        R_BIT_MASK: 23,
        G_BIT_MASK: 24,
        B_BIT_MASK: 25,
        A_BIT_MASK: 26
    }
      , W4 = {
        DXGI_FORMAT: 0,
        RESOURCE_DIMENSION: 1,
        MISC_FLAG: 2,
        ARRAY_SIZE: 3,
        MISC_FLAGS2: 4
    }
      , gm = (i => (i[i.DXGI_FORMAT_UNKNOWN = 0] = "DXGI_FORMAT_UNKNOWN",
    i[i.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS",
    i[i.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT",
    i[i.DXGI_FORMAT_R32G32B32A32_UINT = 3] = "DXGI_FORMAT_R32G32B32A32_UINT",
    i[i.DXGI_FORMAT_R32G32B32A32_SINT = 4] = "DXGI_FORMAT_R32G32B32A32_SINT",
    i[i.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS",
    i[i.DXGI_FORMAT_R32G32B32_FLOAT = 6] = "DXGI_FORMAT_R32G32B32_FLOAT",
    i[i.DXGI_FORMAT_R32G32B32_UINT = 7] = "DXGI_FORMAT_R32G32B32_UINT",
    i[i.DXGI_FORMAT_R32G32B32_SINT = 8] = "DXGI_FORMAT_R32G32B32_SINT",
    i[i.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS",
    i[i.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT",
    i[i.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM",
    i[i.DXGI_FORMAT_R16G16B16A16_UINT = 12] = "DXGI_FORMAT_R16G16B16A16_UINT",
    i[i.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM",
    i[i.DXGI_FORMAT_R16G16B16A16_SINT = 14] = "DXGI_FORMAT_R16G16B16A16_SINT",
    i[i.DXGI_FORMAT_R32G32_TYPELESS = 15] = "DXGI_FORMAT_R32G32_TYPELESS",
    i[i.DXGI_FORMAT_R32G32_FLOAT = 16] = "DXGI_FORMAT_R32G32_FLOAT",
    i[i.DXGI_FORMAT_R32G32_UINT = 17] = "DXGI_FORMAT_R32G32_UINT",
    i[i.DXGI_FORMAT_R32G32_SINT = 18] = "DXGI_FORMAT_R32G32_SINT",
    i[i.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS",
    i[i.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT",
    i[i.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS",
    i[i.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT",
    i[i.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS",
    i[i.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM",
    i[i.DXGI_FORMAT_R10G10B10A2_UINT = 25] = "DXGI_FORMAT_R10G10B10A2_UINT",
    i[i.DXGI_FORMAT_R11G11B10_FLOAT = 26] = "DXGI_FORMAT_R11G11B10_FLOAT",
    i[i.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS",
    i[i.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM",
    i[i.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB",
    i[i.DXGI_FORMAT_R8G8B8A8_UINT = 30] = "DXGI_FORMAT_R8G8B8A8_UINT",
    i[i.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM",
    i[i.DXGI_FORMAT_R8G8B8A8_SINT = 32] = "DXGI_FORMAT_R8G8B8A8_SINT",
    i[i.DXGI_FORMAT_R16G16_TYPELESS = 33] = "DXGI_FORMAT_R16G16_TYPELESS",
    i[i.DXGI_FORMAT_R16G16_FLOAT = 34] = "DXGI_FORMAT_R16G16_FLOAT",
    i[i.DXGI_FORMAT_R16G16_UNORM = 35] = "DXGI_FORMAT_R16G16_UNORM",
    i[i.DXGI_FORMAT_R16G16_UINT = 36] = "DXGI_FORMAT_R16G16_UINT",
    i[i.DXGI_FORMAT_R16G16_SNORM = 37] = "DXGI_FORMAT_R16G16_SNORM",
    i[i.DXGI_FORMAT_R16G16_SINT = 38] = "DXGI_FORMAT_R16G16_SINT",
    i[i.DXGI_FORMAT_R32_TYPELESS = 39] = "DXGI_FORMAT_R32_TYPELESS",
    i[i.DXGI_FORMAT_D32_FLOAT = 40] = "DXGI_FORMAT_D32_FLOAT",
    i[i.DXGI_FORMAT_R32_FLOAT = 41] = "DXGI_FORMAT_R32_FLOAT",
    i[i.DXGI_FORMAT_R32_UINT = 42] = "DXGI_FORMAT_R32_UINT",
    i[i.DXGI_FORMAT_R32_SINT = 43] = "DXGI_FORMAT_R32_SINT",
    i[i.DXGI_FORMAT_R24G8_TYPELESS = 44] = "DXGI_FORMAT_R24G8_TYPELESS",
    i[i.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT",
    i[i.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS",
    i[i.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT",
    i[i.DXGI_FORMAT_R8G8_TYPELESS = 48] = "DXGI_FORMAT_R8G8_TYPELESS",
    i[i.DXGI_FORMAT_R8G8_UNORM = 49] = "DXGI_FORMAT_R8G8_UNORM",
    i[i.DXGI_FORMAT_R8G8_UINT = 50] = "DXGI_FORMAT_R8G8_UINT",
    i[i.DXGI_FORMAT_R8G8_SNORM = 51] = "DXGI_FORMAT_R8G8_SNORM",
    i[i.DXGI_FORMAT_R8G8_SINT = 52] = "DXGI_FORMAT_R8G8_SINT",
    i[i.DXGI_FORMAT_R16_TYPELESS = 53] = "DXGI_FORMAT_R16_TYPELESS",
    i[i.DXGI_FORMAT_R16_FLOAT = 54] = "DXGI_FORMAT_R16_FLOAT",
    i[i.DXGI_FORMAT_D16_UNORM = 55] = "DXGI_FORMAT_D16_UNORM",
    i[i.DXGI_FORMAT_R16_UNORM = 56] = "DXGI_FORMAT_R16_UNORM",
    i[i.DXGI_FORMAT_R16_UINT = 57] = "DXGI_FORMAT_R16_UINT",
    i[i.DXGI_FORMAT_R16_SNORM = 58] = "DXGI_FORMAT_R16_SNORM",
    i[i.DXGI_FORMAT_R16_SINT = 59] = "DXGI_FORMAT_R16_SINT",
    i[i.DXGI_FORMAT_R8_TYPELESS = 60] = "DXGI_FORMAT_R8_TYPELESS",
    i[i.DXGI_FORMAT_R8_UNORM = 61] = "DXGI_FORMAT_R8_UNORM",
    i[i.DXGI_FORMAT_R8_UINT = 62] = "DXGI_FORMAT_R8_UINT",
    i[i.DXGI_FORMAT_R8_SNORM = 63] = "DXGI_FORMAT_R8_SNORM",
    i[i.DXGI_FORMAT_R8_SINT = 64] = "DXGI_FORMAT_R8_SINT",
    i[i.DXGI_FORMAT_A8_UNORM = 65] = "DXGI_FORMAT_A8_UNORM",
    i[i.DXGI_FORMAT_R1_UNORM = 66] = "DXGI_FORMAT_R1_UNORM",
    i[i.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP",
    i[i.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM",
    i[i.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM",
    i[i.DXGI_FORMAT_BC1_TYPELESS = 70] = "DXGI_FORMAT_BC1_TYPELESS",
    i[i.DXGI_FORMAT_BC1_UNORM = 71] = "DXGI_FORMAT_BC1_UNORM",
    i[i.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB",
    i[i.DXGI_FORMAT_BC2_TYPELESS = 73] = "DXGI_FORMAT_BC2_TYPELESS",
    i[i.DXGI_FORMAT_BC2_UNORM = 74] = "DXGI_FORMAT_BC2_UNORM",
    i[i.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB",
    i[i.DXGI_FORMAT_BC3_TYPELESS = 76] = "DXGI_FORMAT_BC3_TYPELESS",
    i[i.DXGI_FORMAT_BC3_UNORM = 77] = "DXGI_FORMAT_BC3_UNORM",
    i[i.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB",
    i[i.DXGI_FORMAT_BC4_TYPELESS = 79] = "DXGI_FORMAT_BC4_TYPELESS",
    i[i.DXGI_FORMAT_BC4_UNORM = 80] = "DXGI_FORMAT_BC4_UNORM",
    i[i.DXGI_FORMAT_BC4_SNORM = 81] = "DXGI_FORMAT_BC4_SNORM",
    i[i.DXGI_FORMAT_BC5_TYPELESS = 82] = "DXGI_FORMAT_BC5_TYPELESS",
    i[i.DXGI_FORMAT_BC5_UNORM = 83] = "DXGI_FORMAT_BC5_UNORM",
    i[i.DXGI_FORMAT_BC5_SNORM = 84] = "DXGI_FORMAT_BC5_SNORM",
    i[i.DXGI_FORMAT_B5G6R5_UNORM = 85] = "DXGI_FORMAT_B5G6R5_UNORM",
    i[i.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM",
    i[i.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM",
    i[i.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM",
    i[i.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM",
    i[i.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS",
    i[i.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB",
    i[i.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS",
    i[i.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB",
    i[i.DXGI_FORMAT_BC6H_TYPELESS = 94] = "DXGI_FORMAT_BC6H_TYPELESS",
    i[i.DXGI_FORMAT_BC6H_UF16 = 95] = "DXGI_FORMAT_BC6H_UF16",
    i[i.DXGI_FORMAT_BC6H_SF16 = 96] = "DXGI_FORMAT_BC6H_SF16",
    i[i.DXGI_FORMAT_BC7_TYPELESS = 97] = "DXGI_FORMAT_BC7_TYPELESS",
    i[i.DXGI_FORMAT_BC7_UNORM = 98] = "DXGI_FORMAT_BC7_UNORM",
    i[i.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB",
    i[i.DXGI_FORMAT_AYUV = 100] = "DXGI_FORMAT_AYUV",
    i[i.DXGI_FORMAT_Y410 = 101] = "DXGI_FORMAT_Y410",
    i[i.DXGI_FORMAT_Y416 = 102] = "DXGI_FORMAT_Y416",
    i[i.DXGI_FORMAT_NV12 = 103] = "DXGI_FORMAT_NV12",
    i[i.DXGI_FORMAT_P010 = 104] = "DXGI_FORMAT_P010",
    i[i.DXGI_FORMAT_P016 = 105] = "DXGI_FORMAT_P016",
    i[i.DXGI_FORMAT_420_OPAQUE = 106] = "DXGI_FORMAT_420_OPAQUE",
    i[i.DXGI_FORMAT_YUY2 = 107] = "DXGI_FORMAT_YUY2",
    i[i.DXGI_FORMAT_Y210 = 108] = "DXGI_FORMAT_Y210",
    i[i.DXGI_FORMAT_Y216 = 109] = "DXGI_FORMAT_Y216",
    i[i.DXGI_FORMAT_NV11 = 110] = "DXGI_FORMAT_NV11",
    i[i.DXGI_FORMAT_AI44 = 111] = "DXGI_FORMAT_AI44",
    i[i.DXGI_FORMAT_IA44 = 112] = "DXGI_FORMAT_IA44",
    i[i.DXGI_FORMAT_P8 = 113] = "DXGI_FORMAT_P8",
    i[i.DXGI_FORMAT_A8P8 = 114] = "DXGI_FORMAT_A8P8",
    i[i.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM",
    i[i.DXGI_FORMAT_P208 = 116] = "DXGI_FORMAT_P208",
    i[i.DXGI_FORMAT_V208 = 117] = "DXGI_FORMAT_V208",
    i[i.DXGI_FORMAT_V408 = 118] = "DXGI_FORMAT_V408",
    i[i.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE",
    i[i.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE",
    i[i.DXGI_FORMAT_FORCE_UINT = 121] = "DXGI_FORMAT_FORCE_UINT",
    i))(gm || {})
      , _m = (i => (i[i.DDS_DIMENSION_TEXTURE1D = 2] = "DDS_DIMENSION_TEXTURE1D",
    i[i.DDS_DIMENSION_TEXTURE2D = 3] = "DDS_DIMENSION_TEXTURE2D",
    i[i.DDS_DIMENSION_TEXTURE3D = 6] = "DDS_DIMENSION_TEXTURE3D",
    i))(_m || {});
    function rt(i) {
        return i.charCodeAt(0) + (i.charCodeAt(1) << 8) + (i.charCodeAt(2) << 16) + (i.charCodeAt(3) << 24)
    }
    var Mt = (i => (i[i.UNKNOWN = 0] = "UNKNOWN",
    i[i.R8G8B8 = 20] = "R8G8B8",
    i[i.A8R8G8B8 = 21] = "A8R8G8B8",
    i[i.X8R8G8B8 = 22] = "X8R8G8B8",
    i[i.R5G6B5 = 23] = "R5G6B5",
    i[i.X1R5G5B5 = 24] = "X1R5G5B5",
    i[i.A1R5G5B5 = 25] = "A1R5G5B5",
    i[i.A4R4G4B4 = 26] = "A4R4G4B4",
    i[i.R3G3B2 = 27] = "R3G3B2",
    i[i.A8 = 28] = "A8",
    i[i.A8R3G3B2 = 29] = "A8R3G3B2",
    i[i.X4R4G4B4 = 30] = "X4R4G4B4",
    i[i.A2B10G10R10 = 31] = "A2B10G10R10",
    i[i.A8B8G8R8 = 32] = "A8B8G8R8",
    i[i.X8B8G8R8 = 33] = "X8B8G8R8",
    i[i.G16R16 = 34] = "G16R16",
    i[i.A2R10G10B10 = 35] = "A2R10G10B10",
    i[i.A16B16G16R16 = 36] = "A16B16G16R16",
    i[i.A8P8 = 40] = "A8P8",
    i[i.P8 = 41] = "P8",
    i[i.L8 = 50] = "L8",
    i[i.A8L8 = 51] = "A8L8",
    i[i.A4L4 = 52] = "A4L4",
    i[i.V8U8 = 60] = "V8U8",
    i[i.L6V5U5 = 61] = "L6V5U5",
    i[i.X8L8V8U8 = 62] = "X8L8V8U8",
    i[i.Q8W8V8U8 = 63] = "Q8W8V8U8",
    i[i.V16U16 = 64] = "V16U16",
    i[i.A2W10V10U10 = 67] = "A2W10V10U10",
    i[i.Q16W16V16U16 = 110] = "Q16W16V16U16",
    i[i.R16F = 111] = "R16F",
    i[i.G16R16F = 112] = "G16R16F",
    i[i.A16B16G16R16F = 113] = "A16B16G16R16F",
    i[i.R32F = 114] = "R32F",
    i[i.G32R32F = 115] = "G32R32F",
    i[i.A32B32G32R32F = 116] = "A32B32G32R32F",
    i[i.UYVY = rt("UYVY")] = "UYVY",
    i[i.R8G8_B8G8 = rt("RGBG")] = "R8G8_B8G8",
    i[i.YUY2 = rt("YUY2")] = "YUY2",
    i[i.D3DFMT_G8R8_G8B8 = rt("GRGB")] = "D3DFMT_G8R8_G8B8",
    i[i.DXT1 = rt("DXT1")] = "DXT1",
    i[i.DXT2 = rt("DXT2")] = "DXT2",
    i[i.DXT3 = rt("DXT3")] = "DXT3",
    i[i.DXT4 = rt("DXT4")] = "DXT4",
    i[i.DXT5 = rt("DXT5")] = "DXT5",
    i[i.ATI1 = rt("ATI1")] = "ATI1",
    i[i.AT1N = rt("AT1N")] = "AT1N",
    i[i.ATI2 = rt("ATI2")] = "ATI2",
    i[i.AT2N = rt("AT2N")] = "AT2N",
    i[i.BC4U = rt("BC4U")] = "BC4U",
    i[i.BC4S = rt("BC4S")] = "BC4S",
    i[i.BC5U = rt("BC5U")] = "BC5U",
    i[i.BC5S = rt("BC5S")] = "BC5S",
    i[i.DX10 = rt("DX10")] = "DX10",
    i))(Mt || {})
      , ap = {
        [Mt.DXT1]: "bc1-rgba-unorm",
        [Mt.DXT2]: "bc2-rgba-unorm",
        [Mt.DXT3]: "bc2-rgba-unorm",
        [Mt.DXT4]: "bc3-rgba-unorm",
        [Mt.DXT5]: "bc3-rgba-unorm",
        [Mt.ATI1]: "bc4-r-unorm",
        [Mt.BC4U]: "bc4-r-unorm",
        [Mt.BC4S]: "bc4-r-snorm",
        [Mt.ATI2]: "bc5-rg-unorm",
        [Mt.BC5U]: "bc5-rg-unorm",
        [Mt.BC5S]: "bc5-rg-snorm",
        36: "rgba16uint",
        110: "rgba16sint",
        111: "r16float",
        112: "rg16float",
        113: "rgba16float",
        114: "r32float",
        115: "rg32float",
        116: "rgba32float"
    }
      , Ct = {
        70: "bc1-rgba-unorm",
        71: "bc1-rgba-unorm",
        72: "bc1-rgba-unorm-srgb",
        73: "bc2-rgba-unorm",
        74: "bc2-rgba-unorm",
        75: "bc2-rgba-unorm-srgb",
        76: "bc3-rgba-unorm",
        77: "bc3-rgba-unorm",
        78: "bc3-rgba-unorm-srgb",
        79: "bc4-r-unorm",
        80: "bc4-r-unorm",
        81: "bc4-r-snorm",
        82: "bc5-rg-unorm",
        83: "bc5-rg-unorm",
        84: "bc5-rg-snorm",
        94: "bc6h-rgb-ufloat",
        95: "bc6h-rgb-ufloat",
        96: "bc6h-rgb-float",
        97: "bc7-rgba-unorm",
        98: "bc7-rgba-unorm",
        99: "bc7-rgba-unorm-srgb",
        28: "rgba8unorm",
        29: "rgba8unorm-srgb",
        87: "bgra8unorm",
        91: "bgra8unorm-srgb",
        41: "r32float",
        49: "rg8unorm",
        56: "r16uint",
        61: "r8unorm",
        24: "rgb10a2unorm",
        11: "rgba16uint",
        13: "rgba16sint",
        10: "rgba16float",
        54: "r16float",
        34: "rg16float",
        16: "rg32float",
        2: "rgba32float"
    }
      , ge = {
        MAGIC_VALUE: 542327876,
        MAGIC_SIZE: 4,
        HEADER_SIZE: 124,
        HEADER_DX10_SIZE: 20,
        PIXEL_FORMAT_FLAGS: {
            ALPHAPIXELS: 1,
            ALPHA: 2,
            FOURCC: 4,
            RGB: 64,
            RGBA: 65,
            YUV: 512,
            LUMINANCE: 131072,
            LUMINANCEA: 131073
        },
        RESOURCE_MISC_TEXTURECUBE: 4,
        HEADER_FIELDS: V4,
        HEADER_DX10_FIELDS: W4,
        DXGI_FORMAT: gm,
        D3D10_RESOURCE_DIMENSION: _m,
        D3DFMT: Mt
    }
      , Y4 = {
        "bc1-rgba-unorm": 8,
        "bc1-rgba-unorm-srgb": 8,
        "bc2-rgba-unorm": 16,
        "bc2-rgba-unorm-srgb": 16,
        "bc3-rgba-unorm": 16,
        "bc3-rgba-unorm-srgb": 16,
        "bc4-r-unorm": 8,
        "bc4-r-snorm": 8,
        "bc5-rg-unorm": 16,
        "bc5-rg-snorm": 16,
        "bc6h-rgb-ufloat": 16,
        "bc6h-rgb-float": 16,
        "bc7-rgba-unorm": 16,
        "bc7-rgba-unorm-srgb": 16
    };
    function $4(i, e) {
        let {format: t, fourCC: r, width: s, height: n, dataOffset: a, mipmapCount: c} = q4(i);
        if (!e.includes(t))
            throw new Error(`Unsupported texture format: ${r} ${t}, supported: ${e}`);
        if (c <= 1)
            return {
                format: t,
                width: s,
                height: n,
                resource: [new Uint8Array(i,a)],
                alphaMode: "no-premultiply-alpha"
            };
        let l = K4(t, s, n, a, c, i);
        return {
            format: t,
            width: s,
            height: n,
            resource: l,
            alphaMode: "no-premultiply-alpha"
        }
    }
    function K4(i, e, t, r, s, n) {
        let a = []
          , c = Y4[i]
          , l = e
          , u = t
          , d = r;
        for (let f = 0; f < s; ++f) {
            let b = Math.ceil(Math.max(4, l) / 4) * 4
              , m = Math.ceil(Math.max(4, u) / 4) * 4
              , x = c ? b / 4 * m / 4 * c : l * u * 4
              , y = new Uint8Array(n,d,x);
            a.push(y),
            d += x,
            l = Math.max(l >> 1, 1),
            u = Math.max(u >> 1, 1)
        }
        return a
    }
    function q4(i) {
        let e = new Uint32Array(i,0,ge.HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
        if (e[ge.HEADER_FIELDS.MAGIC] !== ge.MAGIC_VALUE)
            throw new Error("Invalid magic number in DDS header");
        let t = e[ge.HEADER_FIELDS.HEIGHT]
          , r = e[ge.HEADER_FIELDS.WIDTH]
          , s = Math.max(1, e[ge.HEADER_FIELDS.MIPMAP_COUNT])
          , n = e[ge.HEADER_FIELDS.PF_FLAGS]
          , a = e[ge.HEADER_FIELDS.FOURCC]
          , c = Z4(e, n, a, i)
          , l = ge.MAGIC_SIZE + ge.HEADER_SIZE + (a === ge.D3DFMT.DX10 ? ge.HEADER_DX10_SIZE : 0);
        return {
            format: c,
            fourCC: a,
            width: r,
            height: t,
            dataOffset: l,
            mipmapCount: s
        }
    }
    function Z4(i, e, t, r) {
        if (e & ge.PIXEL_FORMAT_FLAGS.FOURCC) {
            if (t === ge.D3DFMT.DX10) {
                let s = new Uint32Array(r,ge.MAGIC_SIZE + ge.HEADER_SIZE,ge.HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
                if (s[ge.HEADER_DX10_FIELDS.MISC_FLAG] === ge.RESOURCE_MISC_TEXTURECUBE)
                    throw new Error("DDSParser does not support cubemap textures");
                if (s[ge.HEADER_DX10_FIELDS.RESOURCE_DIMENSION] === ge.D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D)
                    throw new Error("DDSParser does not supported 3D texture data");
                let n = s[ge.HEADER_DX10_FIELDS.DXGI_FORMAT];
                if (n in Ct)
                    return Ct[n];
                throw new Error(`DDSParser cannot parse texture data with DXGI format ${n}`)
            }
            if (t in ap)
                return ap[t];
            throw new Error(`DDSParser cannot parse texture data with fourCC format ${t}`)
        }
        if (e & ge.PIXEL_FORMAT_FLAGS.RGB || e & ge.PIXEL_FORMAT_FLAGS.RGBA)
            return Q4(i);
        throw e & ge.PIXEL_FORMAT_FLAGS.YUV ? new Error("DDSParser does not supported YUV uncompressed texture data.") : e & ge.PIXEL_FORMAT_FLAGS.LUMINANCE || e & ge.PIXEL_FORMAT_FLAGS.LUMINANCEA ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : e & ge.PIXEL_FORMAT_FLAGS.ALPHA || e & ge.PIXEL_FORMAT_FLAGS.ALPHAPIXELS ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!")
    }
    function Q4(i) {
        let e = i[ge.HEADER_FIELDS.RGB_BITCOUNT]
          , t = i[ge.HEADER_FIELDS.R_BIT_MASK]
          , r = i[ge.HEADER_FIELDS.G_BIT_MASK]
          , s = i[ge.HEADER_FIELDS.B_BIT_MASK]
          , n = i[ge.HEADER_FIELDS.A_BIT_MASK];
        switch (e) {
        case 32:
            if (t === 255 && r === 65280 && s === 16711680 && n === 4278190080)
                return Ct[ge.DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UNORM];
            if (t === 16711680 && r === 65280 && s === 255 && n === 4278190080)
                return Ct[ge.DXGI_FORMAT.DXGI_FORMAT_B8G8R8A8_UNORM];
            if (t === 1072693248 && r === 1047552 && s === 1023 && n === 3221225472)
                return Ct[ge.DXGI_FORMAT.DXGI_FORMAT_R10G10B10A2_UNORM];
            if (t === 65535 && r === 4294901760 && s === 0 && n === 0)
                return Ct[ge.DXGI_FORMAT.DXGI_FORMAT_R16G16_UNORM];
            if (t === 4294967295 && r === 0 && s === 0 && n === 0)
                return Ct[ge.DXGI_FORMAT.DXGI_FORMAT_R32_FLOAT];
            break;
        case 24:
            break;
        case 16:
            if (t === 31744 && r === 992 && s === 31 && n === 32768)
                return Ct[ge.DXGI_FORMAT.DXGI_FORMAT_B5G5R5A1_UNORM];
            if (t === 63488 && r === 2016 && s === 31 && n === 0)
                return Ct[ge.DXGI_FORMAT.DXGI_FORMAT_B5G6R5_UNORM];
            if (t === 3840 && r === 240 && s === 15 && n === 61440)
                return Ct[ge.DXGI_FORMAT.DXGI_FORMAT_B4G4R4A4_UNORM];
            if (t === 255 && r === 0 && s === 0 && n === 65280)
                return Ct[ge.DXGI_FORMAT.DXGI_FORMAT_R8G8_UNORM];
            if (t === 65535 && r === 0 && s === 0 && n === 0)
                return Ct[ge.DXGI_FORMAT.DXGI_FORMAT_R16_UNORM];
            break;
        case 8:
            if (t === 255 && r === 0 && s === 0 && n === 0)
                return Ct[ge.DXGI_FORMAT.DXGI_FORMAT_R8_UNORM];
            break
        }
        throw new Error(`DDSParser does not support uncompressed texture with configuration:
                bitCount = ${e}, rBitMask = ${t}, gBitMask = ${r}, aBitMask = ${n}`)
    }
    var ww = {
        extension: {
            type: B.LoadParser,
            priority: jt.High,
            name: "loadDDS"
        },
        name: "loadDDS",
        id: "dds",
        test(i) {
            return ei(i, [".dds"])
        },
        async load(i, e, t) {
            let r = await xo()
              , s = await (await fetch(i)).arrayBuffer()
              , n = $4(s, r)
              , a = new Mr(n);
            return ir(a, t, i)
        },
        unload(i) {
            Array.isArray(i) ? i.forEach(e => e.destroy(!0)) : i.destroy(!0)
        }
    }
      , J4 = (i => (i[i.RGBA8_SNORM = 36759] = "RGBA8_SNORM",
    i[i.RGBA = 6408] = "RGBA",
    i[i.RGBA8UI = 36220] = "RGBA8UI",
    i[i.SRGB8_ALPHA8 = 35907] = "SRGB8_ALPHA8",
    i[i.RGBA8I = 36238] = "RGBA8I",
    i[i.RGBA8 = 32856] = "RGBA8",
    i[i.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT",
    i[i.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT",
    i[i.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT",
    i[i.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT",
    i[i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT",
    i[i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT",
    i[i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT",
    i[i.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT",
    i[i.COMPRESSED_RED_RGTC1_EXT = 36283] = "COMPRESSED_RED_RGTC1_EXT",
    i[i.COMPRESSED_SIGNED_RED_RGTC1_EXT = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT",
    i[i.COMPRESSED_RED_GREEN_RGTC2_EXT = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT",
    i[i.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT",
    i[i.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC",
    i[i.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC",
    i[i.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC",
    i[i.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC",
    i[i.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2",
    i[i.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC",
    i[i.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2",
    i[i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC",
    i[i.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2",
    i[i.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2",
    i[i.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR",
    i[i.COMPRESSED_RGBA_ASTC_5x4_KHR = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR",
    i[i.COMPRESSED_RGBA_ASTC_5x5_KHR = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR",
    i[i.COMPRESSED_RGBA_ASTC_6x5_KHR = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR",
    i[i.COMPRESSED_RGBA_ASTC_6x6_KHR = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR",
    i[i.COMPRESSED_RGBA_ASTC_8x5_KHR = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR",
    i[i.COMPRESSED_RGBA_ASTC_8x6_KHR = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR",
    i[i.COMPRESSED_RGBA_ASTC_8x8_KHR = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR",
    i[i.COMPRESSED_RGBA_ASTC_10x5_KHR = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR",
    i[i.COMPRESSED_RGBA_ASTC_10x6_KHR = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR",
    i[i.COMPRESSED_RGBA_ASTC_10x8_KHR = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR",
    i[i.COMPRESSED_RGBA_ASTC_10x10_KHR = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR",
    i[i.COMPRESSED_RGBA_ASTC_12x10_KHR = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR",
    i[i.COMPRESSED_RGBA_ASTC_12x12_KHR = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR",
    i[i.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT",
    i[i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT",
    i[i.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT",
    i[i.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT",
    i))(J4 || {})
      , e5 = (i => (i[i.RGBA = 6408] = "RGBA",
    i[i.RGB = 6407] = "RGB",
    i[i.RG = 33319] = "RG",
    i[i.RED = 6403] = "RED",
    i[i.RGBA_INTEGER = 36249] = "RGBA_INTEGER",
    i[i.RGB_INTEGER = 36248] = "RGB_INTEGER",
    i[i.RG_INTEGER = 33320] = "RG_INTEGER",
    i[i.RED_INTEGER = 36244] = "RED_INTEGER",
    i[i.ALPHA = 6406] = "ALPHA",
    i[i.LUMINANCE = 6409] = "LUMINANCE",
    i[i.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA",
    i[i.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT",
    i[i.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL",
    i))(e5 || {})
      , t5 = (i => (i[i.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE",
    i[i.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT",
    i[i.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5",
    i[i.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4",
    i[i.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1",
    i[i.UNSIGNED_INT = 5125] = "UNSIGNED_INT",
    i[i.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV",
    i[i.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV",
    i[i.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8",
    i[i.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV",
    i[i.BYTE = 5120] = "BYTE",
    i[i.SHORT = 5122] = "SHORT",
    i[i.INT = 5124] = "INT",
    i[i.FLOAT = 5126] = "FLOAT",
    i[i.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV",
    i[i.HALF_FLOAT = 36193] = "HALF_FLOAT",
    i))(t5 || {})
      , i5 = {
        33776: "bc1-rgba-unorm",
        33777: "bc1-rgba-unorm",
        33778: "bc2-rgba-unorm",
        33779: "bc3-rgba-unorm",
        35916: "bc1-rgba-unorm-srgb",
        35917: "bc1-rgba-unorm-srgb",
        35918: "bc2-rgba-unorm-srgb",
        35919: "bc3-rgba-unorm-srgb",
        36283: "bc4-r-unorm",
        36284: "bc4-r-snorm",
        36285: "bc5-rg-unorm",
        36286: "bc5-rg-snorm",
        37488: "eac-r11unorm",
        37490: "eac-rg11snorm",
        37492: "etc2-rgb8unorm",
        37496: "etc2-rgba8unorm",
        37493: "etc2-rgb8unorm-srgb",
        37497: "etc2-rgba8unorm-srgb",
        37494: "etc2-rgb8a1unorm",
        37495: "etc2-rgb8a1unorm-srgb",
        37808: "astc-4x4-unorm",
        37840: "astc-4x4-unorm-srgb",
        37809: "astc-5x4-unorm",
        37841: "astc-5x4-unorm-srgb",
        37810: "astc-5x5-unorm",
        37842: "astc-5x5-unorm-srgb",
        37811: "astc-6x5-unorm",
        37843: "astc-6x5-unorm-srgb",
        37812: "astc-6x6-unorm",
        37844: "astc-6x6-unorm-srgb",
        37813: "astc-8x5-unorm",
        37845: "astc-8x5-unorm-srgb",
        37814: "astc-8x6-unorm",
        37846: "astc-8x6-unorm-srgb",
        37815: "astc-8x8-unorm",
        37847: "astc-8x8-unorm-srgb",
        37816: "astc-10x5-unorm",
        37848: "astc-10x5-unorm-srgb",
        37817: "astc-10x6-unorm",
        37849: "astc-10x6-unorm-srgb",
        37818: "astc-10x8-unorm",
        37850: "astc-10x8-unorm-srgb",
        37819: "astc-10x10-unorm",
        37851: "astc-10x10-unorm-srgb",
        37820: "astc-12x10-unorm",
        37852: "astc-12x10-unorm-srgb",
        37821: "astc-12x12-unorm",
        37853: "astc-12x12-unorm-srgb",
        36492: "bc7-rgba-unorm",
        36493: "bc7-rgba-unorm-srgb",
        36494: "bc6h-rgb-float",
        36495: "bc6h-rgb-ufloat",
        35907: "rgba8unorm-srgb",
        36759: "rgba8snorm",
        36220: "rgba8uint",
        36238: "rgba8sint",
        6408: "rgba8unorm"
    }
      , r5 = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]
      , s5 = {
        FILE_IDENTIFIER: 0,
        ENDIANNESS: 12,
        GL_TYPE: 16,
        GL_TYPE_SIZE: 20,
        GL_FORMAT: 24,
        GL_INTERNAL_FORMAT: 28,
        GL_BASE_INTERNAL_FORMAT: 32,
        PIXEL_WIDTH: 36,
        PIXEL_HEIGHT: 40,
        PIXEL_DEPTH: 44,
        NUMBER_OF_ARRAY_ELEMENTS: 48,
        NUMBER_OF_FACES: 52,
        NUMBER_OF_MIPMAP_LEVELS: 56,
        BYTES_OF_KEY_VALUE_DATA: 60
    }
      , n5 = 64
      , a5 = 67305985
      , o5 = {
        5121: 1,
        5123: 2,
        5124: 4,
        5125: 4,
        5126: 4,
        36193: 8
    }
      , c5 = {
        6408: 4,
        6407: 3,
        33319: 2,
        6403: 1,
        6409: 1,
        6410: 2,
        6406: 1
    }
      , l5 = {
        32819: 2,
        32820: 2,
        33635: 2
    }
      , h5 = {
        33776: .5,
        33777: .5,
        33778: 1,
        33779: 1,
        35916: .5,
        35917: .5,
        35918: 1,
        35919: 1,
        36283: .5,
        36284: .5,
        36285: 1,
        36286: 1,
        37488: .5,
        37489: .5,
        37490: 1,
        37491: 1,
        37492: .5,
        37496: 1,
        37493: .5,
        37497: 1,
        37494: .5,
        37495: .5,
        37808: 1,
        37840: 1,
        37809: .8,
        37841: .8,
        37810: .64,
        37842: .64,
        37811: .53375,
        37843: .53375,
        37812: .445,
        37844: .445,
        37813: .4,
        37845: .4,
        37814: .33375,
        37846: .33375,
        37815: .25,
        37847: .25,
        37816: .32,
        37848: .32,
        37817: .26625,
        37849: .26625,
        37818: .2,
        37850: .2,
        37819: .16,
        37851: .16,
        37820: .13375,
        37852: .13375,
        37821: .11125,
        37853: .11125,
        36492: 1,
        36493: 1,
        36494: 1,
        36495: 1
    }
      , Ze = {
        FILE_HEADER_SIZE: n5,
        FILE_IDENTIFIER: r5,
        FORMATS_TO_COMPONENTS: c5,
        INTERNAL_FORMAT_TO_BYTES_PER_PIXEL: h5,
        INTERNAL_FORMAT_TO_TEXTURE_FORMATS: i5,
        FIELDS: s5,
        TYPES_TO_BYTES_PER_COMPONENT: o5,
        TYPES_TO_BYTES_PER_PIXEL: l5,
        ENDIANNESS: a5
    };
    function u5(i, e) {
        let t = new DataView(i);
        if (!b5(t))
            throw new Error("Invalid KTX identifier in header");
        let {littleEndian: r, glType: s, glFormat: n, glInternalFormat: a, pixelWidth: c, pixelHeight: l, numberOfMipmapLevels: u, offset: d} = p5(t)
          , f = Ze.INTERNAL_FORMAT_TO_TEXTURE_FORMATS[a];
        if (!f)
            throw new Error(`Unknown texture format ${a}`);
        if (!e.includes(f))
            throw new Error(`Unsupported texture format: ${f}, supportedFormats: ${e}`);
        let b = f5(s, n, a)
          , m = d5(t, s, b, c, l, d, u, r);
        return {
            format: f,
            width: c,
            height: l,
            resource: m,
            alphaMode: "no-premultiply-alpha"
        }
    }
    function d5(i, e, t, r, s, n, a, c) {
        let l = r + 3 & -4
          , u = s + 3 & -4
          , d = r * s;
        e === 0 && (d = l * u);
        let f = d * t
          , b = r
          , m = s
          , x = l
          , y = u
          , S = n
          , A = new Array(a);
        for (let E = 0; E < a; E++) {
            let O = i.getUint32(S, c)
              , M = S + 4;
            A[E] = new Uint8Array(i.buffer,M,f),
            M += f,
            S += O + 4,
            S = S % 4 !== 0 ? S + 4 - S % 4 : S,
            b = b >> 1 || 1,
            m = m >> 1 || 1,
            x = b + 4 - 1 & -4,
            y = m + 4 - 1 & -4,
            f = x * y * t
        }
        return A
    }
    function f5(i, e, t) {
        let r = Ze.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[t];
        if (i !== 0 && (Ze.TYPES_TO_BYTES_PER_COMPONENT[i] ? r = Ze.TYPES_TO_BYTES_PER_COMPONENT[i] * Ze.FORMATS_TO_COMPONENTS[e] : r = Ze.TYPES_TO_BYTES_PER_PIXEL[i]),
        r === void 0)
            throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
        return r
    }
    function p5(i) {
        let e = i.getUint32(Ze.FIELDS.ENDIANNESS, !0) === Ze.ENDIANNESS
          , t = i.getUint32(Ze.FIELDS.GL_TYPE, e)
          , r = i.getUint32(Ze.FIELDS.GL_FORMAT, e)
          , s = i.getUint32(Ze.FIELDS.GL_INTERNAL_FORMAT, e)
          , n = i.getUint32(Ze.FIELDS.PIXEL_WIDTH, e)
          , a = i.getUint32(Ze.FIELDS.PIXEL_HEIGHT, e) || 1
          , c = i.getUint32(Ze.FIELDS.PIXEL_DEPTH, e) || 1
          , l = i.getUint32(Ze.FIELDS.NUMBER_OF_ARRAY_ELEMENTS, e) || 1
          , u = i.getUint32(Ze.FIELDS.NUMBER_OF_FACES, e)
          , d = i.getUint32(Ze.FIELDS.NUMBER_OF_MIPMAP_LEVELS, e)
          , f = i.getUint32(Ze.FIELDS.BYTES_OF_KEY_VALUE_DATA, e);
        if (a === 0 || c !== 1)
            throw new Error("Only 2D textures are supported");
        if (u !== 1)
            throw new Error("CubeTextures are not supported by KTXLoader yet!");
        if (l !== 1)
            throw new Error("WebGL does not support array textures");
        return {
            littleEndian: e,
            glType: t,
            glFormat: r,
            glInternalFormat: s,
            pixelWidth: n,
            pixelHeight: a,
            numberOfMipmapLevels: d,
            offset: Ze.FILE_HEADER_SIZE + f
        }
    }
    function b5(i) {
        for (let e = 0; e < Ze.FILE_IDENTIFIER.length; e++)
            if (i.getUint8(e) !== Ze.FILE_IDENTIFIER[e])
                return !1;
        return !0
    }
    var Aw = {
        extension: {
            type: B.LoadParser,
            priority: jt.High,
            name: "loadKTX"
        },
        name: "loadKTX",
        id: "ktx",
        test(i) {
            return ei(i, ".ktx")
        },
        async load(i, e, t) {
            let r = await xo()
              , s = await (await fetch(i)).arrayBuffer()
              , n = u5(s, r)
              , a = new Mr(n);
            return ir(a, t, i)
        },
        unload(i) {
            Array.isArray(i) ? i.forEach(e => e.destroy(!0)) : i.destroy(!0)
        }
    }
      , m5 = '(function(){"use strict";const s={rgb8unorm:{convertedFormat:"rgba8unorm",convertFunction:i},"rgb8unorm-srgb":{convertedFormat:"rgba8unorm-srgb",convertFunction:i}};function f(r){const t=r.format;if(s[t]){const n=s[t].convertFunction,o=r.resource;for(let e=0;e<o.length;e++)o[e]=n(o[e]);r.format=s[t].convertedFormat}}function i(r){const t=r.byteLength/3,n=new Uint32Array(t);for(let o=0;o<t;++o)n[o]=r[o*3]+(r[o*3+1]<<8)+(r[o*3+2]<<16)+4278190080;return new Uint8Array(n.buffer)}function d(r){const t=[];for(let n=0;n<r.numLevels;n++){const o=r.getImageData(n,0,0),e=new Uint8Array(o.byteLength);e.set(o),t.push(e)}return t}const w={6408:"rgba8unorm",32856:"bgra8unorm",32857:"rgb10a2unorm",33189:"depth16unorm",33190:"depth24plus",33321:"r8unorm",33323:"rg8unorm",33325:"r16float",33326:"r32float",33327:"rg16float",33328:"rg32float",33329:"r8sint",33330:"r8uint",33331:"r16sint",33332:"r16uint",33333:"r32sint",33334:"r32uint",33335:"rg8sint",33336:"rg8uint",33337:"rg16sint",33338:"rg16uint",33339:"rg32sint",33340:"rg32uint",33778:"bc2-rgba-unorm",33779:"bc3-rgba-unorm",34836:"rgba32float",34842:"rgba16float",35056:"depth24plus-stencil8",35898:"rg11b10ufloat",35901:"rgb9e5ufloat",35907:"rgba8unorm-srgb",36012:"depth32float",36013:"depth32float-stencil8",36168:"stencil8",36208:"rgba32uint",36214:"rgba16uint",36220:"rgba8uint",36226:"rgba32sint",36232:"rgba16sint",36238:"rgba8sint",36492:"bc7-rgba-unorm",36756:"r8snorm",36757:"rg8snorm",36759:"rgba8snorm",37496:"etc2-rgba8unorm",37808:"astc-4x4-unorm"};function p(r){const t=w[r];if(t)return t;throw new Error(`Unsupported glInternalFormat: ${r}`)}const h={23:"rgb8unorm",37:"rgba8unorm",43:"rgba8unorm-srgb"};function F(r){const t=h[r];if(t)return t;throw new Error(`Unsupported VkFormat: ${r}`)}function U(r){return r.classId===2?F(r.vkFormat):p(r.glInternalformat)}const T={"bc3-rgba-unorm":"BC3_RGBA","bc7-rgba-unorm":"BC7_M5_RGBA","etc2-rgba8unorm":"ETC2_RGBA","astc-4x4-unorm":"ASTC_4x4_RGBA",rgba8unorm:"RGBA32",rg11b10ufloat:"R11F_G11F_B10F"};function y(r){const t=T[r];if(t)return t;throw new Error(`Unsupported transcoderFormat: ${r}`)}const a={jsUrl:"",wasmUrl:""};let l,u,c;async function g(){if(!c){const r=new URL(a.jsUrl,location.origin).href,t=new URL(a.wasmUrl,location.origin).href;importScripts(r),c=new Promise(n=>{LIBKTX({locateFile:o=>t}).then(o=>{n(o)})})}return c}async function v(r,t){const n=await fetch(r);if(n.ok){const o=await n.arrayBuffer();return new t.ktxTexture(new Uint8Array(o))}throw new Error(`Failed to load KTX(2) texture: ${r}`)}const x=["bc7-rgba-unorm","astc-4x4-unorm","etc2-rgba8unorm","bc3-rgba-unorm","rgba8unorm"];async function B(r){const t=await g(),n=await v(r,t);let o;if(n.needsTranscoding){o=u;const R=t.TranscodeTarget[l];if(n.transcodeBasis(R,0)!==t.ErrorCode.SUCCESS)throw new Error("Unable to transcode basis texture.")}else o=U(n);const e=d(n),b={width:n.baseWidth,height:n.baseHeight,format:o,mipLevelCount:n.numLevels,resource:e,alphaMode:"no-premultiply-alpha"};return f(b),b}async function A(r,t,n){r&&(a.jsUrl=r),t&&(a.wasmUrl=t),u=x.filter(o=>n.includes(o))[0],l=y(u),await g()}const m={init:async r=>{const{jsUrl:t,wasmUrl:n,supportedTextures:o}=r;await A(t,n,o)},load:async r=>{var t;try{const n=await B(r.url);return{type:"load",url:r.url,success:!0,textureOptions:n,transferables:(t=n.resource)==null?void 0:t.map(o=>o.buffer)}}catch(n){throw n}}};self.onmessage=async r=>{var t;const n=r.data,o=await((t=m[n.type])==null?void 0:t.call(m,n));o&&self.postMessage(o,o.transferables)}})();\n'
      , vr = null
      , aa = class {
        constructor() {
            vr || (vr = URL.createObjectURL(new Blob([m5],{
                type: "application/javascript"
            }))),
            this.worker = new Worker(vr)
        }
    }
    ;
    aa.revokeObjectURL = function() {
        vr && (URL.revokeObjectURL(vr),
        vr = null)
    }
    ;
    var op = {
        jsUrl: "https://files.pixijs.download/transcoders/ktx/libktx.js",
        wasmUrl: "https://files.pixijs.download/transcoders/ktx/libktx.wasm"
    };
    var Vr, xm = {};
    function g5(i) {
        return Vr || (Vr = new aa().worker,
        Vr.onmessage = e => {
            let {success: t, url: r, textureOptions: s} = e.data;
            xm[r](s)
        }
        ,
        Vr.postMessage({
            type: "init",
            jsUrl: op.jsUrl,
            wasmUrl: op.wasmUrl,
            supportedTextures: i
        })),
        Vr
    }
    function _5(i, e) {
        let t = g5(e);
        return new Promise(r => {
            xm[i] = r,
            t.postMessage({
                type: "load",
                url: i
            })
        }
        )
    }
    var Ew = {
        extension: {
            type: B.LoadParser,
            priority: jt.High,
            name: "loadKTX2"
        },
        name: "loadKTX2",
        id: "ktx2",
        test(i) {
            return ei(i, ".ktx2")
        },
        async load(i, e, t) {
            let r = await xo()
              , s = await _5(i, r)
              , n = new Mr(s);
            return ir(n, t, i)
        },
        async unload(i) {
            Array.isArray(i) ? i.forEach(e => e.destroy(!0)) : i.destroy(!0)
        }
    };
    var Fl = ["basis", "bc7", "bc6h", "astc", "etc2", "bc5", "bc4", "bc3", "bc2", "bc1", "eac"], Pw = {
        extension: B.ResolveParser,
        test: i => ei(i, [".ktx", ".ktx2", ".dds"]),
        parse: i => {
            var e, t;
            let r, s = i.split(".");
            if (s.length > 2) {
                let n = s[s.length - 2];
                Fl.includes(n) && (r = n)
            } else
                r = s[s.length - 1];
            return {
                resolution: parseFloat((t = (e = xi.RETINA_PREFIX.exec(i)) == null ? void 0 : e[1]) != null ? t : "1"),
                format: r,
                src: i
            }
        }
    }, en, Rw = {
        extension: {
            type: B.DetectionParser,
            priority: 2
        },
        test: async () => !!(await mo() || bo()),
        add: async i => {
            let e = await pm();
            return en = x5(e),
            [...en, ...i]
        }
        ,
        remove: async i => en ? i.filter(e => !(e in en)) : i
    };
    function x5(i) {
        let e = ["basis"]
          , t = {};
        return i.forEach(r => {
            let s = r.split("-")[0];
            s && !t[s] && (t[s] = !0,
            e.push(s))
        }
        ),
        e.sort( (r, s) => {
            let n = Fl.indexOf(r)
              , a = Fl.indexOf(s);
            return n === -1 ? 1 : a === -1 ? -1 : n - a
        }
        ),
        e
    }
    var y5 = new at
      , Dl = class {
        cull(i, e, t=!0) {
            this._cullRecursive(i, e, t)
        }
        _cullRecursive(i, e, t=!0) {
            var r;
            if (i.cullable && i.measurable && i.includeInBuild) {
                let s = (r = i.cullArea) != null ? r : uo(i, t, y5);
                i.culled = s.x >= e.x + e.width || s.y >= e.y + e.height || s.x + s.width <= e.x || s.y + s.height <= e.y
            } else
                i.culled = !1;
            if (!(!i.cullableChildren || i.culled || !i.renderable || !i.measurable || !i.includeInBuild))
                for (let s = 0; s < i.children.length; s++)
                    this._cullRecursive(i.children[s], e, t)
        }
    }
    ;
    Dl.shared = new Dl;
    var v5 = Dl
      , kl = class {
        static init(e) {
            this._renderRef = this.render.bind(this),
            this.render = () => {
                var t;
                let r = ((t = e?.culler) == null ? void 0 : t.updateTransform) !== !0;
                v5.shared.cull(this.stage, this.renderer.screen, r),
                this.renderer.render({
                    container: this.stage
                })
            }
        }
        static destroy() {
            this.render = this._renderRef
        }
    }
    ;
    kl.extension = {
        priority: 10,
        type: B.Application,
        name: "culler"
    };
    var Mw = {
        extension: {
            type: B.Environment,
            name: "browser",
            priority: -1
        },
        test: () => !0,
        load: async () => {
            await Promise.resolve().then(function() {
                return xv
            })
        }
    }
      , T5 = Object.defineProperty
      , oa = Object.getOwnPropertySymbols
      , ym = Object.prototype.hasOwnProperty
      , vm = Object.prototype.propertyIsEnumerable
      , cp = (i, e, t) => e in i ? T5(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , mc = (i, e) => {
        for (var t in e || (e = {}))
            ym.call(e, t) && cp(i, t, e[t]);
        if (oa)
            for (var t of oa(e))
                vm.call(e, t) && cp(i, t, e[t]);
        return i
    }
      , S5 = (i, e) => {
        var t = {};
        for (var r in i)
            ym.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && oa)
            for (var r of oa(i))
                e.indexOf(r) < 0 && vm.call(i, r) && (t[r] = i[r]);
        return t
    }
      , Tm = class Ul extends At {
        constructor(e) {
            e = mc(mc({}, Ul.defaultOptions), e),
            super(e),
            this.enabled = !0,
            this._state = Nt.for2d(),
            this.blendMode = e.blendMode,
            this.padding = e.padding,
            typeof e.antialias == "boolean" ? this.antialias = e.antialias ? "on" : "off" : this.antialias = e.antialias,
            this.resolution = e.resolution,
            this.blendRequired = e.blendRequired,
            this.clipToViewport = e.clipToViewport,
            this.addResource("uTexture", 0, 1)
        }
        apply(e, t, r, s) {
            e.applyFilter(this, t, r, s)
        }
        get blendMode() {
            return this._state.blendMode
        }
        set blendMode(e) {
            this._state.blendMode = e
        }
        static from(e) {
            let t = e, {gpu: r, gl: s} = t, n = S5(t, ["gpu", "gl"]), a, c;
            return r && (a = ci.from(r)),
            s && (c = wi.from(s)),
            new Ul(mc({
                gpuProgram: a,
                glProgram: c
            }, n))
        }
    }
    ;
    Tm.defaultOptions = {
        blendMode: "normal",
        resolution: 1,
        padding: 0,
        antialias: "off",
        blendRequired: !1,
        clipToViewport: !0
    };
    var Gs = Tm;
    var Sm = `in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`
      , w5 = `
in vec2 vTextureCoord;

out vec4 finalColor;

uniform float uAlpha;
uniform sampler2D uTexture;

void main()
{
    finalColor =  texture(uTexture, vTextureCoord) * uAlpha;
}
`
      , lp = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct AlphaUniforms {
  uAlpha:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
 
    var sample = textureSample(uTexture, uSampler, uv);
    
    return sample * alphaUniforms.uAlpha;
}`
      , A5 = Object.defineProperty
      , E5 = Object.defineProperties
      , P5 = Object.getOwnPropertyDescriptors
      , ca = Object.getOwnPropertySymbols
      , wm = Object.prototype.hasOwnProperty
      , Am = Object.prototype.propertyIsEnumerable
      , hp = (i, e, t) => e in i ? A5(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , gc = (i, e) => {
        for (var t in e || (e = {}))
            wm.call(e, t) && hp(i, t, e[t]);
        if (ca)
            for (var t of ca(e))
                Am.call(e, t) && hp(i, t, e[t]);
        return i
    }
      , R5 = (i, e) => E5(i, P5(e))
      , M5 = (i, e) => {
        var t = {};
        for (var r in i)
            wm.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && ca)
            for (var r of ca(i))
                e.indexOf(r) < 0 && Am.call(i, r) && (t[r] = i[r]);
        return t
    }
      , C5 = class Em extends Gs {
        constructor(e) {
            e = gc(gc({}, Em.defaultOptions), e);
            let t = ci.from({
                vertex: {
                    source: lp,
                    entryPoint: "mainVertex"
                },
                fragment: {
                    source: lp,
                    entryPoint: "mainFragment"
                }
            })
              , r = wi.from({
                vertex: Sm,
                fragment: w5,
                name: "alpha-filter"
            })
              , s = e
              , {alpha: n} = s
              , a = M5(s, ["alpha"])
              , c = new ct({
                uAlpha: {
                    value: n,
                    type: "f32"
                }
            });
            super(R5(gc({}, a), {
                gpuProgram: t,
                glProgram: r,
                resources: {
                    alphaUniforms: c
                }
            }))
        }
        get alpha() {
            return this.resources.alphaUniforms.uniforms.uAlpha
        }
        set alpha(e) {
            this.resources.alphaUniforms.uniforms.uAlpha = e
        }
    }
    ;
    C5.defaultOptions = {
        alpha: 1
    };
    var Pm = {
        5: [.153388, .221461, .250301],
        7: [.071303, .131514, .189879, .214607],
        9: [.028532, .067234, .124009, .179044, .20236],
        11: [.0093, .028002, .065984, .121703, .175713, .198596],
        13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641],
        15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448]
    }
      , O5 = ["in vec2 vBlurTexCoords[%size%];", "uniform sampler2D uTexture;", "out vec4 finalColor;", "void main(void)", "{", "    finalColor = vec4(0.0);", "    %blur%", "}"].join(`
`);
    function I5(i) {
        let e = Pm[i], t = e.length, r = O5, s = "", n = "finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;", a;
        for (let c = 0; c < i; c++) {
            let l = n.replace("%index%", c.toString());
            a = c,
            c >= t && (a = i - c - 1),
            l = l.replace("%value%", e[a].toString()),
            s += l,
            s += `
`
        }
        return r = r.replace("%blur%", s),
        r = r.replace("%size%", i.toString()),
        r
    }
    var G5 = `
    in vec2 aPosition;

    uniform float uStrength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 uInputSize;
    uniform vec4 uOutputFrame;
    uniform vec4 uOutputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;

    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (uOutputFrame.zw * uInputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = uInputSize.%dimension% * uStrength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
    function B5(i, e) {
        let t = Math.ceil(i / 2), r = G5, s = "", n;
        e ? n = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);" : n = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";
        for (let a = 0; a < i; a++) {
            let c = n.replace("%index%", a.toString());
            c = c.replace("%sampleIndex%", `${a - (t - 1)}.0`),
            s += c,
            s += `
`
        }
        return r = r.replace("%blur%", s),
        r = r.replace("%size%", i.toString()),
        r = r.replace("%dimension%", e ? "z" : "w"),
        r
    }
    function F5(i, e) {
        let t = B5(e, i)
          , r = I5(e);
        return wi.from({
            vertex: t,
            fragment: r,
            name: `blur-${i ? "horizontal" : "vertical"}-pass-filter`
        })
    }
    var D5 = `

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct BlurUniforms {
  uStrength:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    %blur-struct%
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}


@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {

  let filteredCord = filterTextureCoord(aPosition);

  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;

  return VSOutput(
   filterVertexPosition(aPosition),
    %blur-vertex-out%
  );
}

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  %blur-fragment-in%
) -> @location(0) vec4<f32> {

    var   finalColor = vec4(0.0);

    %blur-sampling%

    return finalColor;
}`;
    function k5(i, e) {
        let t = Pm[e]
          , r = t.length
          , s = []
          , n = []
          , a = [];
        for (let f = 0; f < e; f++) {
            s[f] = `@location(${f}) offset${f}: vec2<f32>,`,
            i ? n[f] = `filteredCord + vec2(${f - r + 1} * pixelStrength, 0.0),` : n[f] = `filteredCord + vec2(0.0, ${f - r + 1} * pixelStrength),`;
            let b = f < r ? f : e - f - 1
              , m = t[b].toString();
            a[f] = `finalColor += textureSample(uTexture, uSampler, offset${f}) * ${m};`
        }
        let c = s.join(`
`)
          , l = n.join(`
`)
          , u = a.join(`
`)
          , d = D5.replace("%blur-struct%", c).replace("%blur-vertex-out%", l).replace("%blur-fragment-in%", c).replace("%blur-sampling%", u).replace("%dimension%", i ? "z" : "w");
        return ci.from({
            vertex: {
                source: d,
                entryPoint: "mainVertex"
            },
            fragment: {
                source: d,
                entryPoint: "mainFragment"
            }
        })
    }
    var U5 = Object.defineProperty
      , up = Object.getOwnPropertySymbols
      , L5 = Object.prototype.hasOwnProperty
      , N5 = Object.prototype.propertyIsEnumerable
      , dp = (i, e, t) => e in i ? U5(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , _c = (i, e) => {
        for (var t in e || (e = {}))
            L5.call(e, t) && dp(i, t, e[t]);
        if (up)
            for (var t of up(e))
                N5.call(e, t) && dp(i, t, e[t]);
        return i
    }
      , Rm = class Mm extends Gs {
        constructor(e) {
            e = _c(_c({}, Mm.defaultOptions), e);
            let t = F5(e.horizontal, e.kernelSize)
              , r = k5(e.horizontal, e.kernelSize);
            super(_c({
                glProgram: t,
                gpuProgram: r,
                resources: {
                    blurUniforms: {
                        uStrength: {
                            value: 0,
                            type: "f32"
                        }
                    }
                }
            }, e)),
            this.horizontal = e.horizontal,
            this._quality = 0,
            this.quality = e.quality,
            this.blur = e.strength,
            this._uniforms = this.resources.blurUniforms.uniforms
        }
        apply(e, t, r, s) {
            if (this._uniforms.uStrength = this.strength / this.passes,
            this.passes === 1)
                e.applyFilter(this, t, r, s);
            else {
                let n = Qe.getSameSizeTexture(t)
                  , a = t
                  , c = n;
                this._state.blend = !1;
                let l = e.renderer.type === Bt.WEBGPU;
                for (let u = 0; u < this.passes - 1; u++) {
                    e.applyFilter(this, a, c, u === 0 ? !0 : l);
                    let d = c;
                    c = a,
                    a = d
                }
                this._state.blend = !0,
                e.applyFilter(this, a, r, s),
                Qe.returnTexture(n)
            }
        }
        get blur() {
            return this.strength
        }
        set blur(e) {
            this.padding = 1 + Math.abs(e) * 2,
            this.strength = e
        }
        get quality() {
            return this._quality
        }
        set quality(e) {
            this._quality = e,
            this.passes = e
        }
    }
    ;
    Rm.defaultOptions = {
        strength: 8,
        quality: 4,
        kernelSize: 5
    };
    var xc = Rm
      , X5 = Object.defineProperty
      , j5 = Object.defineProperties
      , H5 = Object.getOwnPropertyDescriptors
      , la = Object.getOwnPropertySymbols
      , Cm = Object.prototype.hasOwnProperty
      , Om = Object.prototype.propertyIsEnumerable
      , fp = (i, e, t) => e in i ? X5(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Wr = (i, e) => {
        for (var t in e || (e = {}))
            Cm.call(e, t) && fp(i, t, e[t]);
        if (la)
            for (var t of la(e))
                Om.call(e, t) && fp(i, t, e[t]);
        return i
    }
      , z5 = (i, e) => j5(i, H5(e))
      , V5 = (i, e) => {
        var t = {};
        for (var r in i)
            Cm.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && la)
            for (var r of la(i))
                e.indexOf(r) < 0 && Om.call(i, r) && (t[r] = i[r]);
        return t
    }
      , Ll = class extends Gs {
        constructor(...e) {
            var t;
            let r = (t = e[0]) != null ? t : {};
            typeof r == "number" && (r = {
                strength: r
            },
            e[1] !== void 0 && (r.quality = e[1]),
            e[2] !== void 0 && (r.resolution = e[2] || "inherit"),
            e[3] !== void 0 && (r.kernelSize = e[3])),
            r = Wr(Wr({}, xc.defaultOptions), r);
            let s = r
              , {strength: n, strengthX: a, strengthY: c, quality: l} = s
              , u = V5(s, ["strength", "strengthX", "strengthY", "quality"]);
            super(z5(Wr({}, u), {
                compatibleRenderers: Bt.BOTH,
                resources: {}
            })),
            this._repeatEdgePixels = !1,
            this.blurXFilter = new xc(Wr({
                horizontal: !0
            }, r)),
            this.blurYFilter = new xc(Wr({
                horizontal: !1
            }, r)),
            this.quality = l,
            this.strengthX = a ?? n,
            this.strengthY = c ?? n,
            this.repeatEdgePixels = !1
        }
        apply(e, t, r, s) {
            let n = Math.abs(this.blurXFilter.strength)
              , a = Math.abs(this.blurYFilter.strength);
            if (n && a) {
                let c = Qe.getSameSizeTexture(t);
                this.blurXFilter.blendMode = "normal",
                this.blurXFilter.apply(e, t, c, !0),
                this.blurYFilter.blendMode = this.blendMode,
                this.blurYFilter.apply(e, c, r, s),
                Qe.returnTexture(c)
            } else
                a ? (this.blurYFilter.blendMode = this.blendMode,
                this.blurYFilter.apply(e, t, r, s)) : (this.blurXFilter.blendMode = this.blendMode,
                this.blurXFilter.apply(e, t, r, s))
        }
        updatePadding() {
            this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.blur), Math.abs(this.blurYFilter.blur)) * 2
        }
        get strength() {
            if (this.strengthX !== this.strengthY)
                throw new Error("BlurFilter's strengthX and strengthY are different");
            return this.strengthX
        }
        set strength(e) {
            this.blurXFilter.blur = this.blurYFilter.blur = e,
            this.updatePadding()
        }
        get quality() {
            return this.blurXFilter.quality
        }
        set quality(e) {
            this.blurXFilter.quality = this.blurYFilter.quality = e
        }
        get strengthX() {
            return this.blurXFilter.blur
        }
        set strengthX(e) {
            this.blurXFilter.blur = e,
            this.updatePadding()
        }
        get strengthY() {
            return this.blurYFilter.blur
        }
        set strengthY(e) {
            this.blurYFilter.blur = e,
            this.updatePadding()
        }
        get blur() {
            return this.strength
        }
        set blur(e) {
            this.strength = e
        }
        get blurX() {
            return this.strengthX
        }
        set blurX(e) {
            this.strengthX = e
        }
        get blurY() {
            return this.strengthY
        }
        set blurY(e) {
            this.strengthY = e
        }
        get repeatEdgePixels() {
            return this._repeatEdgePixels
        }
        set repeatEdgePixels(e) {
            this._repeatEdgePixels = e,
            this.updatePadding()
        }
    }
    ;
    Ll.defaultOptions = {
        strength: 8,
        quality: 4,
        kernelSize: 5
    };
    var W5 = `
in vec2 vTextureCoord;
in vec4 vColor;

out vec4 finalColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uTexture;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture(uTexture, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) *  uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    finalColor = color;
}
`
      , pp = `

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct NoiseUniforms {
  uNoise:f32,
  uSeed:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> noiseUniforms : NoiseUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

fn rand(co:vec2<f32>) -> f32
{
  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}



@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var pixelPosition =  globalTextureCoord(position.xy);// / (getSize());//-  gfu.uOutputFrame.xy);
  
    
    var sample = textureSample(uTexture, uSampler, uv);
    var randomValue =  rand(pixelPosition.xy * noiseUniforms.uSeed);
    var diff = (randomValue - 0.5) * noiseUniforms.uNoise;
  
    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (sample.a > 0.0) {
      sample.r /= sample.a;
      sample.g /= sample.a;
      sample.b /= sample.a;
    }

    sample.r += diff;
    sample.g += diff;
    sample.b += diff;

    // Premultiply alpha again.
    sample.r *= sample.a;
    sample.g *= sample.a;
    sample.b *= sample.a;
    
    return sample;
}`
      , Y5 = Object.defineProperty
      , $5 = Object.defineProperties
      , K5 = Object.getOwnPropertyDescriptors
      , ha = Object.getOwnPropertySymbols
      , Im = Object.prototype.hasOwnProperty
      , Gm = Object.prototype.propertyIsEnumerable
      , bp = (i, e, t) => e in i ? Y5(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , yc = (i, e) => {
        for (var t in e || (e = {}))
            Im.call(e, t) && bp(i, t, e[t]);
        if (ha)
            for (var t of ha(e))
                Gm.call(e, t) && bp(i, t, e[t]);
        return i
    }
      , q5 = (i, e) => $5(i, K5(e))
      , Z5 = (i, e) => {
        var t = {};
        for (var r in i)
            Im.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && ha)
            for (var r of ha(i))
                e.indexOf(r) < 0 && Gm.call(i, r) && (t[r] = i[r]);
        return t
    }
      , Q5 = class Bm extends Gs {
        constructor(e={}) {
            e = yc(yc({}, Bm.defaultOptions), e);
            let t = ci.from({
                vertex: {
                    source: pp,
                    entryPoint: "mainVertex"
                },
                fragment: {
                    source: pp,
                    entryPoint: "mainFragment"
                }
            })
              , r = wi.from({
                vertex: Sm,
                fragment: W5,
                name: "noise-filter"
            })
              , s = e
              , {noise: n, seed: a} = s
              , c = Z5(s, ["noise", "seed"]);
            super(q5(yc({}, c), {
                gpuProgram: t,
                glProgram: r,
                resources: {
                    noiseUniforms: new ct({
                        uNoise: {
                            value: 1,
                            type: "f32"
                        },
                        uSeed: {
                            value: 1,
                            type: "f32"
                        }
                    })
                }
            })),
            this.noise = n,
            this.seed = a ?? Math.random()
        }
        get noise() {
            return this.resources.noiseUniforms.uniforms.uNoise
        }
        set noise(e) {
            this.resources.noiseUniforms.uniforms.uNoise = e
        }
        get seed() {
            return this.resources.noiseUniforms.uniforms.uSeed
        }
        set seed(e) {
            this.resources.noiseUniforms.uniforms.uSeed = e
        }
    }
    ;
    Q5.defaultOptions = {
        noise: .5
    };
    var J5 = `in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`
      , e8 = `in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`
      , mp = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`
      , t8 = Object.defineProperty
      , i8 = Object.defineProperties
      , r8 = Object.getOwnPropertyDescriptors
      , ua = Object.getOwnPropertySymbols
      , Fm = Object.prototype.hasOwnProperty
      , Dm = Object.prototype.propertyIsEnumerable
      , gp = (i, e, t) => e in i ? t8(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , s8 = (i, e) => {
        for (var t in e || (e = {}))
            Fm.call(e, t) && gp(i, t, e[t]);
        if (ua)
            for (var t of ua(e))
                Dm.call(e, t) && gp(i, t, e[t]);
        return i
    }
      , n8 = (i, e) => i8(i, r8(e))
      , a8 = (i, e) => {
        var t = {};
        for (var r in i)
            Fm.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && ua)
            for (var r of ua(i))
                e.indexOf(r) < 0 && Dm.call(i, r) && (t[r] = i[r]);
        return t
    }
      , Nl = class extends Gs {
        constructor(e) {
            let t = e
              , {sprite: r} = t
              , s = a8(t, ["sprite"])
              , n = new mn(r.texture)
              , a = new ct({
                uFilterMatrix: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uMaskClamp: {
                    value: n.uClampFrame,
                    type: "vec4<f32>"
                },
                uAlpha: {
                    value: 1,
                    type: "f32"
                },
                uInverse: {
                    value: e.inverse ? 1 : 0,
                    type: "f32"
                }
            })
              , c = ci.from({
                vertex: {
                    source: mp,
                    entryPoint: "mainVertex"
                },
                fragment: {
                    source: mp,
                    entryPoint: "mainFragment"
                }
            })
              , l = wi.from({
                vertex: e8,
                fragment: J5,
                name: "mask-filter"
            });
            super(n8(s8({}, s), {
                gpuProgram: c,
                glProgram: l,
                clipToViewport: !1,
                resources: {
                    filterUniforms: a,
                    uMaskTexture: r.texture.source
                }
            })),
            this.sprite = r,
            this._textureMatrix = n
        }
        set inverse(e) {
            this.resources.filterUniforms.uniforms.uInverse = e ? 1 : 0
        }
        get inverse() {
            return this.resources.filterUniforms.uniforms.uInverse === 1
        }
        apply(e, t, r, s) {
            this._textureMatrix.texture = this.sprite.texture,
            e.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite).prepend(this._textureMatrix.mapCoord),
            this.resources.uMaskTexture = this.sprite.texture.source,
            e.applyFilter(this, t, r, s)
        }
    }
    ;
    var km = class Um {
        constructor(e) {
            this._tick = () => {
                this.timeout = setTimeout(this._processQueue, 0)
            }
            ,
            this._processQueue = () => {
                let {queue: t} = this
                  , r = 0;
                for (; t.length && r < Um.uploadsPerFrame; ) {
                    let s = t.shift();
                    this.uploadQueueItem(s),
                    r++
                }
                t.length ? nt.system.addOnce(this._tick, this, gi.UTILITY) : this._resolve()
            }
            ,
            this.renderer = e,
            this.queue = [],
            this.resolves = []
        }
        getQueue() {
            return [...this.queue]
        }
        add(e) {
            let t = Array.isArray(e) ? e : [e];
            for (let r of t)
                r instanceof _e ? this._addContainer(r) : this.resolveQueueItem(r, this.queue);
            return this
        }
        _addContainer(e) {
            this.resolveQueueItem(e, this.queue);
            for (let t of e.children)
                this._addContainer(t)
        }
        upload(e) {
            return e && this.add(e),
            new Promise(t => {
                this.queue.length ? (this.resolves.push(t),
                this.dedupeQueue(),
                nt.system.addOnce(this._tick, this, gi.UTILITY)) : t()
            }
            )
        }
        dedupeQueue() {
            let e = Object.create(null)
              , t = 0;
            for (let r = 0; r < this.queue.length; r++) {
                let s = this.queue[r];
                e[s.uid] || (e[s.uid] = !0,
                this.queue[t++] = s)
            }
            this.queue.length = t
        }
        _resolve() {
            let {resolves: e} = this
              , t = e.slice(0);
            e.length = 0;
            for (let r of t)
                r()
        }
    }
    ;
    km.uploadsPerFrame = 4;
    var o8 = km
      , c8 = Object.defineProperty
      , da = Object.getOwnPropertySymbols
      , Lm = Object.prototype.hasOwnProperty
      , Nm = Object.prototype.propertyIsEnumerable
      , _p = (i, e, t) => e in i ? c8(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , l8 = (i, e) => {
        for (var t in e || (e = {}))
            Lm.call(e, t) && _p(i, t, e[t]);
        if (da)
            for (var t of da(e))
                Nm.call(e, t) && _p(i, t, e[t]);
        return i
    }
      , h8 = (i, e) => {
        var t = {};
        for (var r in i)
            Lm.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && da)
            for (var r of da(i))
                e.indexOf(r) < 0 && Nm.call(i, r) && (t[r] = i[r]);
        return t
    }
      , tr = class extends _i {
        constructor(...e) {
            var t;
            let r = e[0];
            r instanceof oi && (r = {
                geometry: r,
                shader: e[1]
            },
            e[3] && (r.geometry.topology = e[3]));
            let s = r
              , {geometry: n, shader: a, texture: c, roundPixels: l, state: u} = s
              , d = h8(s, ["geometry", "shader", "texture", "roundPixels", "state"]);
            super(l8({
                label: "Mesh"
            }, d)),
            this.renderPipeId = "mesh",
            this._shader = null,
            this.allowChildren = !1,
            this.shader = a ?? null,
            this.texture = (t = c ?? a?.texture) != null ? t : Z.WHITE,
            this.state = u ?? Nt.for2d(),
            this._geometry = n,
            this._geometry.on("update", this.onViewUpdate, this),
            this.roundPixels = l ?? !1
        }
        get material() {
            return this._shader
        }
        set shader(e) {
            this._shader !== e && (this._shader = e,
            this.onViewUpdate())
        }
        get shader() {
            return this._shader
        }
        set geometry(e) {
            var t;
            this._geometry !== e && ((t = this._geometry) == null || t.off("update", this.onViewUpdate, this),
            e.on("update", this.onViewUpdate, this),
            this._geometry = e,
            this.onViewUpdate())
        }
        get geometry() {
            return this._geometry
        }
        set texture(e) {
            e || (e = Z.EMPTY);
            let t = this._texture;
            t !== e && (t && t.dynamic && t.off("update", this.onViewUpdate, this),
            e.dynamic && e.on("update", this.onViewUpdate, this),
            this.shader && (this.shader.texture = e),
            this._texture = e,
            this.onViewUpdate())
        }
        get texture() {
            return this._texture
        }
        get batched() {
            return this._shader || this.state.data & 12 ? !1 : this._geometry instanceof Is ? this._geometry.batchMode === "auto" ? this._geometry.positions.length / 2 <= 100 : this._geometry.batchMode === "batch" : !1
        }
        get bounds() {
            return this._geometry.bounds
        }
        updateBounds() {
            this._bounds = this._geometry.bounds
        }
        containsPoint(e) {
            let {x: t, y: r} = e;
            if (!this.bounds.containsPoint(t, r))
                return !1;
            let s = this.geometry.getBuffer("aPosition").data
              , n = this.geometry.topology === "triangle-strip" ? 3 : 1;
            if (this.geometry.getIndex()) {
                let a = this.geometry.getIndex().data
                  , c = a.length;
                for (let l = 0; l + 2 < c; l += n) {
                    let u = a[l] * 2
                      , d = a[l + 1] * 2
                      , f = a[l + 2] * 2;
                    if (Bf(t, r, s[u], s[u + 1], s[d], s[d + 1], s[f], s[f + 1]))
                        return !0
                }
            } else {
                let a = s.length / 2;
                for (let c = 0; c + 2 < a; c += n) {
                    let l = c * 2
                      , u = (c + 1) * 2
                      , d = (c + 2) * 2;
                    if (Bf(t, r, s[l], s[l + 1], s[u], s[u + 1], s[d], s[d + 1]))
                        return !0
                }
            }
            return !1
        }
        destroy(e) {
            var t;
            if (super.destroy(e),
            typeof e == "boolean" ? e : e?.texture) {
                let r = typeof e == "boolean" ? e : e?.textureSource;
                this._texture.destroy(r)
            }
            (t = this._geometry) == null || t.off("update", this.onViewUpdate, this),
            this._texture = null,
            this._geometry = null,
            this._shader = null,
            this._gpuData = null
        }
    }
      , u8 = Object.defineProperty
      , d8 = Object.defineProperties
      , f8 = Object.getOwnPropertyDescriptors
      , fa = Object.getOwnPropertySymbols
      , Xm = Object.prototype.hasOwnProperty
      , jm = Object.prototype.propertyIsEnumerable
      , xp = (i, e, t) => e in i ? u8(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , p8 = (i, e) => {
        for (var t in e || (e = {}))
            Xm.call(e, t) && xp(i, t, e[t]);
        if (fa)
            for (var t of fa(e))
                jm.call(e, t) && xp(i, t, e[t]);
        return i
    }
      , b8 = (i, e) => d8(i, f8(e))
      , m8 = (i, e) => {
        var t = {};
        for (var r in i)
            Xm.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && fa)
            for (var r of fa(i))
                e.indexOf(r) < 0 && jm.call(i, r) && (t[r] = i[r]);
        return t
    }
      , Xl = class i extends Ge {
        constructor(...e) {
            let t = e[0];
            Array.isArray(e[0]) && (t = {
                textures: e[0],
                autoUpdate: e[1]
            });
            let r = t
              , {animationSpeed: s=1, autoPlay: n=!1, autoUpdate: a=!0, loop: c=!0, onComplete: l=null, onFrameChange: u=null, onLoop: d=null, textures: f, updateAnchor: b=!1} = r
              , m = m8(r, ["animationSpeed", "autoPlay", "autoUpdate", "loop", "onComplete", "onFrameChange", "onLoop", "textures", "updateAnchor"])
              , [x] = f;
            super(b8(p8({}, m), {
                texture: x instanceof Z ? x : x.texture
            })),
            this._textures = null,
            this._durations = null,
            this._autoUpdate = a,
            this._isConnectedToTicker = !1,
            this.animationSpeed = s,
            this.loop = c,
            this.updateAnchor = b,
            this.onComplete = l,
            this.onFrameChange = u,
            this.onLoop = d,
            this._currentTime = 0,
            this._playing = !1,
            this._previousFrame = null,
            this.textures = f,
            n && this.play()
        }
        stop() {
            this._playing && (this._playing = !1,
            this._autoUpdate && this._isConnectedToTicker && (nt.shared.remove(this.update, this),
            this._isConnectedToTicker = !1))
        }
        play() {
            this._playing || (this._playing = !0,
            this._autoUpdate && !this._isConnectedToTicker && (nt.shared.add(this.update, this, gi.HIGH),
            this._isConnectedToTicker = !0))
        }
        gotoAndStop(e) {
            this.stop(),
            this.currentFrame = e
        }
        gotoAndPlay(e) {
            this.currentFrame = e,
            this.play()
        }
        update(e) {
            if (!this._playing)
                return;
            let t = e.deltaTime
              , r = this.animationSpeed * t
              , s = this.currentFrame;
            if (this._durations !== null) {
                let n = this._currentTime % 1 * this._durations[this.currentFrame];
                for (n += r / 60 * 1e3; n < 0; )
                    this._currentTime--,
                    n += this._durations[this.currentFrame];
                let a = Math.sign(this.animationSpeed * t);
                for (this._currentTime = Math.floor(this._currentTime); n >= this._durations[this.currentFrame]; )
                    n -= this._durations[this.currentFrame] * a,
                    this._currentTime += a;
                this._currentTime += n / this._durations[this.currentFrame]
            } else
                this._currentTime += r;
            this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0),
            this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1),
            this.onComplete && this.onComplete()) : s !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < s || this.animationSpeed < 0 && this.currentFrame > s) && this.onLoop(),
            this._updateTexture())
        }
        _updateTexture() {
            let e = this.currentFrame;
            this._previousFrame !== e && (this._previousFrame = e,
            this.texture = this._textures[e],
            this.updateAnchor && this.texture.defaultAnchor && this.anchor.copyFrom(this.texture.defaultAnchor),
            this.onFrameChange && this.onFrameChange(this.currentFrame))
        }
        destroy(e=!1) {
            if (typeof e == "boolean" ? e : e != null && e.texture) {
                let t = typeof e == "boolean" ? e : e?.textureSource;
                this._textures.forEach(r => {
                    this.texture !== r && r.destroy(t)
                }
                )
            }
            this._textures = [],
            this._durations = null,
            this.stop(),
            super.destroy(e),
            this.onComplete = null,
            this.onFrameChange = null,
            this.onLoop = null
        }
        static fromFrames(e) {
            let t = [];
            for (let r = 0; r < e.length; ++r)
                t.push(Z.from(e[r]));
            return new i(t)
        }
        static fromImages(e) {
            let t = [];
            for (let r = 0; r < e.length; ++r)
                t.push(Z.from(e[r]));
            return new i(t)
        }
        get totalFrames() {
            return this._textures.length
        }
        get textures() {
            return this._textures
        }
        set textures(e) {
            if (e[0]instanceof Z)
                this._textures = e,
                this._durations = null;
            else {
                this._textures = [],
                this._durations = [];
                for (let t = 0; t < e.length; t++)
                    this._textures.push(e[t].texture),
                    this._durations.push(e[t].time)
            }
            this._previousFrame = null,
            this.gotoAndStop(0),
            this._updateTexture()
        }
        get currentFrame() {
            let e = Math.floor(this._currentTime) % this._textures.length;
            return e < 0 && (e += this._textures.length),
            e
        }
        set currentFrame(e) {
            if (e < 0 || e > this.totalFrames - 1)
                throw new Error(`[AnimatedSprite]: Invalid frame index value ${e}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
            let t = this.currentFrame;
            this._currentTime = e,
            t !== this.currentFrame && this._updateTexture()
        }
        get playing() {
            return this._playing
        }
        get autoUpdate() {
            return this._autoUpdate
        }
        set autoUpdate(e) {
            e !== this._autoUpdate && (this._autoUpdate = e,
            !this._autoUpdate && this._isConnectedToTicker ? (nt.shared.remove(this.update, this),
            this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (nt.shared.add(this.update, this),
            this._isConnectedToTicker = !0))
        }
    }
      , jl = class {
        constructor({matrix: e, observer: t}={}) {
            this.dirty = !0,
            this._matrix = e ?? new ce,
            this.observer = t,
            this.position = new We(this,0,0),
            this.scale = new We(this,1,1),
            this.pivot = new We(this,0,0),
            this.skew = new We(this,0,0),
            this._rotation = 0,
            this._cx = 1,
            this._sx = 0,
            this._cy = 0,
            this._sy = 1
        }
        get matrix() {
            let e = this._matrix;
            return this.dirty && (e.a = this._cx * this.scale.x,
            e.b = this._sx * this.scale.x,
            e.c = this._cy * this.scale.y,
            e.d = this._sy * this.scale.y,
            e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c),
            e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d),
            this.dirty = !1),
            e
        }
        _onUpdate(e) {
            var t;
            this.dirty = !0,
            e === this.skew && this.updateSkew(),
            (t = this.observer) == null || t._onUpdate(this)
        }
        updateSkew() {
            this._cx = Math.cos(this._rotation + this.skew.y),
            this._sx = Math.sin(this._rotation + this.skew.y),
            this._cy = -Math.sin(this._rotation - this.skew.x),
            this._sy = Math.cos(this._rotation - this.skew.x),
            this.dirty = !0
        }
        setFromMatrix(e) {
            e.decompose(this),
            this.dirty = !0
        }
        get rotation() {
            return this._rotation
        }
        set rotation(e) {
            this._rotation !== e && (this._rotation = e,
            this._onUpdate(this.skew))
        }
    }
      , g8 = Object.defineProperty
      , pa = Object.getOwnPropertySymbols
      , Hm = Object.prototype.hasOwnProperty
      , zm = Object.prototype.propertyIsEnumerable
      , yp = (i, e, t) => e in i ? g8(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Yr = (i, e) => {
        for (var t in e || (e = {}))
            Hm.call(e, t) && yp(i, t, e[t]);
        if (pa)
            for (var t of pa(e))
                zm.call(e, t) && yp(i, t, e[t]);
        return i
    }
      , _8 = (i, e) => {
        var t = {};
        for (var r in i)
            Hm.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && pa)
            for (var r of pa(i))
                e.indexOf(r) < 0 && zm.call(i, r) && (t[r] = i[r]);
        return t
    }
      , Vm = class ln extends _i {
        constructor(...e) {
            let t = e[0] || {};
            t instanceof Z && (t = {
                texture: t
            }),
            e.length > 1 && (t.width = e[1],
            t.height = e[2]),
            t = Yr(Yr({}, ln.defaultOptions), t);
            let r = t ?? {}
              , {texture: s, anchor: n, tilePosition: a, tileScale: c, tileRotation: l, width: u, height: d, applyAnchorToTexture: f, roundPixels: b} = r
              , m = _8(r, ["texture", "anchor", "tilePosition", "tileScale", "tileRotation", "width", "height", "applyAnchorToTexture", "roundPixels"]);
            super(Yr({
                label: "TilingSprite"
            }, m)),
            this.renderPipeId = "tilingSprite",
            this.batched = !0,
            this.allowChildren = !1,
            this._anchor = new We({
                _onUpdate: () => {
                    this.onViewUpdate()
                }
            }),
            this.applyAnchorToTexture = f,
            this.texture = s,
            this._width = u ?? s.width,
            this._height = d ?? s.height,
            this._tileTransform = new jl({
                observer: {
                    _onUpdate: () => this.onViewUpdate()
                }
            }),
            n && (this.anchor = n),
            this.tilePosition = a,
            this.tileScale = c,
            this.tileRotation = l,
            this.roundPixels = b ?? !1
        }
        static from(e, t={}) {
            return typeof e == "string" ? new ln(Yr({
                texture: Oe.get(e)
            }, t)) : new ln(Yr({
                texture: e
            }, t))
        }
        get uvRespectAnchor() {
            return Pn(Ju, "uvRespectAnchor is deprecated, please use applyAnchorToTexture instead"),
            this.applyAnchorToTexture
        }
        set uvRespectAnchor(e) {
            Pn(Ju, "uvRespectAnchor is deprecated, please use applyAnchorToTexture instead"),
            this.applyAnchorToTexture = e
        }
        get clampMargin() {
            return this._texture.textureMatrix.clampMargin
        }
        set clampMargin(e) {
            this._texture.textureMatrix.clampMargin = e
        }
        get anchor() {
            return this._anchor
        }
        set anchor(e) {
            typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
        }
        get tilePosition() {
            return this._tileTransform.position
        }
        set tilePosition(e) {
            this._tileTransform.position.copyFrom(e)
        }
        get tileScale() {
            return this._tileTransform.scale
        }
        set tileScale(e) {
            typeof e == "number" ? this._tileTransform.scale.set(e) : this._tileTransform.scale.copyFrom(e)
        }
        set tileRotation(e) {
            this._tileTransform.rotation = e
        }
        get tileRotation() {
            return this._tileTransform.rotation
        }
        get tileTransform() {
            return this._tileTransform
        }
        set texture(e) {
            e || (e = Z.EMPTY);
            let t = this._texture;
            t !== e && (t && t.dynamic && t.off("update", this.onViewUpdate, this),
            e.dynamic && e.on("update", this.onViewUpdate, this),
            this._texture = e,
            this.onViewUpdate())
        }
        get texture() {
            return this._texture
        }
        set width(e) {
            this._width = e,
            this.onViewUpdate()
        }
        get width() {
            return this._width
        }
        set height(e) {
            this._height = e,
            this.onViewUpdate()
        }
        get height() {
            return this._height
        }
        setSize(e, t) {
            var r;
            typeof e == "object" && (t = (r = e.height) != null ? r : e.width,
            e = e.width),
            this._width = e,
            this._height = t ?? e,
            this.onViewUpdate()
        }
        getSize(e) {
            return e || (e = {}),
            e.width = this._width,
            e.height = this._height,
            e
        }
        updateBounds() {
            let e = this._bounds
              , t = this._anchor
              , r = this._width
              , s = this._height;
            e.minX = -t._x * r,
            e.maxX = e.minX + r,
            e.minY = -t._y * s,
            e.maxY = e.minY + s
        }
        containsPoint(e) {
            let t = this._width
              , r = this._height
              , s = -t * this._anchor._x
              , n = 0;
            return e.x >= s && e.x <= s + t && (n = -r * this._anchor._y,
            e.y >= n && e.y <= n + r)
        }
        destroy(e=!1) {
            if (super.destroy(e),
            this._anchor = null,
            this._tileTransform = null,
            this._bounds = null,
            typeof e == "boolean" ? e : e?.texture) {
                let t = typeof e == "boolean" ? e : e?.textureSource;
                this._texture.destroy(t)
            }
            this._texture = null
        }
    }
    ;
    Vm.defaultOptions = {
        texture: Z.EMPTY,
        anchor: {
            x: 0,
            y: 0
        },
        tilePosition: {
            x: 0,
            y: 0
        },
        tileScale: {
            x: 1,
            y: 1
        },
        tileRotation: 0,
        applyAnchorToTexture: !1
    };
    var x8 = Vm
      , y8 = Object.defineProperty
      , ba = Object.getOwnPropertySymbols
      , Wm = Object.prototype.hasOwnProperty
      , Ym = Object.prototype.propertyIsEnumerable
      , vp = (i, e, t) => e in i ? y8(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , v8 = (i, e) => {
        for (var t in e || (e = {}))
            Wm.call(e, t) && vp(i, t, e[t]);
        if (ba)
            for (var t of ba(e))
                Ym.call(e, t) && vp(i, t, e[t]);
        return i
    }
      , T8 = (i, e) => {
        var t = {};
        for (var r in i)
            Wm.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && ba)
            for (var r of ba(i))
                e.indexOf(r) < 0 && Ym.call(i, r) && (t[r] = i[r]);
        return t
    }
      , Ss = class extends _i {
        constructor(e, t) {
            let r = e
              , {text: s, resolution: n, style: a, anchor: c, width: l, height: u, roundPixels: d} = r
              , f = T8(r, ["text", "resolution", "style", "anchor", "width", "height", "roundPixels"]);
            super(v8({}, f)),
            this.batched = !0,
            this._resolution = null,
            this._autoResolution = !0,
            this._didTextUpdate = !0,
            this._styleClass = t,
            this.text = s ?? "",
            this.style = a,
            this.resolution = n ?? null,
            this.allowChildren = !1,
            this._anchor = new We({
                _onUpdate: () => {
                    this.onViewUpdate()
                }
            }),
            c && (this.anchor = c),
            this.roundPixels = d ?? !1,
            l !== void 0 && (this.width = l),
            u !== void 0 && (this.height = u)
        }
        get anchor() {
            return this._anchor
        }
        set anchor(e) {
            typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
        }
        set text(e) {
            e = e.toString(),
            this._text !== e && (this._text = e,
            this.onViewUpdate())
        }
        get text() {
            return this._text
        }
        set resolution(e) {
            this._autoResolution = e === null,
            this._resolution = e,
            this.onViewUpdate()
        }
        get resolution() {
            return this._resolution
        }
        get style() {
            return this._style
        }
        set style(e) {
            var t;
            e || (e = {}),
            (t = this._style) == null || t.off("update", this.onViewUpdate, this),
            e instanceof this._styleClass ? this._style = e : this._style = new this._styleClass(e),
            this._style.on("update", this.onViewUpdate, this),
            this.onViewUpdate()
        }
        get width() {
            return Math.abs(this.scale.x) * this.bounds.width
        }
        set width(e) {
            this._setWidth(e, this.bounds.width)
        }
        get height() {
            return Math.abs(this.scale.y) * this.bounds.height
        }
        set height(e) {
            this._setHeight(e, this.bounds.height)
        }
        getSize(e) {
            return e || (e = {}),
            e.width = Math.abs(this.scale.x) * this.bounds.width,
            e.height = Math.abs(this.scale.y) * this.bounds.height,
            e
        }
        setSize(e, t) {
            var r;
            typeof e == "object" ? (t = (r = e.height) != null ? r : e.width,
            e = e.width) : t != null || (t = e),
            e !== void 0 && this._setWidth(e, this.bounds.width),
            t !== void 0 && this._setHeight(t, this.bounds.height)
        }
        containsPoint(e) {
            let t = this.bounds.width
              , r = this.bounds.height
              , s = -t * this.anchor.x
              , n = 0;
            return e.x >= s && e.x <= s + t && (n = -r * this.anchor.y,
            e.y >= n && e.y <= n + r)
        }
        onViewUpdate() {
            this.didViewUpdate || (this._didTextUpdate = !0),
            super.onViewUpdate()
        }
        destroy(e=!1) {
            super.destroy(e),
            this.owner = null,
            this._bounds = null,
            this._anchor = null,
            (typeof e == "boolean" ? e : e != null && e.style) && this._style.destroy(e),
            this._style = null,
            this._text = null
        }
        get styleKey() {
            return `${this._text}:${this._style.styleKey}:${this._resolution}`
        }
    }
    ;
    function Uh(i, e) {
        var t;
        let r = (t = i[0]) != null ? t : {};
        return (typeof r == "string" || i[1]) && (r = {
            text: r,
            style: i[1]
        }),
        r
    }
    var Ue = class extends Ss {
        constructor(...e) {
            let t = Uh(e, "Text");
            super(t, Xt),
            this.renderPipeId = "text",
            t.textureStyle && (this.textureStyle = t.textureStyle instanceof Lt ? t.textureStyle : new Lt(t.textureStyle))
        }
        updateBounds() {
            let e = this._bounds
              , t = this._anchor
              , r = 0
              , s = 0;
            if (this._style.trim) {
                let {frame: n, canvasAndContext: a} = cs.getCanvasAndContext({
                    text: this.text,
                    style: this._style,
                    resolution: 1
                });
                cs.returnCanvasAndContext(a),
                r = n.width,
                s = n.height
            } else {
                let n = bt.measureText(this._text, this._style);
                r = n.width,
                s = n.height
            }
            e.minX = -t._x * r,
            e.maxX = e.minX + r,
            e.minY = -t._y * s,
            e.maxY = e.minY + s
        }
    }
      , Hl = class extends o8 {
        resolveQueueItem(e, t) {
            return e instanceof _e ? this.resolveContainerQueueItem(e, t) : e instanceof He || e instanceof Z ? t.push(e.source) : e instanceof wt && t.push(e),
            null
        }
        resolveContainerQueueItem(e, t) {
            e instanceof Ge || e instanceof x8 || e instanceof tr ? t.push(e.texture.source) : e instanceof Ue ? t.push(e) : e instanceof Ke ? t.push(e.context) : e instanceof Xl && e.textures.forEach(r => {
                r.source ? t.push(r.source) : t.push(r.texture.source)
            }
            )
        }
        resolveGraphicsContextQueueItem(e) {
            this.renderer.graphicsContext.getGpuContext(e);
            let {instructions: t} = e;
            for (let r of t)
                if (r.action === "texture") {
                    let {image: s} = r.data;
                    return s.source
                } else if (r.action === "fill") {
                    let {texture: s} = r.data.style;
                    return s.source
                }
            return null
        }
    }
      , ma = class extends Ss {
        constructor(...e) {
            var t, r, s;
            let n = Uh(e, "BitmapText");
            (t = n.style) != null || (n.style = n.style || {}),
            (s = (r = n.style).fill) != null || (r.fill = 16777215),
            super(n, Xt),
            this.renderPipeId = "bitmapText"
        }
        updateBounds() {
            let e = this._bounds
              , t = this._anchor
              , r = Ts.measureText(this.text, this._style)
              , s = r.scale
              , n = r.offsetY * s
              , a = r.width * s
              , c = r.height * s
              , l = this._style._stroke;
            l && (a += l.width,
            c += l.width),
            e.minX = -t._x * a,
            e.maxX = e.minX + a,
            e.minY = -t._y * (c + n),
            e.maxY = e.minY + c
        }
        set resolution(e) {}
        get resolution() {
            return this._resolution
        }
    }
    ;
    function S8(i) {
        let e = i._stroke
          , t = i._fill
          , r = [`div { ${[`color: ${Ie.shared.setValue(t.color).toHex()}`, `font-size: ${i.fontSize}px`, `font-family: ${i.fontFamily}`, `font-weight: ${i.fontWeight}`, `font-style: ${i.fontStyle}`, `font-variant: ${i.fontVariant}`, `letter-spacing: ${i.letterSpacing}px`, `text-align: ${i.align}`, `padding: ${i.padding}px`, `white-space: ${i.whiteSpace === "pre" && i.wordWrap ? "pre-wrap" : i.whiteSpace}`, ...i.lineHeight ? [`line-height: ${i.lineHeight}px`] : [], ...i.wordWrap ? [`word-wrap: ${i.breakWords ? "break-all" : "break-word"}`, `max-width: ${i.wordWrapWidth}px`] : [], ...e ? [Km(e)] : [], ...i.dropShadow ? [$m(i.dropShadow)] : [], ...i.cssOverrides].join(";")} }`];
        return w8(i.tagStyles, r),
        r.join(" ")
    }
    function $m(i) {
        let e = Ie.shared.setValue(i.color).setAlpha(i.alpha).toHexa()
          , t = Math.round(Math.cos(i.angle) * i.distance)
          , r = Math.round(Math.sin(i.angle) * i.distance)
          , s = `${t}px ${r}px`;
        return i.blur > 0 ? `text-shadow: ${s} ${i.blur}px ${e}` : `text-shadow: ${s} ${e}`
    }
    function Km(i) {
        return [`-webkit-text-stroke-width: ${i.width}px`, `-webkit-text-stroke-color: ${Ie.shared.setValue(i.color).toHex()}`, `text-stroke-width: ${i.width}px`, `text-stroke-color: ${Ie.shared.setValue(i.color).toHex()}`, "paint-order: stroke"].join(";")
    }
    var Tp = {
        fontSize: "font-size: {{VALUE}}px",
        fontFamily: "font-family: {{VALUE}}",
        fontWeight: "font-weight: {{VALUE}}",
        fontStyle: "font-style: {{VALUE}}",
        fontVariant: "font-variant: {{VALUE}}",
        letterSpacing: "letter-spacing: {{VALUE}}px",
        align: "text-align: {{VALUE}}",
        padding: "padding: {{VALUE}}px",
        whiteSpace: "white-space: {{VALUE}}",
        lineHeight: "line-height: {{VALUE}}px",
        wordWrapWidth: "max-width: {{VALUE}}px"
    }
      , Sp = {
        fill: i => `color: ${Ie.shared.setValue(i).toHex()}`,
        breakWords: i => `word-wrap: ${i ? "break-all" : "break-word"}`,
        stroke: Km,
        dropShadow: $m
    };
    function w8(i, e) {
        for (let t in i) {
            let r = i[t]
              , s = [];
            for (let n in r)
                Sp[n] ? s.push(Sp[n](r[n])) : Tp[n] && s.push(Tp[n].replace("{{VALUE}}", r[n]));
            e.push(`${t} { ${s.join(";")} }`)
        }
    }
    var A8 = Object.defineProperty
      , wp = Object.getOwnPropertySymbols
      , E8 = Object.prototype.hasOwnProperty
      , P8 = Object.prototype.propertyIsEnumerable
      , Ap = (i, e, t) => e in i ? A8(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Ep = (i, e) => {
        for (var t in e || (e = {}))
            E8.call(e, t) && Ap(i, t, e[t]);
        if (wp)
            for (var t of wp(e))
                P8.call(e, t) && Ap(i, t, e[t]);
        return i
    }
      , zl = class i extends Xt {
        constructor(e={}) {
            var t, r;
            super(e),
            this._cssOverrides = [],
            this.cssOverrides = (t = e.cssOverrides) != null ? t : [],
            this.tagStyles = (r = e.tagStyles) != null ? r : {}
        }
        set cssOverrides(e) {
            this._cssOverrides = e instanceof Array ? e : [e],
            this.update()
        }
        get cssOverrides() {
            return this._cssOverrides
        }
        update() {
            this._cssStyle = null,
            super.update()
        }
        clone() {
            return new i({
                align: this.align,
                breakWords: this.breakWords,
                dropShadow: this.dropShadow ? Ep({}, this.dropShadow) : null,
                fill: this._fill,
                fontFamily: this.fontFamily,
                fontSize: this.fontSize,
                fontStyle: this.fontStyle,
                fontVariant: this.fontVariant,
                fontWeight: this.fontWeight,
                letterSpacing: this.letterSpacing,
                lineHeight: this.lineHeight,
                padding: this.padding,
                stroke: this._stroke,
                whiteSpace: this.whiteSpace,
                wordWrap: this.wordWrap,
                wordWrapWidth: this.wordWrapWidth,
                cssOverrides: this.cssOverrides,
                tagStyles: Ep({}, this.tagStyles)
            })
        }
        get cssStyle() {
            return this._cssStyle || (this._cssStyle = S8(this)),
            this._cssStyle
        }
        addOverride(...e) {
            let t = e.filter(r => !this.cssOverrides.includes(r));
            t.length > 0 && (this.cssOverrides.push(...t),
            this.update())
        }
        removeOverride(...e) {
            let t = e.filter(r => this.cssOverrides.includes(r));
            t.length > 0 && (this.cssOverrides = this.cssOverrides.filter(r => !t.includes(r)),
            this.update())
        }
        set fill(e) {
            super.fill = e
        }
        set stroke(e) {
            super.stroke = e
        }
    }
      , Vl = class extends Ss {
        constructor(...e) {
            let t = Uh(e, "HtmlText");
            super(t, zl),
            this.renderPipeId = "htmlText",
            t.textureStyle && (this.textureStyle = t.textureStyle instanceof Lt ? t.textureStyle : new Lt(t.textureStyle))
        }
        updateBounds() {
            let e = this._bounds
              , t = this._anchor
              , r = q0(this.text, this._style)
              , {width: s, height: n} = r;
            e.minX = -t._x * s,
            e.maxX = e.minX + s,
            e.minY = -t._y * n,
            e.maxY = e.minY + n
        }
        get text() {
            return this._text
        }
        set text(e) {
            let t = this._sanitiseText(e.toString());
            super.text = t
        }
        _sanitiseText(e) {
            return this._removeInvalidHtmlTags(e.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;"))
        }
        _removeInvalidHtmlTags(e) {
            let t = /<[^>]*?(?=<|$)/g;
            return e.replace(t, "")
        }
    }
      , Wl = class extends Hl {
        uploadQueueItem(e) {
            e instanceof He ? this.uploadTextureSource(e) : e instanceof Ue ? this.uploadText(e) : e instanceof Vl ? this.uploadHTMLText(e) : e instanceof ma ? this.uploadBitmapText(e) : e instanceof wt && this.uploadGraphicsContext(e)
        }
        uploadTextureSource(e) {
            this.renderer.texture.initSource(e)
        }
        uploadText(e) {
            this.renderer.renderPipes.text.initGpuText(e)
        }
        uploadBitmapText(e) {
            this.renderer.renderPipes.bitmapText.initGpuText(e)
        }
        uploadHTMLText(e) {
            this.renderer.renderPipes.htmlText.initGpuText(e)
        }
        uploadGraphicsContext(e) {
            this.renderer.graphicsContext.getGpuContext(e);
            let {instructions: t} = e;
            for (let r of t)
                if (r.action === "texture") {
                    let {image: s} = r.data;
                    this.uploadTextureSource(s.source)
                } else if (r.action === "fill") {
                    let {texture: s} = r.data.style;
                    this.uploadTextureSource(s.source)
                }
            return null
        }
    }
      , Yl = class extends Wl {
        destroy() {
            clearTimeout(this.timeout),
            this.renderer = null,
            this.queue = null,
            this.resolves = null
        }
    }
    ;
    Yl.extension = {
        type: [B.WebGLSystem, B.WebGPUSystem],
        name: "prepare"
    };
    var ga = class {
        constructor() {
            this._tempState = Nt.for2d(),
            this._didUploadHash = {}
        }
        init(e) {
            e.renderer.runners.contextChange.add(this)
        }
        contextChange() {
            this._didUploadHash = {}
        }
        start(e, t, r) {
            let s = e.renderer
              , n = this._didUploadHash[r.uid];
            s.shader.bind(r, n),
            n || (this._didUploadHash[r.uid] = !0),
            s.shader.updateUniformGroup(s.globalUniforms.uniformGroup),
            s.geometry.bind(t, r.glProgram)
        }
        execute(e, t) {
            let r = e.renderer;
            this._tempState.blendMode = t.blendMode,
            r.state.set(this._tempState);
            let s = t.textures.textures;
            for (let n = 0; n < t.textures.count; n++)
                r.texture.bind(s[n], n);
            r.geometry.draw(t.topology, t.size, t.start)
        }
    }
    ;
    ga.extension = {
        type: [B.WebGLPipesAdaptor],
        name: "batch"
    };
    var tn = Nt.for2d()
      , _a = class {
        start(e, t, r) {
            let s = e.renderer
              , n = s.encoder
              , a = r.gpuProgram;
            this._shader = r,
            this._geometry = t,
            n.setGeometry(t, a),
            tn.blendMode = "normal",
            s.pipeline.getPipeline(t, a, tn);
            let c = s.globalUniforms.bindGroup;
            n.resetBindGroup(1),
            n.setBindGroup(0, c, a)
        }
        execute(e, t) {
            let r = this._shader.gpuProgram
              , s = e.renderer
              , n = s.encoder;
            if (!t.bindGroup) {
                let l = t.textures;
                t.bindGroup = Ph(l.textures, l.count, s.limits.maxBatchableTextures)
            }
            tn.blendMode = t.blendMode;
            let a = s.bindGroup.getBindGroup(t.bindGroup, r, 1)
              , c = s.pipeline.getPipeline(this._geometry, r, tn, t.topology);
            t.bindGroup._touch(s.textureGC.count),
            n.setPipeline(c),
            n.renderPassEncoder.setBindGroup(1, a),
            n.renderPassEncoder.drawIndexed(t.size, 1, t.start)
        }
    }
    ;
    _a.extension = {
        type: [B.WebGPUPipesAdaptor],
        name: "batch"
    };
    var $l = class qm {
        constructor(e, t) {
            this.state = Nt.for2d(),
            this._batchersByInstructionSet = Object.create(null),
            this._activeBatches = Object.create(null);
            var r, s;
            this.renderer = e,
            this._adaptor = t,
            (s = (r = this._adaptor).init) == null || s.call(r, this)
        }
        static getBatcher(e) {
            return new this._availableBatchers[e]
        }
        buildStart(e) {
            let t = this._batchersByInstructionSet[e.uid];
            t || (t = this._batchersByInstructionSet[e.uid] = Object.create(null),
            t.default || (t.default = new Gh({
                maxTextures: this.renderer.limits.maxBatchableTextures
            }))),
            this._activeBatches = t,
            this._activeBatch = this._activeBatches.default;
            for (let r in this._activeBatches)
                this._activeBatches[r].begin()
        }
        addToBatch(e, t) {
            if (this._activeBatch.name !== e.batcherName) {
                this._activeBatch.break(t);
                let r = this._activeBatches[e.batcherName];
                r || (r = this._activeBatches[e.batcherName] = qm.getBatcher(e.batcherName),
                r.begin()),
                this._activeBatch = r
            }
            this._activeBatch.add(e)
        }
        break(e) {
            this._activeBatch.break(e)
        }
        buildEnd(e) {
            this._activeBatch.break(e);
            let t = this._activeBatches;
            for (let r in t) {
                let s = t[r]
                  , n = s.geometry;
                n.indexBuffer.setDataWithSize(s.indexBuffer, s.indexSize, !0),
                n.buffers[0].setDataWithSize(s.attributeBuffer.float32View, s.attributeSize, !1)
            }
        }
        upload(e) {
            let t = this._batchersByInstructionSet[e.uid];
            for (let r in t) {
                let s = t[r]
                  , n = s.geometry;
                s.dirty && (s.dirty = !1,
                n.buffers[0].update(s.attributeSize * 4))
            }
        }
        execute(e) {
            if (e.action === "startBatch") {
                let t = e.batcher
                  , r = t.geometry
                  , s = t.shader;
                this._adaptor.start(this, r, s)
            }
            this._adaptor.execute(this, e)
        }
        destroy() {
            this.state = null,
            this.renderer = null,
            this._adaptor = null;
            for (let e in this._activeBatches)
                this._activeBatches[e].destroy();
            this._activeBatches = null
        }
    }
    ;
    $l.extension = {
        type: [B.WebGLPipes, B.WebGPUPipes, B.CanvasPipes],
        name: "batch"
    },
    $l._availableBatchers = Object.create(null);
    var Zm = $l;
    be.handleByMap(B.Batcher, Zm._availableBatchers),
    be.add(Gh);
    var R8 = {
        name: "texture-bit",
        vertex: {
            header: `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `,
            main: `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
        },
        fragment: {
            header: `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;


        `,
            main: `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
        }
    }
      , M8 = {
        name: "texture-bit",
        vertex: {
            header: `
            uniform mat3 uTextureMatrix;
        `,
            main: `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
        },
        fragment: {
            header: `
        uniform sampler2D uTexture;


        `,
            main: `
            outColor = texture(uTexture, vUV);
        `
        }
    }
      , C8 = new at
      , O8 = class extends Tr {
        constructor() {
            super(),
            this.filters = [new Nl({
                sprite: new Ge(Z.EMPTY),
                inverse: !1,
                resolution: "inherit",
                antialias: "inherit"
            })]
        }
        get sprite() {
            return this.filters[0].sprite
        }
        set sprite(i) {
            this.filters[0].sprite = i
        }
        get inverse() {
            return this.filters[0].inverse
        }
        set inverse(i) {
            this.filters[0].inverse = i
        }
    }
      , xa = class {
        constructor(e) {
            this._activeMaskStage = [],
            this._renderer = e
        }
        push(e, t, r) {
            let s = this._renderer;
            if (s.renderPipes.batch.break(r),
            r.add({
                renderPipeId: "alphaMask",
                action: "pushMaskBegin",
                mask: e,
                inverse: t._maskOptions.inverse,
                canBundle: !1,
                maskedContainer: t
            }),
            e.inverse = t._maskOptions.inverse,
            e.renderMaskToTexture) {
                let n = e.mask;
                n.includeInBuild = !0,
                n.collectRenderables(r, s, null),
                n.includeInBuild = !1
            }
            s.renderPipes.batch.break(r),
            r.add({
                renderPipeId: "alphaMask",
                action: "pushMaskEnd",
                mask: e,
                maskedContainer: t,
                inverse: t._maskOptions.inverse,
                canBundle: !1
            })
        }
        pop(e, t, r) {
            this._renderer.renderPipes.batch.break(r),
            r.add({
                renderPipeId: "alphaMask",
                action: "popMaskEnd",
                mask: e,
                inverse: t._maskOptions.inverse,
                canBundle: !1
            })
        }
        execute(e) {
            let t = this._renderer
              , r = e.mask.renderMaskToTexture;
            if (e.action === "pushMaskBegin") {
                let s = et.get(O8);
                if (s.inverse = e.inverse,
                r) {
                    e.mask.mask.measurable = !0;
                    let n = uo(e.mask.mask, !0, C8);
                    e.mask.mask.measurable = !1,
                    n.ceil();
                    let a = t.renderTarget.renderTarget.colorTexture.source
                      , c = Qe.getOptimalTexture(n.width, n.height, a._resolution, a.antialias);
                    t.renderTarget.push(c, !0),
                    t.globalUniforms.push({
                        offset: n,
                        worldColor: 4294967295
                    });
                    let l = s.sprite;
                    l.texture = c,
                    l.worldTransform.tx = n.minX,
                    l.worldTransform.ty = n.minY,
                    this._activeMaskStage.push({
                        filterEffect: s,
                        maskedContainer: e.maskedContainer,
                        filterTexture: c
                    })
                } else
                    s.sprite = e.mask.mask,
                    this._activeMaskStage.push({
                        filterEffect: s,
                        maskedContainer: e.maskedContainer
                    })
            } else if (e.action === "pushMaskEnd") {
                let s = this._activeMaskStage[this._activeMaskStage.length - 1];
                r && (t.type === Bt.WEBGL && t.renderTarget.finishRenderPass(),
                t.renderTarget.pop(),
                t.globalUniforms.pop()),
                t.filter.push({
                    renderPipeId: "filter",
                    action: "pushFilter",
                    container: s.maskedContainer,
                    filterEffect: s.filterEffect,
                    canBundle: !1
                })
            } else if (e.action === "popMaskEnd") {
                t.filter.pop();
                let s = this._activeMaskStage.pop();
                r && Qe.returnTexture(s.filterTexture),
                et.return(s.filterEffect)
            }
        }
        destroy() {
            this._renderer = null,
            this._activeMaskStage = null
        }
    }
    ;
    xa.extension = {
        type: [B.WebGLPipes, B.WebGPUPipes, B.CanvasPipes],
        name: "alphaMask"
    };
    var ya = class {
        constructor(e) {
            this._colorStack = [],
            this._colorStackIndex = 0,
            this._currentColor = 0,
            this._renderer = e
        }
        buildStart() {
            this._colorStack[0] = 15,
            this._colorStackIndex = 1,
            this._currentColor = 15
        }
        push(e, t, r) {
            this._renderer.renderPipes.batch.break(r);
            let s = this._colorStack;
            s[this._colorStackIndex] = s[this._colorStackIndex - 1] & e.mask;
            let n = this._colorStack[this._colorStackIndex];
            n !== this._currentColor && (this._currentColor = n,
            r.add({
                renderPipeId: "colorMask",
                colorMask: n,
                canBundle: !1
            })),
            this._colorStackIndex++
        }
        pop(e, t, r) {
            this._renderer.renderPipes.batch.break(r);
            let s = this._colorStack;
            this._colorStackIndex--;
            let n = s[this._colorStackIndex - 1];
            n !== this._currentColor && (this._currentColor = n,
            r.add({
                renderPipeId: "colorMask",
                colorMask: n,
                canBundle: !1
            }))
        }
        execute(e) {
            this._renderer.colorMask.setMask(e.colorMask)
        }
        destroy() {
            this._renderer = null,
            this._colorStack = null
        }
    }
    ;
    ya.extension = {
        type: [B.WebGLPipes, B.WebGPUPipes, B.CanvasPipes],
        name: "colorMask"
    };
    var va = class {
        constructor(e) {
            this._maskStackHash = {},
            this._maskHash = new WeakMap,
            this._renderer = e
        }
        push(e, t, r) {
            var s, n;
            let a = e
              , c = this._renderer;
            c.renderPipes.batch.break(r),
            c.renderPipes.blendMode.setBlendMode(a.mask, "none", r),
            r.add({
                renderPipeId: "stencilMask",
                action: "pushMaskBegin",
                mask: e,
                inverse: t._maskOptions.inverse,
                canBundle: !1
            });
            let l = a.mask;
            l.includeInBuild = !0,
            this._maskHash.has(a) || this._maskHash.set(a, {
                instructionsStart: 0,
                instructionsLength: 0
            });
            let u = this._maskHash.get(a);
            u.instructionsStart = r.instructionSize,
            l.collectRenderables(r, c, null),
            l.includeInBuild = !1,
            c.renderPipes.batch.break(r),
            r.add({
                renderPipeId: "stencilMask",
                action: "pushMaskEnd",
                mask: e,
                inverse: t._maskOptions.inverse,
                canBundle: !1
            });
            let d = r.instructionSize - u.instructionsStart - 1;
            u.instructionsLength = d;
            let f = c.renderTarget.renderTarget.uid;
            (n = (s = this._maskStackHash)[f]) != null || (s[f] = 0)
        }
        pop(e, t, r) {
            let s = e
              , n = this._renderer;
            n.renderPipes.batch.break(r),
            n.renderPipes.blendMode.setBlendMode(s.mask, "none", r),
            r.add({
                renderPipeId: "stencilMask",
                action: "popMaskBegin",
                inverse: t._maskOptions.inverse,
                canBundle: !1
            });
            let a = this._maskHash.get(e);
            for (let c = 0; c < a.instructionsLength; c++)
                r.instructions[r.instructionSize++] = r.instructions[a.instructionsStart++];
            r.add({
                renderPipeId: "stencilMask",
                action: "popMaskEnd",
                canBundle: !1
            })
        }
        execute(e) {
            var t, r;
            let s = this._renderer
              , n = s.renderTarget.renderTarget.uid
              , a = (r = (t = this._maskStackHash)[n]) != null ? r : t[n] = 0;
            e.action === "pushMaskBegin" ? (s.renderTarget.ensureDepthStencil(),
            s.stencil.setStencilMode(Je.RENDERING_MASK_ADD, a),
            a++,
            s.colorMask.setMask(0)) : e.action === "pushMaskEnd" ? (e.inverse ? s.stencil.setStencilMode(Je.INVERSE_MASK_ACTIVE, a) : s.stencil.setStencilMode(Je.MASK_ACTIVE, a),
            s.colorMask.setMask(15)) : e.action === "popMaskBegin" ? (s.colorMask.setMask(0),
            a !== 0 ? s.stencil.setStencilMode(Je.RENDERING_MASK_REMOVE, a) : (s.renderTarget.clear(null, It.STENCIL),
            s.stencil.setStencilMode(Je.DISABLED, a)),
            a--) : e.action === "popMaskEnd" && (e.inverse ? s.stencil.setStencilMode(Je.INVERSE_MASK_ACTIVE, a) : s.stencil.setStencilMode(Je.MASK_ACTIVE, a),
            s.colorMask.setMask(15)),
            this._maskStackHash[n] = a
        }
        destroy() {
            this._renderer = null,
            this._maskStackHash = null,
            this._maskHash = null
        }
    }
    ;
    va.extension = {
        type: [B.WebGLPipes, B.WebGPUPipes, B.CanvasPipes],
        name: "stencilMask"
    };
    var hn = (i => (i[i.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER",
    i[i.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER",
    i[i.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER",
    i))(hn || {})
      , Kl = class {
        constructor(e, t) {
            this._lastBindBaseLocation = -1,
            this._lastBindCallId = -1,
            this.buffer = e || null,
            this.updateID = -1,
            this.byteLength = -1,
            this.type = t
        }
    }
      , Ta = class {
        constructor(e) {
            this._gpuBuffers = Object.create(null),
            this._boundBufferBases = Object.create(null),
            this._minBaseLocation = 0,
            this._nextBindBaseIndex = this._minBaseLocation,
            this._bindCallId = 0,
            this._renderer = e,
            this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers")
        }
        destroy() {
            this._renderer = null,
            this._gl = null,
            this._gpuBuffers = null,
            this._boundBufferBases = null
        }
        contextChange() {
            this._gl = this._renderer.gl,
            this._gpuBuffers = Object.create(null),
            this._maxBindings = this._renderer.limits.maxUniformBindings
        }
        getGlBuffer(e) {
            return this._gpuBuffers[e.uid] || this.createGLBuffer(e)
        }
        bind(e) {
            let {_gl: t} = this
              , r = this.getGlBuffer(e);
            t.bindBuffer(r.type, r.buffer)
        }
        bindBufferBase(e, t) {
            let {_gl: r} = this;
            this._boundBufferBases[t] !== e && (this._boundBufferBases[t] = e,
            e._lastBindBaseLocation = t,
            r.bindBufferBase(r.UNIFORM_BUFFER, t, e.buffer))
        }
        nextBindBase(e) {
            this._bindCallId++,
            this._minBaseLocation = 0,
            e && (this._boundBufferBases[0] = null,
            this._minBaseLocation = 1,
            this._nextBindBaseIndex < 1 && (this._nextBindBaseIndex = 1))
        }
        freeLocationForBufferBase(e) {
            let t = this.getLastBindBaseLocation(e);
            if (t >= this._minBaseLocation)
                return e._lastBindCallId = this._bindCallId,
                t;
            let r = 0
              , s = this._nextBindBaseIndex;
            for (; r < 2; ) {
                s >= this._maxBindings && (s = this._minBaseLocation,
                r++);
                let n = this._boundBufferBases[s];
                if (n && n._lastBindCallId === this._bindCallId) {
                    s++;
                    continue
                }
                break
            }
            return t = s,
            this._nextBindBaseIndex = s + 1,
            r >= 2 ? -1 : (e._lastBindCallId = this._bindCallId,
            this._boundBufferBases[t] = null,
            t)
        }
        getLastBindBaseLocation(e) {
            let t = e._lastBindBaseLocation;
            return this._boundBufferBases[t] === e ? t : -1
        }
        bindBufferRange(e, t, r, s) {
            let {_gl: n} = this;
            r || (r = 0),
            t || (t = 0),
            this._boundBufferBases[t] = null,
            n.bindBufferRange(n.UNIFORM_BUFFER, t || 0, e.buffer, r * 256, s || 256)
        }
        updateBuffer(e) {
            let {_gl: t} = this
              , r = this.getGlBuffer(e);
            if (e._updateID === r.updateID)
                return r;
            r.updateID = e._updateID,
            t.bindBuffer(r.type, r.buffer);
            let s = e.data
              , n = e.descriptor.usage & Ae.STATIC ? t.STATIC_DRAW : t.DYNAMIC_DRAW;
            return s ? r.byteLength >= s.byteLength ? t.bufferSubData(r.type, 0, s, 0, e._updateSize / s.BYTES_PER_ELEMENT) : (r.byteLength = s.byteLength,
            t.bufferData(r.type, s, n)) : (r.byteLength = e.descriptor.size,
            t.bufferData(r.type, r.byteLength, n)),
            r
        }
        destroyAll() {
            let e = this._gl;
            for (let t in this._gpuBuffers)
                e.deleteBuffer(this._gpuBuffers[t].buffer);
            this._gpuBuffers = Object.create(null)
        }
        onBufferDestroy(e, t) {
            let r = this._gpuBuffers[e.uid]
              , s = this._gl;
            t || s.deleteBuffer(r.buffer),
            this._gpuBuffers[e.uid] = null
        }
        createGLBuffer(e) {
            let {_gl: t} = this
              , r = hn.ARRAY_BUFFER;
            e.descriptor.usage & Ae.INDEX ? r = hn.ELEMENT_ARRAY_BUFFER : e.descriptor.usage & Ae.UNIFORM && (r = hn.UNIFORM_BUFFER);
            let s = new Kl(t.createBuffer(),r);
            return this._gpuBuffers[e.uid] = s,
            e.on("destroy", this.onBufferDestroy, this),
            s
        }
        resetState() {
            this._boundBufferBases = Object.create(null)
        }
    }
    ;
    Ta.extension = {
        type: [B.WebGLSystem],
        name: "buffer"
    };
    var I8 = Object.defineProperty
      , G8 = Object.defineProperties
      , B8 = Object.getOwnPropertyDescriptors
      , Pp = Object.getOwnPropertySymbols
      , F8 = Object.prototype.hasOwnProperty
      , D8 = Object.prototype.propertyIsEnumerable
      , Rp = (i, e, t) => e in i ? I8(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , rn = (i, e) => {
        for (var t in e || (e = {}))
            F8.call(e, t) && Rp(i, t, e[t]);
        if (Pp)
            for (var t of Pp(e))
                D8.call(e, t) && Rp(i, t, e[t]);
        return i
    }
      , Mp = (i, e) => G8(i, B8(e))
      , ql = class Qm {
        constructor(e) {
            this.supports = {
                uint32Indices: !0,
                uniformBufferObject: !0,
                vertexArrayObject: !0,
                srgbTextures: !0,
                nonPowOf2wrapping: !0,
                msaa: !0,
                nonPowOf2mipmaps: !0
            },
            this._renderer = e,
            this.extensions = Object.create(null),
            this.handleContextLost = this.handleContextLost.bind(this),
            this.handleContextRestored = this.handleContextRestored.bind(this)
        }
        get isLost() {
            return !this.gl || this.gl.isContextLost()
        }
        contextChange(e) {
            this.gl = e,
            this._renderer.gl = e
        }
        init(e) {
            var t, r;
            e = rn(rn({}, Qm.defaultOptions), e);
            let s = this.multiView = e.multiView;
            if (e.context && s && (Ti("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together."),
            s = !1),
            s ? this.canvas = xe.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height) : this.canvas = this._renderer.view.canvas,
            e.context)
                this.initFromContext(e.context);
            else {
                let n = this._renderer.background.alpha < 1
                  , a = (t = e.premultipliedAlpha) != null ? t : !0
                  , c = e.antialias && !this._renderer.backBuffer.useBackBuffer;
                this.createContext(e.preferWebGLVersion, {
                    alpha: n,
                    premultipliedAlpha: a,
                    antialias: c,
                    stencil: !0,
                    preserveDrawingBuffer: e.preserveDrawingBuffer,
                    powerPreference: (r = e.powerPreference) != null ? r : "default"
                })
            }
        }
        ensureCanvasSize(e) {
            if (!this.multiView) {
                e !== this.canvas && Ti("multiView is disabled, but targetCanvas is not the main canvas");
                return
            }
            let {canvas: t} = this;
            (t.width < e.width || t.height < e.height) && (t.width = Math.max(e.width, e.width),
            t.height = Math.max(e.height, e.height))
        }
        initFromContext(e) {
            this.gl = e,
            this.webGLVersion = e instanceof xe.get().getWebGLRenderingContext() ? 1 : 2,
            this.getExtensions(),
            this.validateContext(e),
            this._renderer.runners.contextChange.emit(e);
            let t = this._renderer.view.canvas;
            t.addEventListener("webglcontextlost", this.handleContextLost, !1),
            t.addEventListener("webglcontextrestored", this.handleContextRestored, !1)
        }
        createContext(e, t) {
            let r, s = this.canvas;
            if (e === 2 && (r = s.getContext("webgl2", t)),
            !r && (r = s.getContext("webgl", t),
            !r))
                throw new Error("This browser does not support WebGL. Try using the canvas renderer");
            this.gl = r,
            this.initFromContext(this.gl)
        }
        getExtensions() {
            let {gl: e} = this
              , t = {
                anisotropicFiltering: e.getExtension("EXT_texture_filter_anisotropic"),
                floatTextureLinear: e.getExtension("OES_texture_float_linear"),
                s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
                s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
                etc: e.getExtension("WEBGL_compressed_texture_etc"),
                etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
                pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                atc: e.getExtension("WEBGL_compressed_texture_atc"),
                astc: e.getExtension("WEBGL_compressed_texture_astc"),
                bptc: e.getExtension("EXT_texture_compression_bptc"),
                rgtc: e.getExtension("EXT_texture_compression_rgtc"),
                loseContext: e.getExtension("WEBGL_lose_context")
            };
            if (this.webGLVersion === 1)
                this.extensions = Mp(rn({}, t), {
                    drawBuffers: e.getExtension("WEBGL_draw_buffers"),
                    depthTexture: e.getExtension("WEBGL_depth_texture"),
                    vertexArrayObject: e.getExtension("OES_vertex_array_object") || e.getExtension("MOZ_OES_vertex_array_object") || e.getExtension("WEBKIT_OES_vertex_array_object"),
                    uint32ElementIndex: e.getExtension("OES_element_index_uint"),
                    floatTexture: e.getExtension("OES_texture_float"),
                    floatTextureLinear: e.getExtension("OES_texture_float_linear"),
                    textureHalfFloat: e.getExtension("OES_texture_half_float"),
                    textureHalfFloatLinear: e.getExtension("OES_texture_half_float_linear"),
                    vertexAttribDivisorANGLE: e.getExtension("ANGLE_instanced_arrays"),
                    srgb: e.getExtension("EXT_sRGB")
                });
            else {
                this.extensions = Mp(rn({}, t), {
                    colorBufferFloat: e.getExtension("EXT_color_buffer_float")
                });
                let r = e.getExtension("WEBGL_provoking_vertex");
                r && r.provokingVertexWEBGL(r.FIRST_VERTEX_CONVENTION_WEBGL)
            }
        }
        handleContextLost(e) {
            e.preventDefault(),
            this._contextLossForced && (this._contextLossForced = !1,
            setTimeout( () => {
                var t;
                this.gl.isContextLost() && ((t = this.extensions.loseContext) == null || t.restoreContext())
            }
            , 0))
        }
        handleContextRestored() {
            this.getExtensions(),
            this._renderer.runners.contextChange.emit(this.gl)
        }
        destroy() {
            var e;
            let t = this._renderer.view.canvas;
            this._renderer = null,
            t.removeEventListener("webglcontextlost", this.handleContextLost),
            t.removeEventListener("webglcontextrestored", this.handleContextRestored),
            this.gl.useProgram(null),
            (e = this.extensions.loseContext) == null || e.loseContext()
        }
        forceContextLoss() {
            var e;
            (e = this.extensions.loseContext) == null || e.loseContext(),
            this._contextLossForced = !0
        }
        validateContext(e) {
            let t = e.getContextAttributes();
            t && t.stencil;
            let r = this.supports
              , s = this.webGLVersion === 2
              , n = this.extensions;
            r.uint32Indices = s || !!n.uint32ElementIndex,
            r.uniformBufferObject = s,
            r.vertexArrayObject = s || !!n.vertexArrayObject,
            r.srgbTextures = s || !!n.srgb,
            r.nonPowOf2wrapping = s,
            r.nonPowOf2mipmaps = s,
            r.msaa = s,
            r.uint32Indices
        }
    }
    ;
    ql.extension = {
        type: [B.WebGLSystem],
        name: "context"
    },
    ql.defaultOptions = {
        context: null,
        premultipliedAlpha: !0,
        preserveDrawingBuffer: !1,
        powerPreference: void 0,
        preferWebGLVersion: 2,
        multiView: !1
    };
    var k8 = ql;
    function Jm(i, e) {
        var t, r, s;
        for (let n in i.attributes) {
            let a = i.attributes[n]
              , c = e[n];
            c ? ((t = a.format) != null || (a.format = c.format),
            (r = a.offset) != null || (a.offset = c.offset),
            (s = a.instance) != null || (a.instance = c.instance)) : Ti(`Attribute ${n} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`)
        }
        U8(i)
    }
    function U8(i) {
        var e, t;
        let {buffers: r, attributes: s} = i
          , n = {}
          , a = {};
        for (let c in r) {
            let l = r[c];
            n[l.uid] = 0,
            a[l.uid] = 0
        }
        for (let c in s) {
            let l = s[c];
            n[l.buffer.uid] += Gi(l.format).stride
        }
        for (let c in s) {
            let l = s[c];
            (e = l.stride) != null || (l.stride = n[l.buffer.uid]),
            (t = l.start) != null || (l.start = a[l.buffer.uid]),
            a[l.buffer.uid] += Gi(l.format).stride
        }
    }
    var Zl = (i => (i[i.RGBA = 6408] = "RGBA",
    i[i.RGB = 6407] = "RGB",
    i[i.RG = 33319] = "RG",
    i[i.RED = 6403] = "RED",
    i[i.RGBA_INTEGER = 36249] = "RGBA_INTEGER",
    i[i.RGB_INTEGER = 36248] = "RGB_INTEGER",
    i[i.RG_INTEGER = 33320] = "RG_INTEGER",
    i[i.RED_INTEGER = 36244] = "RED_INTEGER",
    i[i.ALPHA = 6406] = "ALPHA",
    i[i.LUMINANCE = 6409] = "LUMINANCE",
    i[i.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA",
    i[i.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT",
    i[i.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL",
    i))(Zl || {})
      , eg = (i => (i[i.TEXTURE_2D = 3553] = "TEXTURE_2D",
    i[i.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP",
    i[i.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY",
    i[i.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X",
    i[i.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X",
    i[i.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y",
    i[i.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y",
    i[i.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z",
    i[i.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z",
    i))(eg || {})
      , L8 = (i => (i[i.CLAMP = 33071] = "CLAMP",
    i[i.REPEAT = 10497] = "REPEAT",
    i[i.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT",
    i))(L8 || {})
      , Pe = (i => (i[i.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE",
    i[i.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT",
    i[i.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5",
    i[i.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4",
    i[i.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1",
    i[i.UNSIGNED_INT = 5125] = "UNSIGNED_INT",
    i[i.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV",
    i[i.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV",
    i[i.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8",
    i[i.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV",
    i[i.BYTE = 5120] = "BYTE",
    i[i.SHORT = 5122] = "SHORT",
    i[i.INT = 5124] = "INT",
    i[i.FLOAT = 5126] = "FLOAT",
    i[i.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV",
    i[i.HALF_FLOAT = 36193] = "HALF_FLOAT",
    i))(Pe || {})
      , Cp = {
        uint8x2: Pe.UNSIGNED_BYTE,
        uint8x4: Pe.UNSIGNED_BYTE,
        sint8x2: Pe.BYTE,
        sint8x4: Pe.BYTE,
        unorm8x2: Pe.UNSIGNED_BYTE,
        unorm8x4: Pe.UNSIGNED_BYTE,
        snorm8x2: Pe.BYTE,
        snorm8x4: Pe.BYTE,
        uint16x2: Pe.UNSIGNED_SHORT,
        uint16x4: Pe.UNSIGNED_SHORT,
        sint16x2: Pe.SHORT,
        sint16x4: Pe.SHORT,
        unorm16x2: Pe.UNSIGNED_SHORT,
        unorm16x4: Pe.UNSIGNED_SHORT,
        snorm16x2: Pe.SHORT,
        snorm16x4: Pe.SHORT,
        float16x2: Pe.HALF_FLOAT,
        float16x4: Pe.HALF_FLOAT,
        float32: Pe.FLOAT,
        float32x2: Pe.FLOAT,
        float32x3: Pe.FLOAT,
        float32x4: Pe.FLOAT,
        uint32: Pe.UNSIGNED_INT,
        uint32x2: Pe.UNSIGNED_INT,
        uint32x3: Pe.UNSIGNED_INT,
        uint32x4: Pe.UNSIGNED_INT,
        sint32: Pe.INT,
        sint32x2: Pe.INT,
        sint32x3: Pe.INT,
        sint32x4: Pe.INT
    };
    function N8(i) {
        var e;
        return (e = Cp[i]) != null ? e : Cp.float32
    }
    var X8 = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 3,
        "triangle-list": 4,
        "triangle-strip": 5
    }
      , Sa = class {
        constructor(e) {
            this._geometryVaoHash = Object.create(null),
            this._renderer = e,
            this._activeGeometry = null,
            this._activeVao = null,
            this.hasVao = !0,
            this.hasInstance = !0,
            this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash")
        }
        contextChange() {
            let e = this.gl = this._renderer.gl;
            if (!this._renderer.context.supports.vertexArrayObject)
                throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
            let t = this._renderer.context.extensions.vertexArrayObject;
            t && (e.createVertexArray = () => t.createVertexArrayOES(),
            e.bindVertexArray = s => t.bindVertexArrayOES(s),
            e.deleteVertexArray = s => t.deleteVertexArrayOES(s));
            let r = this._renderer.context.extensions.vertexAttribDivisorANGLE;
            r && (e.drawArraysInstanced = (s, n, a, c) => {
                r.drawArraysInstancedANGLE(s, n, a, c)
            }
            ,
            e.drawElementsInstanced = (s, n, a, c, l) => {
                r.drawElementsInstancedANGLE(s, n, a, c, l)
            }
            ,
            e.vertexAttribDivisor = (s, n) => r.vertexAttribDivisorANGLE(s, n)),
            this._activeGeometry = null,
            this._activeVao = null,
            this._geometryVaoHash = Object.create(null)
        }
        bind(e, t) {
            let r = this.gl;
            this._activeGeometry = e;
            let s = this.getVao(e, t);
            this._activeVao !== s && (this._activeVao = s,
            r.bindVertexArray(s)),
            this.updateBuffers()
        }
        resetState() {
            this.unbind()
        }
        updateBuffers() {
            let e = this._activeGeometry
              , t = this._renderer.buffer;
            for (let r = 0; r < e.buffers.length; r++) {
                let s = e.buffers[r];
                t.updateBuffer(s)
            }
        }
        checkCompatibility(e, t) {
            let r = e.attributes
              , s = t._attributeData;
            for (let n in s)
                if (!r[n])
                    throw new Error(`shader and geometry incompatible, geometry missing the "${n}" attribute`)
        }
        getSignature(e, t) {
            let r = e.attributes
              , s = t._attributeData
              , n = ["g", e.uid];
            for (let a in r)
                s[a] && n.push(a, s[a].location);
            return n.join("-")
        }
        getVao(e, t) {
            var r;
            return ((r = this._geometryVaoHash[e.uid]) == null ? void 0 : r[t._key]) || this.initGeometryVao(e, t)
        }
        initGeometryVao(e, t, r=!0) {
            let s = this._renderer.gl
              , n = this._renderer.buffer;
            this._renderer.shader._getProgramData(t),
            this.checkCompatibility(e, t);
            let a = this.getSignature(e, t);
            this._geometryVaoHash[e.uid] || (this._geometryVaoHash[e.uid] = Object.create(null),
            e.on("destroy", this.onGeometryDestroy, this));
            let c = this._geometryVaoHash[e.uid]
              , l = c[a];
            if (l)
                return c[t._key] = l,
                l;
            Jm(e, t._attributeData);
            let u = e.buffers;
            l = s.createVertexArray(),
            s.bindVertexArray(l);
            for (let d = 0; d < u.length; d++) {
                let f = u[d];
                n.bind(f)
            }
            return this.activateVao(e, t),
            c[t._key] = l,
            c[a] = l,
            s.bindVertexArray(null),
            l
        }
        onGeometryDestroy(e, t) {
            let r = this._geometryVaoHash[e.uid]
              , s = this.gl;
            if (r) {
                if (t)
                    for (let n in r)
                        this._activeVao !== r[n] && this.unbind(),
                        s.deleteVertexArray(r[n]);
                this._geometryVaoHash[e.uid] = null
            }
        }
        destroyAll(e=!1) {
            let t = this.gl;
            for (let r in this._geometryVaoHash) {
                if (e)
                    for (let s in this._geometryVaoHash[r]) {
                        let n = this._geometryVaoHash[r];
                        this._activeVao !== n && this.unbind(),
                        t.deleteVertexArray(n[s])
                    }
                this._geometryVaoHash[r] = null
            }
        }
        activateVao(e, t) {
            var r, s;
            let n = this._renderer.gl
              , a = this._renderer.buffer
              , c = e.attributes;
            e.indexBuffer && a.bind(e.indexBuffer);
            let l = null;
            for (let u in c) {
                let d = c[u]
                  , f = d.buffer
                  , b = a.getGlBuffer(f)
                  , m = t._attributeData[u];
                if (m) {
                    l !== b && (a.bind(f),
                    l = b);
                    let x = m.location;
                    n.enableVertexAttribArray(x);
                    let y = Gi(d.format)
                      , S = N8(d.format);
                    if (((r = m.format) == null ? void 0 : r.substring(1, 4)) === "int" ? n.vertexAttribIPointer(x, y.size, S, d.stride, d.offset) : n.vertexAttribPointer(x, y.size, S, y.normalised, d.stride, d.offset),
                    d.instance)
                        if (this.hasInstance) {
                            let A = (s = d.divisor) != null ? s : 1;
                            n.vertexAttribDivisor(x, A)
                        } else
                            throw new Error("geometry error, GPU Instancing is not supported on this device")
                }
            }
        }
        draw(e, t, r, s) {
            let {gl: n} = this._renderer
              , a = this._activeGeometry
              , c = X8[e || a.topology];
            if (s != null || (s = a.instanceCount),
            a.indexBuffer) {
                let l = a.indexBuffer.data.BYTES_PER_ELEMENT
                  , u = l === 2 ? n.UNSIGNED_SHORT : n.UNSIGNED_INT;
                s > 1 ? n.drawElementsInstanced(c, t || a.indexBuffer.data.length, u, (r || 0) * l, s) : n.drawElements(c, t || a.indexBuffer.data.length, u, (r || 0) * l)
            } else
                s > 1 ? n.drawArraysInstanced(c, r || 0, t || a.getSize(), s) : n.drawArrays(c, r || 0, t || a.getSize());
            return this
        }
        unbind() {
            this.gl.bindVertexArray(null),
            this._activeVao = null,
            this._activeGeometry = null
        }
        destroy() {
            this._renderer = null,
            this.gl = null,
            this._activeVao = null,
            this._activeGeometry = null,
            this._geometryVaoHash = null
        }
    }
    ;
    Sa.extension = {
        type: [B.WebGLSystem],
        name: "geometry"
    };
    var j8 = Object.defineProperty
      , Op = Object.getOwnPropertySymbols
      , H8 = Object.prototype.hasOwnProperty
      , z8 = Object.prototype.propertyIsEnumerable
      , Ip = (i, e, t) => e in i ? j8(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Gp = (i, e) => {
        for (var t in e || (e = {}))
            H8.call(e, t) && Ip(i, t, e[t]);
        if (Op)
            for (var t of Op(e))
                z8.call(e, t) && Ip(i, t, e[t]);
        return i
    }
      , V8 = new oi({
        attributes: {
            aPosition: [-1, -1, 3, -1, -1, 3]
        }
    })
      , Ql = class tg {
        constructor(e) {
            this.useBackBuffer = !1,
            this._useBackBufferThisRender = !1,
            this._renderer = e
        }
        init(e={}) {
            let {useBackBuffer: t, antialias: r} = Gp(Gp({}, tg.defaultOptions), e);
            this.useBackBuffer = t,
            this._antialias = r,
            this._renderer.context.supports.msaa || (Ti("antialiasing, is not supported on when using the back buffer"),
            this._antialias = !1),
            this._state = Nt.for2d();
            let s = new wi({
                vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
                fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
                name: "big-triangle"
            });
            this._bigTriangleShader = new At({
                glProgram: s,
                resources: {
                    uTexture: Z.WHITE.source
                }
            })
        }
        renderStart(e) {
            let t = this._renderer.renderTarget.getRenderTarget(e.target);
            if (this._useBackBufferThisRender = this.useBackBuffer && !!t.isRoot,
            this._useBackBufferThisRender) {
                let r = this._renderer.renderTarget.getRenderTarget(e.target);
                this._targetTexture = r.colorTexture,
                e.target = this._getBackBufferTexture(r.colorTexture)
            }
        }
        renderEnd() {
            this._presentBackBuffer()
        }
        _presentBackBuffer() {
            let e = this._renderer;
            e.renderTarget.finishRenderPass(),
            this._useBackBufferThisRender && (e.renderTarget.bind(this._targetTexture, !1),
            this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source,
            e.encoder.draw({
                geometry: V8,
                shader: this._bigTriangleShader,
                state: this._state
            }))
        }
        _getBackBufferTexture(e) {
            return this._backBufferTexture = this._backBufferTexture || new Z({
                source: new He({
                    width: e.width,
                    height: e.height,
                    resolution: e._resolution,
                    antialias: this._antialias
                })
            }),
            this._backBufferTexture.source.resize(e.width, e.height, e._resolution),
            this._backBufferTexture
        }
        destroy() {
            this._backBufferTexture && (this._backBufferTexture.destroy(),
            this._backBufferTexture = null)
        }
    }
    ;
    Ql.extension = {
        type: [B.WebGLSystem],
        name: "backBuffer",
        priority: 1
    },
    Ql.defaultOptions = {
        useBackBuffer: !1
    };
    var W8 = Ql
      , wa = class {
        constructor(e) {
            this._colorMaskCache = 15,
            this._renderer = e
        }
        setMask(e) {
            this._colorMaskCache !== e && (this._colorMaskCache = e,
            this._renderer.gl.colorMask(!!(e & 8), !!(e & 4), !!(e & 2), !!(e & 1)))
        }
    }
    ;
    wa.extension = {
        type: [B.WebGLSystem],
        name: "colorMask"
    };
    var Aa = class {
        constructor(e) {
            this.commandFinished = Promise.resolve(),
            this._renderer = e
        }
        setGeometry(e, t) {
            this._renderer.geometry.bind(e, t.glProgram)
        }
        finishRenderPass() {}
        draw(e) {
            let t = this._renderer
              , {geometry: r, shader: s, state: n, skipSync: a, topology: c, size: l, start: u, instanceCount: d} = e;
            t.shader.bind(s, a),
            t.geometry.bind(r, t.shader._activeProgram),
            n && t.state.set(n),
            t.geometry.draw(c, l, u, d ?? r.instanceCount)
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    Aa.extension = {
        type: [B.WebGLSystem],
        name: "encoder"
    };
    var Ea = class {
        constructor(e) {
            this._renderer = e
        }
        contextChange() {
            let e = this._renderer.gl;
            this.maxTextures = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
            this.maxBatchableTextures = m0(this.maxTextures, e);
            let t = this._renderer.context.webGLVersion === 2;
            this.maxUniformBindings = t ? e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS) : 0
        }
        destroy() {}
    }
    ;
    Ea.extension = {
        type: [B.WebGLSystem],
        name: "limits"
    };
    var Jl = class {
        constructor() {
            this.width = -1,
            this.height = -1,
            this.msaa = !1,
            this.msaaRenderBuffer = []
        }
    }
      , Ci = [];
    Ci[Je.NONE] = void 0,
    Ci[Je.DISABLED] = {
        stencilWriteMask: 0,
        stencilReadMask: 0
    },
    Ci[Je.RENDERING_MASK_ADD] = {
        stencilFront: {
            compare: "equal",
            passOp: "increment-clamp"
        },
        stencilBack: {
            compare: "equal",
            passOp: "increment-clamp"
        }
    },
    Ci[Je.RENDERING_MASK_REMOVE] = {
        stencilFront: {
            compare: "equal",
            passOp: "decrement-clamp"
        },
        stencilBack: {
            compare: "equal",
            passOp: "decrement-clamp"
        }
    },
    Ci[Je.MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: {
            compare: "equal",
            passOp: "keep"
        },
        stencilBack: {
            compare: "equal",
            passOp: "keep"
        }
    },
    Ci[Je.INVERSE_MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: {
            compare: "not-equal",
            passOp: "keep"
        },
        stencilBack: {
            compare: "not-equal",
            passOp: "keep"
        }
    };
    var Pa = class {
        constructor(e) {
            this._stencilCache = {
                enabled: !1,
                stencilReference: 0,
                stencilMode: Je.NONE
            },
            this._renderTargetStencilState = Object.create(null),
            e.renderTarget.onRenderTargetChange.add(this)
        }
        contextChange(e) {
            this._gl = e,
            this._comparisonFuncMapping = {
                always: e.ALWAYS,
                never: e.NEVER,
                equal: e.EQUAL,
                "not-equal": e.NOTEQUAL,
                less: e.LESS,
                "less-equal": e.LEQUAL,
                greater: e.GREATER,
                "greater-equal": e.GEQUAL
            },
            this._stencilOpsMapping = {
                keep: e.KEEP,
                zero: e.ZERO,
                replace: e.REPLACE,
                invert: e.INVERT,
                "increment-clamp": e.INCR,
                "decrement-clamp": e.DECR,
                "increment-wrap": e.INCR_WRAP,
                "decrement-wrap": e.DECR_WRAP
            },
            this.resetState()
        }
        onRenderTargetChange(e) {
            if (this._activeRenderTarget === e)
                return;
            this._activeRenderTarget = e;
            let t = this._renderTargetStencilState[e.uid];
            t || (t = this._renderTargetStencilState[e.uid] = {
                stencilMode: Je.DISABLED,
                stencilReference: 0
            }),
            this.setStencilMode(t.stencilMode, t.stencilReference)
        }
        resetState() {
            this._stencilCache.enabled = !1,
            this._stencilCache.stencilMode = Je.NONE,
            this._stencilCache.stencilReference = 0
        }
        setStencilMode(e, t) {
            let r = this._renderTargetStencilState[this._activeRenderTarget.uid]
              , s = this._gl
              , n = Ci[e]
              , a = this._stencilCache;
            if (r.stencilMode = e,
            r.stencilReference = t,
            e === Je.DISABLED) {
                this._stencilCache.enabled && (this._stencilCache.enabled = !1,
                s.disable(s.STENCIL_TEST));
                return
            }
            this._stencilCache.enabled || (this._stencilCache.enabled = !0,
            s.enable(s.STENCIL_TEST)),
            (e !== a.stencilMode || a.stencilReference !== t) && (a.stencilMode = e,
            a.stencilReference = t,
            s.stencilFunc(this._comparisonFuncMapping[n.stencilBack.compare], t, 255),
            s.stencilOp(s.KEEP, s.KEEP, this._stencilOpsMapping[n.stencilBack.passOp]))
        }
    }
    ;
    Pa.extension = {
        type: [B.WebGLSystem],
        name: "stencil"
    };
    var Ra = class {
        constructor(e) {
            this._syncFunctionHash = Object.create(null),
            this._adaptor = e,
            this._systemCheck()
        }
        _systemCheck() {
            if (!sm())
                throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")
        }
        ensureUniformGroup(e) {
            let t = this.getUniformGroupData(e);
            e.buffer || (e.buffer = new gt({
                data: new Float32Array(t.layout.size / 4),
                usage: Ae.UNIFORM | Ae.COPY_DST
            }))
        }
        getUniformGroupData(e) {
            return this._syncFunctionHash[e._signature] || this._initUniformGroup(e)
        }
        _initUniformGroup(e) {
            let t = e._signature
              , r = this._syncFunctionHash[t];
            if (!r) {
                let s = Object.keys(e.uniformStructures).map(c => e.uniformStructures[c])
                  , n = this._adaptor.createUboElements(s)
                  , a = this._generateUboSync(n.uboElements);
                r = this._syncFunctionHash[t] = {
                    layout: n,
                    syncFunction: a
                }
            }
            return this._syncFunctionHash[t]
        }
        _generateUboSync(e) {
            return this._adaptor.generateUboSync(e)
        }
        syncUniformGroup(e, t, r) {
            let s = this.getUniformGroupData(e);
            e.buffer || (e.buffer = new gt({
                data: new Float32Array(s.layout.size / 4),
                usage: Ae.UNIFORM | Ae.COPY_DST
            }));
            let n = null;
            return t || (t = e.buffer.data,
            n = e.buffer.dataInt32),
            r || (r = 0),
            s.syncFunction(e.uniforms, t, n, r),
            !0
        }
        updateUniformGroup(e) {
            if (e.isStatic && !e._dirtyId)
                return !1;
            e._dirtyId = 0;
            let t = this.syncUniformGroup(e);
            return e.buffer.update(),
            t
        }
        destroy() {
            this._syncFunctionHash = null
        }
    }
      , ig = {
        f32: 4,
        i32: 4,
        "vec2<f32>": 8,
        "vec3<f32>": 12,
        "vec4<f32>": 16,
        "vec2<i32>": 8,
        "vec3<i32>": 12,
        "vec4<i32>": 16,
        "mat2x2<f32>": 32,
        "mat3x3<f32>": 48,
        "mat4x4<f32>": 64
    };
    function Y8(i) {
        let e = i.map(n => ({
            data: n,
            offset: 0,
            size: 0
        }))
          , t = 16
          , r = 0
          , s = 0;
        for (let n = 0; n < e.length; n++) {
            let a = e[n];
            if (r = ig[a.data.type],
            !r)
                throw new Error(`Unknown type ${a.data.type}`);
            a.data.size > 1 && (r = Math.max(r, t) * a.data.size);
            let c = r === 12 ? 16 : r;
            a.size = r;
            let l = s % t;
            l > 0 && t - l < c ? s += (t - l) % 16 : s += (r - l % r) % r,
            a.offset = s,
            s += r
        }
        return s = Math.ceil(s / 16) * 16,
        {
            uboElements: e,
            size: s
        }
    }
    var Ji = [{
        type: "mat3x3<f32>",
        test: i => i.value.a !== void 0,
        ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
        uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
    }, {
        type: "vec4<f32>",
        test: i => i.type === "vec4<f32>" && i.size === 1 && i.value.width !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
    }, {
        type: "vec2<f32>",
        test: i => i.type === "vec2<f32>" && i.size === 1 && i.value.x !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
    }, {
        type: "vec4<f32>",
        test: i => i.type === "vec4<f32>" && i.size === 1 && i.value.red !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
    }, {
        type: "vec3<f32>",
        test: i => i.type === "vec3<f32>" && i.size === 1 && i.value.red !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
    }];
    function rg(i, e, t, r) {
        let s = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `]
          , n = 0;
        for (let c = 0; c < i.length; c++) {
            let l = i[c]
              , u = l.data.name
              , d = !1
              , f = 0;
            for (let b = 0; b < Ji.length; b++)
                if (Ji[b].test(l.data)) {
                    f = l.offset / 4,
                    s.push(`name = "${u}";`, `offset += ${f - n};`, Ji[b][e] || Ji[b].ubo),
                    d = !0;
                    break
                }
            if (!d)
                if (l.data.size > 1)
                    f = l.offset / 4,
                    s.push(t(l, f - n));
                else {
                    let b = r[l.data.type];
                    f = l.offset / 4,
                    s.push(`
                    v = uv.${u};
                    offset += ${f - n};
                    ${b};
                `)
                }
            n = f
        }
        let a = s.join(`
`);
        return new Function("uv","data","dataInt32","offset",a)
    }
    var $8 = Object.defineProperty
      , K8 = Object.defineProperties
      , q8 = Object.getOwnPropertyDescriptors
      , Bp = Object.getOwnPropertySymbols
      , Z8 = Object.prototype.hasOwnProperty
      , Q8 = Object.prototype.propertyIsEnumerable
      , Fp = (i, e, t) => e in i ? $8(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , J8 = (i, e) => {
        for (var t in e || (e = {}))
            Z8.call(e, t) && Fp(i, t, e[t]);
        if (Bp)
            for (var t of Bp(e))
                Q8.call(e, t) && Fp(i, t, e[t]);
        return i
    }
      , e6 = (i, e) => K8(i, q8(e));
    function dr(i, e) {
        return `
        for (let i = 0; i < ${i * e}; i++) {
            data[offset + (((i / ${i})|0) * 4) + (i % ${i})] = v[i];
        }
    `
    }
    var sg = {
        f32: `
        data[offset] = v;`,
        i32: `
        dataInt32[offset] = v;`,
        "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
        "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
        "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
        "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
        "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
        "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
        "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
        "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
        "mat3x2<f32>": dr(3, 2),
        "mat4x2<f32>": dr(4, 2),
        "mat2x3<f32>": dr(2, 3),
        "mat4x3<f32>": dr(4, 3),
        "mat2x4<f32>": dr(2, 4),
        "mat3x4<f32>": dr(3, 4)
    }
      , t6 = e6(J8({}, sg), {
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
    });
    function i6(i, e) {
        let t = Math.max(ig[i.data.type] / 16, 1)
          , r = i.data.value.length / i.data.size
          , s = (4 - r % 4) % 4
          , n = i.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
        return `
        v = uv.${i.data.name};
        offset += ${e};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${i.data.size * t}; i++)
        {
            for(var j = 0; j < ${r}; j++)
            {
                ${n}[arrayOffset++] = v[t++];
            }
            ${s !== 0 ? `arrayOffset += ${s};` : ""}
        }
    `
    }
    function r6(i) {
        return rg(i, "uboStd40", i6, sg)
    }
    var Ma = class extends Ra {
        constructor() {
            super({
                createUboElements: Y8,
                generateUboSync: r6
            })
        }
    }
    ;
    Ma.extension = {
        type: [B.WebGLSystem],
        name: "ubo"
    };
    var eh = class {
        constructor() {
            this._clearColorCache = [0, 0, 0, 0],
            this._viewPortCache = new Re
        }
        init(e, t) {
            this._renderer = e,
            this._renderTargetSystem = t,
            e.runners.contextChange.add(this)
        }
        contextChange() {
            this._clearColorCache = [0, 0, 0, 0],
            this._viewPortCache = new Re
        }
        copyToTexture(e, t, r, s, n) {
            let a = this._renderTargetSystem
              , c = this._renderer
              , l = a.getGpuRenderTarget(e)
              , u = c.gl;
            return this.finishRenderPass(e),
            u.bindFramebuffer(u.FRAMEBUFFER, l.resolveTargetFramebuffer),
            c.texture.bind(t, 0),
            u.copyTexSubImage2D(u.TEXTURE_2D, 0, n.x, n.y, r.x, r.y, s.width, s.height),
            t
        }
        startRenderPass(e, t=!0, r, s) {
            let n = this._renderTargetSystem
              , a = e.colorTexture
              , c = n.getGpuRenderTarget(e)
              , l = s.y;
            e.isRoot && (l = a.pixelHeight - s.height),
            e.colorTextures.forEach(f => {
                this._renderer.texture.unbind(f)
            }
            );
            let u = this._renderer.gl;
            u.bindFramebuffer(u.FRAMEBUFFER, c.framebuffer);
            let d = this._viewPortCache;
            (d.x !== s.x || d.y !== l || d.width !== s.width || d.height !== s.height) && (d.x = s.x,
            d.y = l,
            d.width = s.width,
            d.height = s.height,
            u.viewport(s.x, l, s.width, s.height)),
            !c.depthStencilRenderBuffer && (e.stencil || e.depth) && this._initStencil(c),
            this.clear(e, t, r)
        }
        finishRenderPass(e) {
            let t = this._renderTargetSystem.getGpuRenderTarget(e);
            if (!t.msaa)
                return;
            let r = this._renderer.gl;
            r.bindFramebuffer(r.FRAMEBUFFER, t.resolveTargetFramebuffer),
            r.bindFramebuffer(r.READ_FRAMEBUFFER, t.framebuffer),
            r.blitFramebuffer(0, 0, t.width, t.height, 0, 0, t.width, t.height, r.COLOR_BUFFER_BIT, r.NEAREST),
            r.bindFramebuffer(r.FRAMEBUFFER, t.framebuffer)
        }
        initGpuRenderTarget(e) {
            let t = this._renderer.gl
              , r = new Jl;
            return e.colorTexture instanceof Zt ? (this._renderer.context.ensureCanvasSize(e.colorTexture.resource),
            r.framebuffer = null,
            r) : (this._initColor(e, r),
            t.bindFramebuffer(t.FRAMEBUFFER, null),
            r)
        }
        destroyGpuRenderTarget(e) {
            let t = this._renderer.gl;
            e.framebuffer && (t.deleteFramebuffer(e.framebuffer),
            e.framebuffer = null),
            e.resolveTargetFramebuffer && (t.deleteFramebuffer(e.resolveTargetFramebuffer),
            e.resolveTargetFramebuffer = null),
            e.depthStencilRenderBuffer && (t.deleteRenderbuffer(e.depthStencilRenderBuffer),
            e.depthStencilRenderBuffer = null),
            e.msaaRenderBuffer.forEach(r => {
                t.deleteRenderbuffer(r)
            }
            ),
            e.msaaRenderBuffer = null
        }
        clear(e, t, r) {
            if (!t)
                return;
            let s = this._renderTargetSystem;
            typeof t == "boolean" && (t = t ? It.ALL : It.NONE);
            let n = this._renderer.gl;
            if (t & It.COLOR) {
                r != null || (r = s.defaultClearColor);
                let a = this._clearColorCache
                  , c = r;
                (a[0] !== c[0] || a[1] !== c[1] || a[2] !== c[2] || a[3] !== c[3]) && (a[0] = c[0],
                a[1] = c[1],
                a[2] = c[2],
                a[3] = c[3],
                n.clearColor(c[0], c[1], c[2], c[3]))
            }
            n.clear(t)
        }
        resizeGpuRenderTarget(e) {
            if (e.isRoot)
                return;
            let t = this._renderTargetSystem.getGpuRenderTarget(e);
            this._resizeColor(e, t),
            (e.stencil || e.depth) && this._resizeStencil(t)
        }
        _initColor(e, t) {
            let r = this._renderer
              , s = r.gl
              , n = s.createFramebuffer();
            if (t.resolveTargetFramebuffer = n,
            s.bindFramebuffer(s.FRAMEBUFFER, n),
            t.width = e.colorTexture.source.pixelWidth,
            t.height = e.colorTexture.source.pixelHeight,
            e.colorTextures.forEach( (a, c) => {
                let l = a.source;
                l.antialias && (r.context.supports.msaa ? t.msaa = !0 : Ti("[RenderTexture] Antialiasing on textures is not supported in WebGL1")),
                r.texture.bindSource(l, 0);
                let u = r.texture.getGlSource(l).texture;
                s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + c, 3553, u, 0)
            }
            ),
            t.msaa) {
                let a = s.createFramebuffer();
                t.framebuffer = a,
                s.bindFramebuffer(s.FRAMEBUFFER, a),
                e.colorTextures.forEach( (c, l) => {
                    let u = s.createRenderbuffer();
                    t.msaaRenderBuffer[l] = u
                }
                )
            } else
                t.framebuffer = n;
            this._resizeColor(e, t)
        }
        _resizeColor(e, t) {
            let r = e.colorTexture.source;
            if (t.width = r.pixelWidth,
            t.height = r.pixelHeight,
            e.colorTextures.forEach( (s, n) => {
                n !== 0 && s.source.resize(r.width, r.height, r._resolution)
            }
            ),
            t.msaa) {
                let s = this._renderer
                  , n = s.gl
                  , a = t.framebuffer;
                n.bindFramebuffer(n.FRAMEBUFFER, a),
                e.colorTextures.forEach( (c, l) => {
                    let u = c.source;
                    s.texture.bindSource(u, 0);
                    let d = s.texture.getGlSource(u).internalFormat
                      , f = t.msaaRenderBuffer[l];
                    n.bindRenderbuffer(n.RENDERBUFFER, f),
                    n.renderbufferStorageMultisample(n.RENDERBUFFER, 4, d, u.pixelWidth, u.pixelHeight),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + l, n.RENDERBUFFER, f)
                }
                )
            }
        }
        _initStencil(e) {
            if (e.framebuffer === null)
                return;
            let t = this._renderer.gl
              , r = t.createRenderbuffer();
            e.depthStencilRenderBuffer = r,
            t.bindRenderbuffer(t.RENDERBUFFER, r),
            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, r),
            this._resizeStencil(e)
        }
        _resizeStencil(e) {
            let t = this._renderer.gl;
            t.bindRenderbuffer(t.RENDERBUFFER, e.depthStencilRenderBuffer),
            e.msaa ? t.renderbufferStorageMultisample(t.RENDERBUFFER, 4, t.DEPTH24_STENCIL8, e.width, e.height) : t.renderbufferStorage(t.RENDERBUFFER, this._renderer.context.webGLVersion === 2 ? t.DEPTH24_STENCIL8 : t.DEPTH_STENCIL, e.width, e.height)
        }
        prerender(e) {
            let t = e.colorTexture.resource;
            this._renderer.context.multiView && Zt.test(t) && this._renderer.context.ensureCanvasSize(t)
        }
        postrender(e) {
            if (this._renderer.context.multiView && Zt.test(e.colorTexture.resource)) {
                let t = this._renderer.context.canvas
                  , r = e.colorTexture;
                r.context2D.drawImage(t, 0, r.pixelHeight - t.height)
            }
        }
    }
    ;
    function s6(i, e, t, r, s, n) {
        let a = n ? 1 : -1;
        return i.identity(),
        i.a = 1 / r * 2,
        i.d = a * (1 / s * 2),
        i.tx = -1 - e * i.a,
        i.ty = -a - t * i.d,
        i
    }
    var n6 = Object.defineProperty
      , Dp = Object.getOwnPropertySymbols
      , a6 = Object.prototype.hasOwnProperty
      , o6 = Object.prototype.propertyIsEnumerable
      , kp = (i, e, t) => e in i ? n6(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , c6 = (i, e) => {
        for (var t in e || (e = {}))
            a6.call(e, t) && kp(i, t, e[t]);
        if (Dp)
            for (var t of Dp(e))
                o6.call(e, t) && kp(i, t, e[t]);
        return i
    }
      , mr = new Map;
    Cr.register(mr);
    function ng(i, e) {
        if (!mr.has(i)) {
            let t = new Z({
                source: new Zt(c6({
                    resource: i
                }, e))
            })
              , r = () => {
                mr.get(i) === t && mr.delete(i)
            }
            ;
            t.once("destroy", r),
            t.source.once("destroy", r),
            mr.set(i, t)
        }
        return mr.get(i)
    }
    function l6(i) {
        let e = i.colorTexture.source.resource;
        return globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement && document.body.contains(e)
    }
    var h6 = Object.defineProperty
      , Up = Object.getOwnPropertySymbols
      , u6 = Object.prototype.hasOwnProperty
      , d6 = Object.prototype.propertyIsEnumerable
      , Lp = (i, e, t) => e in i ? h6(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Np = (i, e) => {
        for (var t in e || (e = {}))
            u6.call(e, t) && Lp(i, t, e[t]);
        if (Up)
            for (var t of Up(e))
                d6.call(e, t) && Lp(i, t, e[t]);
        return i
    }
      , ag = class og {
        constructor(e={}) {
            if (this.uid = Xe("renderTarget"),
            this.colorTextures = [],
            this.dirtyId = 0,
            this.isRoot = !1,
            this._size = new Float32Array(2),
            this._managedColorTextures = !1,
            e = Np(Np({}, og.defaultOptions), e),
            this.stencil = e.stencil,
            this.depth = e.depth,
            this.isRoot = e.isRoot,
            typeof e.colorTextures == "number") {
                this._managedColorTextures = !0;
                for (let t = 0; t < e.colorTextures; t++)
                    this.colorTextures.push(new He({
                        width: e.width,
                        height: e.height,
                        resolution: e.resolution,
                        antialias: e.antialias
                    }))
            } else {
                this.colorTextures = [...e.colorTextures.map(r => r.source)];
                let t = this.colorTexture.source;
                this.resize(t.width, t.height, t._resolution)
            }
            this.colorTexture.source.on("resize", this.onSourceResize, this),
            (e.depthStencilTexture || this.stencil) && (e.depthStencilTexture instanceof Z || e.depthStencilTexture instanceof He ? this.depthStencilTexture = e.depthStencilTexture.source : this.ensureDepthStencilTexture())
        }
        get size() {
            let e = this._size;
            return e[0] = this.pixelWidth,
            e[1] = this.pixelHeight,
            e
        }
        get width() {
            return this.colorTexture.source.width
        }
        get height() {
            return this.colorTexture.source.height
        }
        get pixelWidth() {
            return this.colorTexture.source.pixelWidth
        }
        get pixelHeight() {
            return this.colorTexture.source.pixelHeight
        }
        get resolution() {
            return this.colorTexture.source._resolution
        }
        get colorTexture() {
            return this.colorTextures[0]
        }
        onSourceResize(e) {
            this.resize(e.width, e.height, e._resolution, !0)
        }
        ensureDepthStencilTexture() {
            this.depthStencilTexture || (this.depthStencilTexture = new He({
                width: this.width,
                height: this.height,
                resolution: this.resolution,
                format: "depth24plus-stencil8",
                autoGenerateMipmaps: !1,
                antialias: !1,
                mipLevelCount: 1
            }))
        }
        resize(e, t, r=this.resolution, s=!1) {
            this.dirtyId++,
            this.colorTextures.forEach( (n, a) => {
                s && a === 0 || n.source.resize(e, t, r)
            }
            ),
            this.depthStencilTexture && this.depthStencilTexture.source.resize(e, t, r)
        }
        destroy() {
            this.colorTexture.source.off("resize", this.onSourceResize, this),
            this._managedColorTextures && this.colorTextures.forEach(e => {
                e.destroy()
            }
            ),
            this.depthStencilTexture && (this.depthStencilTexture.destroy(),
            delete this.depthStencilTexture)
        }
    }
    ;
    ag.defaultOptions = {
        width: 0,
        height: 0,
        resolution: 1,
        colorTextures: 1,
        stencil: !1,
        depth: !1,
        antialias: !1,
        isRoot: !1
    };
    var th = ag
      , Ca = class {
        constructor(e) {
            this.rootViewPort = new Re,
            this.viewport = new Re,
            this.onRenderTargetChange = new ea("onRenderTargetChange"),
            this.projectionMatrix = new ce,
            this.defaultClearColor = [0, 0, 0, 0],
            this._renderSurfaceToRenderTargetHash = new Map,
            this._gpuRenderTargetHash = Object.create(null),
            this._renderTargetStack = [],
            this._renderer = e,
            e.renderableGC.addManagedHash(this, "_gpuRenderTargetHash")
        }
        finishRenderPass() {
            this.adaptor.finishRenderPass(this.renderTarget)
        }
        renderStart({target: e, clear: t, clearColor: r, frame: s}) {
            var n, a;
            this._renderTargetStack.length = 0,
            this.push(e, t, r, s),
            this.rootViewPort.copyFrom(this.viewport),
            this.rootRenderTarget = this.renderTarget,
            this.renderingToScreen = l6(this.rootRenderTarget),
            (a = (n = this.adaptor).prerender) == null || a.call(n, this.rootRenderTarget)
        }
        postrender() {
            var e, t;
            (t = (e = this.adaptor).postrender) == null || t.call(e, this.rootRenderTarget)
        }
        bind(e, t=!0, r, s) {
            let n = this.getRenderTarget(e)
              , a = this.renderTarget !== n;
            this.renderTarget = n,
            this.renderSurface = e;
            let c = this.getGpuRenderTarget(n);
            (n.pixelWidth !== c.width || n.pixelHeight !== c.height) && (this.adaptor.resizeGpuRenderTarget(n),
            c.width = n.pixelWidth,
            c.height = n.pixelHeight);
            let l = n.colorTexture
              , u = this.viewport
              , d = l.pixelWidth
              , f = l.pixelHeight;
            if (!s && e instanceof Z && (s = e.frame),
            s) {
                let b = l._resolution;
                u.x = s.x * b + .5 | 0,
                u.y = s.y * b + .5 | 0,
                u.width = s.width * b + .5 | 0,
                u.height = s.height * b + .5 | 0
            } else
                u.x = 0,
                u.y = 0,
                u.width = d,
                u.height = f;
            return s6(this.projectionMatrix, 0, 0, u.width / l.resolution, u.height / l.resolution, !n.isRoot),
            this.adaptor.startRenderPass(n, t, r, u),
            a && this.onRenderTargetChange.emit(n),
            n
        }
        clear(e, t=It.ALL, r) {
            t && (e && (e = this.getRenderTarget(e)),
            this.adaptor.clear(e || this.renderTarget, t, r, this.viewport))
        }
        contextChange() {
            this._gpuRenderTargetHash = Object.create(null)
        }
        push(e, t=It.ALL, r, s) {
            let n = this.bind(e, t, r, s);
            return this._renderTargetStack.push({
                renderTarget: n,
                frame: s
            }),
            n
        }
        pop() {
            this._renderTargetStack.pop();
            let e = this._renderTargetStack[this._renderTargetStack.length - 1];
            this.bind(e.renderTarget, !1, null, e.frame)
        }
        getRenderTarget(e) {
            var t;
            return e.isTexture && (e = e.source),
            (t = this._renderSurfaceToRenderTargetHash.get(e)) != null ? t : this._initRenderTarget(e)
        }
        copyToTexture(e, t, r, s, n) {
            r.x < 0 && (s.width += r.x,
            n.x -= r.x,
            r.x = 0),
            r.y < 0 && (s.height += r.y,
            n.y -= r.y,
            r.y = 0);
            let {pixelWidth: a, pixelHeight: c} = e;
            return s.width = Math.min(s.width, a - r.x),
            s.height = Math.min(s.height, c - r.y),
            this.adaptor.copyToTexture(e, t, r, s, n)
        }
        ensureDepthStencil() {
            this.renderTarget.stencil || (this.renderTarget.stencil = !0,
            this.adaptor.startRenderPass(this.renderTarget, !1, null, this.viewport))
        }
        destroy() {
            this._renderer = null,
            this._renderSurfaceToRenderTargetHash.forEach( (e, t) => {
                e !== t && e.destroy()
            }
            ),
            this._renderSurfaceToRenderTargetHash.clear(),
            this._gpuRenderTargetHash = Object.create(null)
        }
        _initRenderTarget(e) {
            let t = null;
            return Zt.test(e) && (e = ng(e).source),
            e instanceof th ? t = e : e instanceof He && (t = new th({
                colorTextures: [e]
            }),
            e.source instanceof Zt && (t.isRoot = !0),
            e.once("destroy", () => {
                t.destroy(),
                this._renderSurfaceToRenderTargetHash.delete(e);
                let r = this._gpuRenderTargetHash[t.uid];
                r && (this._gpuRenderTargetHash[t.uid] = null,
                this.adaptor.destroyGpuRenderTarget(r))
            }
            )),
            this._renderSurfaceToRenderTargetHash.set(e, t),
            t
        }
        getGpuRenderTarget(e) {
            return this._gpuRenderTargetHash[e.uid] || (this._gpuRenderTargetHash[e.uid] = this.adaptor.initGpuRenderTarget(e))
        }
        resetState() {
            this.renderTarget = null,
            this.renderSurface = null
        }
    }
      , Oa = class extends Ca {
        constructor(e) {
            super(e),
            this.adaptor = new eh,
            this.adaptor.init(e, this)
        }
    }
    ;
    Oa.extension = {
        type: [B.WebGLSystem],
        name: "renderTarget"
    };
    var ws = class extends Ft {
        constructor({buffer: e, offset: t, size: r}) {
            super(),
            this.uid = Xe("buffer"),
            this._resourceType = "bufferResource",
            this._touched = 0,
            this._resourceId = Xe("resource"),
            this._bufferResource = !0,
            this.destroyed = !1,
            this.buffer = e,
            this.offset = t | 0,
            this.size = r,
            this.buffer.on("change", this.onBufferChange, this)
        }
        onBufferChange() {
            this._resourceId = Xe("resource"),
            this.emit("change", this)
        }
        destroy(e=!1) {
            this.destroyed = !0,
            e && this.buffer.destroy(),
            this.emit("change", this),
            this.buffer = null
        }
    }
    ;
    function f6(i, e) {
        let t = []
          , r = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `]
          , s = !1
          , n = 0
          , a = e._getProgramData(i.glProgram);
        for (let l in i.groups) {
            let u = i.groups[l];
            t.push(`
            resources = g[${l}].resources;
        `);
            for (let d in u.resources) {
                let f = u.resources[d];
                if (f instanceof ct)
                    if (f.ubo) {
                        let b = i._uniformBindMap[l][Number(d)];
                        t.push(`
                        sS.bindUniformBlock(
                            resources[${d}],
                            '${b}',
                            ${i.glProgram._uniformBlockData[b].index}
                        );
                    `)
                    } else
                        t.push(`
                        ugS.updateUniformGroup(resources[${d}], p, sD);
                    `);
                else if (f instanceof ws) {
                    let b = i._uniformBindMap[l][Number(d)];
                    t.push(`
                    sS.bindUniformBlock(
                        resources[${d}],
                        '${b}',
                        ${i.glProgram._uniformBlockData[b].index}
                    );
                `)
                } else if (f instanceof He) {
                    let b = i._uniformBindMap[l][d]
                      , m = a.uniformData[b];
                    m && (s || (s = !0,
                    r.push(`
                        var tS = r.texture;
                        `)),
                    e._gl.uniform1i(m.location, n),
                    t.push(`
                        tS.bind(resources[${d}], ${n});
                    `),
                    n++)
                }
            }
        }
        let c = [...r, ...t].join(`
`);
        return new Function("r","s","sD",c)
    }
    var ih = class {
        constructor(e, t) {
            this.program = e,
            this.uniformData = t,
            this.uniformGroups = {},
            this.uniformDirtyGroups = {},
            this.uniformBlockBindings = {}
        }
        destroy() {
            this.uniformData = null,
            this.uniformGroups = null,
            this.uniformDirtyGroups = null,
            this.uniformBlockBindings = null,
            this.program = null
        }
    }
    ;
    function Xp(i, e, t) {
        let r = i.createShader(e);
        return i.shaderSource(r, t),
        i.compileShader(r),
        r
    }
    function vc(i) {
        let e = new Array(i);
        for (let t = 0; t < e.length; t++)
            e[t] = !1;
        return e
    }
    function cg(i, e) {
        switch (i) {
        case "float":
            return 0;
        case "vec2":
            return new Float32Array(2 * e);
        case "vec3":
            return new Float32Array(3 * e);
        case "vec4":
            return new Float32Array(4 * e);
        case "int":
        case "uint":
        case "sampler2D":
        case "sampler2DArray":
            return 0;
        case "ivec2":
            return new Int32Array(2 * e);
        case "ivec3":
            return new Int32Array(3 * e);
        case "ivec4":
            return new Int32Array(4 * e);
        case "uvec2":
            return new Uint32Array(2 * e);
        case "uvec3":
            return new Uint32Array(3 * e);
        case "uvec4":
            return new Uint32Array(4 * e);
        case "bool":
            return !1;
        case "bvec2":
            return vc(2 * e);
        case "bvec3":
            return vc(3 * e);
        case "bvec4":
            return vc(4 * e);
        case "mat2":
            return new Float32Array([1, 0, 0, 1]);
        case "mat3":
            return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        case "mat4":
            return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
        }
        return null
    }
    var sn = null
      , jp = {
        FLOAT: "float",
        FLOAT_VEC2: "vec2",
        FLOAT_VEC3: "vec3",
        FLOAT_VEC4: "vec4",
        INT: "int",
        INT_VEC2: "ivec2",
        INT_VEC3: "ivec3",
        INT_VEC4: "ivec4",
        UNSIGNED_INT: "uint",
        UNSIGNED_INT_VEC2: "uvec2",
        UNSIGNED_INT_VEC3: "uvec3",
        UNSIGNED_INT_VEC4: "uvec4",
        BOOL: "bool",
        BOOL_VEC2: "bvec2",
        BOOL_VEC3: "bvec3",
        BOOL_VEC4: "bvec4",
        FLOAT_MAT2: "mat2",
        FLOAT_MAT3: "mat3",
        FLOAT_MAT4: "mat4",
        SAMPLER_2D: "sampler2D",
        INT_SAMPLER_2D: "sampler2D",
        UNSIGNED_INT_SAMPLER_2D: "sampler2D",
        SAMPLER_CUBE: "samplerCube",
        INT_SAMPLER_CUBE: "samplerCube",
        UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
        SAMPLER_2D_ARRAY: "sampler2DArray",
        INT_SAMPLER_2D_ARRAY: "sampler2DArray",
        UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
    }
      , p6 = {
        float: "float32",
        vec2: "float32x2",
        vec3: "float32x3",
        vec4: "float32x4",
        int: "sint32",
        ivec2: "sint32x2",
        ivec3: "sint32x3",
        ivec4: "sint32x4",
        uint: "uint32",
        uvec2: "uint32x2",
        uvec3: "uint32x3",
        uvec4: "uint32x4",
        bool: "uint32",
        bvec2: "uint32x2",
        bvec3: "uint32x3",
        bvec4: "uint32x4"
    };
    function lg(i, e) {
        if (!sn) {
            let t = Object.keys(jp);
            sn = {};
            for (let r = 0; r < t.length; ++r) {
                let s = t[r];
                sn[i[s]] = jp[s]
            }
        }
        return sn[e]
    }
    function b6(i, e) {
        let t = lg(i, e);
        return p6[t] || "float32"
    }
    function m6(i, e, t=!1) {
        let r = {}
          , s = e.getProgramParameter(i, e.ACTIVE_ATTRIBUTES);
        for (let a = 0; a < s; a++) {
            let c = e.getActiveAttrib(i, a);
            if (c.name.startsWith("gl_"))
                continue;
            let l = b6(e, c.type);
            r[c.name] = {
                location: 0,
                format: l,
                stride: Gi(l).stride,
                offset: 0,
                instance: !1,
                start: 0
            }
        }
        let n = Object.keys(r);
        if (t) {
            n.sort( (a, c) => a > c ? 1 : -1);
            for (let a = 0; a < n.length; a++)
                r[n[a]].location = a,
                e.bindAttribLocation(i, a, n[a]);
            e.linkProgram(i)
        } else
            for (let a = 0; a < n.length; a++)
                r[n[a]].location = e.getAttribLocation(i, n[a]);
        return r
    }
    function g6(i, e) {
        if (!e.ACTIVE_UNIFORM_BLOCKS)
            return {};
        let t = {}
          , r = e.getProgramParameter(i, e.ACTIVE_UNIFORM_BLOCKS);
        for (let s = 0; s < r; s++) {
            let n = e.getActiveUniformBlockName(i, s)
              , a = e.getUniformBlockIndex(i, n)
              , c = e.getActiveUniformBlockParameter(i, s, e.UNIFORM_BLOCK_DATA_SIZE);
            t[n] = {
                name: n,
                index: a,
                size: c
            }
        }
        return t
    }
    function _6(i, e) {
        let t = {}
          , r = e.getProgramParameter(i, e.ACTIVE_UNIFORMS);
        for (let s = 0; s < r; s++) {
            let n = e.getActiveUniform(i, s)
              , a = n.name.replace(/\[.*?\]$/, "")
              , c = !!n.name.match(/\[.*?\]$/)
              , l = lg(e, n.type);
            t[a] = {
                name: a,
                index: s,
                type: l,
                size: n.size,
                isArray: c,
                value: cg(l, n.size)
            }
        }
        return t
    }
    function Hp(i, e) {
        let t = i.getShaderSource(e).split(`
`).map( (u, d) => `${d}: ${u}`)
          , r = i.getShaderInfoLog(e)
          , s = r.split(`
`)
          , n = {}
          , a = s.map(u => parseFloat(u.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter(u => u && !n[u] ? (n[u] = !0,
        !0) : !1)
          , c = [""];
        a.forEach(u => {
            t[u - 1] = `%c${t[u - 1]}%c`,
            c.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px")
        }
        );
        let l = t.join(`
`);
        c[0] = l
    }
    function x6(i, e, t, r) {
        i.getProgramParameter(e, i.LINK_STATUS) || (i.getShaderParameter(t, i.COMPILE_STATUS) || Hp(i, t),
        i.getShaderParameter(r, i.COMPILE_STATUS) || Hp(i, r),
        i.getProgramInfoLog(e))
    }
    function y6(i, e) {
        let t = Xp(i, i.VERTEX_SHADER, e.vertex)
          , r = Xp(i, i.FRAGMENT_SHADER, e.fragment)
          , s = i.createProgram();
        i.attachShader(s, t),
        i.attachShader(s, r);
        let n = e.transformFeedbackVaryings;
        n && (typeof i.transformFeedbackVaryings != "function" || i.transformFeedbackVaryings(s, n.names, n.bufferMode === "separate" ? i.SEPARATE_ATTRIBS : i.INTERLEAVED_ATTRIBS)),
        i.linkProgram(s),
        i.getProgramParameter(s, i.LINK_STATUS) || x6(i, s, t, r),
        e._attributeData = m6(s, i, !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertex)),
        e._uniformData = _6(s, i),
        e._uniformBlockData = g6(s, i),
        i.deleteShader(t),
        i.deleteShader(r);
        let a = {};
        for (let c in e._uniformData) {
            let l = e._uniformData[c];
            a[c] = {
                location: i.getUniformLocation(s, c),
                value: cg(l.type, l.size)
            }
        }
        return new ih(s,a)
    }
    var nn = {
        textureCount: 0,
        blockIndex: 0
    }
      , Ia = class {
        constructor(e) {
            this._activeProgram = null,
            this._programDataHash = Object.create(null),
            this._shaderSyncFunctions = Object.create(null),
            this._renderer = e,
            this._renderer.renderableGC.addManagedHash(this, "_programDataHash")
        }
        contextChange(e) {
            this._gl = e,
            this._programDataHash = Object.create(null),
            this._shaderSyncFunctions = Object.create(null),
            this._activeProgram = null
        }
        bind(e, t) {
            if (this._setProgram(e.glProgram),
            t)
                return;
            nn.textureCount = 0,
            nn.blockIndex = 0;
            let r = this._shaderSyncFunctions[e.glProgram._key];
            r || (r = this._shaderSyncFunctions[e.glProgram._key] = this._generateShaderSync(e, this)),
            this._renderer.buffer.nextBindBase(!!e.glProgram.transformFeedbackVaryings),
            r(this._renderer, e, nn)
        }
        updateUniformGroup(e) {
            this._renderer.uniformGroup.updateUniformGroup(e, this._activeProgram, nn)
        }
        bindUniformBlock(e, t, r=0) {
            let s = this._renderer.buffer
              , n = this._getProgramData(this._activeProgram)
              , a = e._bufferResource;
            a || this._renderer.ubo.updateUniformGroup(e);
            let c = e.buffer
              , l = s.updateBuffer(c)
              , u = s.freeLocationForBufferBase(l);
            if (a) {
                let {offset: f, size: b} = e;
                f === 0 && b === c.data.byteLength ? s.bindBufferBase(l, u) : s.bindBufferRange(l, u, f)
            } else
                s.getLastBindBaseLocation(l) !== u && s.bindBufferBase(l, u);
            let d = this._activeProgram._uniformBlockData[t].index;
            n.uniformBlockBindings[r] !== u && (n.uniformBlockBindings[r] = u,
            this._renderer.gl.uniformBlockBinding(n.program, d, u))
        }
        _setProgram(e) {
            if (this._activeProgram === e)
                return;
            this._activeProgram = e;
            let t = this._getProgramData(e);
            this._gl.useProgram(t.program)
        }
        _getProgramData(e) {
            return this._programDataHash[e._key] || this._createProgramData(e)
        }
        _createProgramData(e) {
            let t = e._key;
            return this._programDataHash[t] = y6(this._gl, e),
            this._programDataHash[t]
        }
        destroy() {
            for (let e of Object.keys(this._programDataHash))
                this._programDataHash[e].destroy(),
                this._programDataHash[e] = null;
            this._programDataHash = null,
            this._shaderSyncFunctions = null,
            this._activeProgram = null,
            this._renderer = null,
            this._gl = null
        }
        _generateShaderSync(e, t) {
            return f6(e, t)
        }
        resetState() {
            this._activeProgram = null
        }
    }
    ;
    Ia.extension = {
        type: [B.WebGLSystem],
        name: "shader"
    };
    var v6 = {
        f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
        "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
        "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
        "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
        i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
        "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
        "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
        "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
        bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
        "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
        "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);"
    }
      , T6 = {
        f32: "gl.uniform1fv(location, v);",
        "vec2<f32>": "gl.uniform2fv(location, v);",
        "vec3<f32>": "gl.uniform3fv(location, v);",
        "vec4<f32>": "gl.uniform4fv(location, v);",
        "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
        "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
        "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);",
        i32: "gl.uniform1iv(location, v);",
        "vec2<i32>": "gl.uniform2iv(location, v);",
        "vec3<i32>": "gl.uniform3iv(location, v);",
        "vec4<i32>": "gl.uniform4iv(location, v);",
        u32: "gl.uniform1iv(location, v);",
        "vec2<u32>": "gl.uniform2iv(location, v);",
        "vec3<u32>": "gl.uniform3iv(location, v);",
        "vec4<u32>": "gl.uniform4iv(location, v);",
        bool: "gl.uniform1iv(location, v);",
        "vec2<bool>": "gl.uniform2iv(location, v);",
        "vec3<bool>": "gl.uniform3iv(location, v);",
        "vec4<bool>": "gl.uniform4iv(location, v);"
    };
    function S6(i, e) {
        let t = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];
        for (let r in i.uniforms) {
            if (!e[r]) {
                i.uniforms[r]instanceof ct ? i.uniforms[r].ubo ? t.push(`
                        renderer.shader.bindUniformBlock(uv.${r}, "${r}");
                    `) : t.push(`
                        renderer.shader.updateUniformGroup(uv.${r});
                    `) : i.uniforms[r]instanceof ws && t.push(`
                        renderer.shader.bindBufferResource(uv.${r}, "${r}");
                    `);
                continue
            }
            let s = i.uniformStructures[r]
              , n = !1;
            for (let a = 0; a < Ji.length; a++) {
                let c = Ji[a];
                if (s.type === c.type && c.test(s)) {
                    t.push(`name = "${r}";`, Ji[a].uniform),
                    n = !0;
                    break
                }
            }
            if (!n) {
                let a = (s.size === 1 ? v6 : T6)[s.type].replace("location", `ud["${r}"].location`);
                t.push(`
            cu = ud["${r}"];
            cv = cu.value;
            v = uv["${r}"];
            ${a};`)
            }
        }
        return new Function("ud","uv","renderer","syncData",t.join(`
`))
    }
    var Ga = class {
        constructor(e) {
            this._cache = {},
            this._uniformGroupSyncHash = {},
            this._renderer = e,
            this.gl = null,
            this._cache = {}
        }
        contextChange(e) {
            this.gl = e
        }
        updateUniformGroup(e, t, r) {
            let s = this._renderer.shader._getProgramData(t);
            (!e.isStatic || e._dirtyId !== s.uniformDirtyGroups[e.uid]) && (s.uniformDirtyGroups[e.uid] = e._dirtyId,
            this._getUniformSyncFunction(e, t)(s.uniformData, e.uniforms, this._renderer, r))
        }
        _getUniformSyncFunction(e, t) {
            var r;
            return ((r = this._uniformGroupSyncHash[e._signature]) == null ? void 0 : r[t._key]) || this._createUniformSyncFunction(e, t)
        }
        _createUniformSyncFunction(e, t) {
            let r = this._uniformGroupSyncHash[e._signature] || (this._uniformGroupSyncHash[e._signature] = {})
              , s = this._getSignature(e, t._uniformData, "u");
            return this._cache[s] || (this._cache[s] = this._generateUniformsSync(e, t._uniformData)),
            r[t._key] = this._cache[s],
            r[t._key]
        }
        _generateUniformsSync(e, t) {
            return S6(e, t)
        }
        _getSignature(e, t, r) {
            let s = e.uniforms
              , n = [`${r}-`];
            for (let a in s)
                n.push(a),
                t[a] && n.push(t[a].type);
            return n.join("-")
        }
        destroy() {
            this._renderer = null,
            this._cache = null
        }
    }
    ;
    Ga.extension = {
        type: [B.WebGLSystem],
        name: "uniformGroup"
    };
    function w6(i) {
        let e = {};
        if (e.normal = [i.ONE, i.ONE_MINUS_SRC_ALPHA],
        e.add = [i.ONE, i.ONE],
        e.multiply = [i.DST_COLOR, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA],
        e.screen = [i.ONE, i.ONE_MINUS_SRC_COLOR, i.ONE, i.ONE_MINUS_SRC_ALPHA],
        e.none = [0, 0],
        e["normal-npm"] = [i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA],
        e["add-npm"] = [i.SRC_ALPHA, i.ONE, i.ONE, i.ONE],
        e["screen-npm"] = [i.SRC_ALPHA, i.ONE_MINUS_SRC_COLOR, i.ONE, i.ONE_MINUS_SRC_ALPHA],
        e.erase = [i.ZERO, i.ONE_MINUS_SRC_ALPHA],
        !(i instanceof xe.get().getWebGLRenderingContext()))
            e.min = [i.ONE, i.ONE, i.ONE, i.ONE, i.MIN, i.MIN],
            e.max = [i.ONE, i.ONE, i.ONE, i.ONE, i.MAX, i.MAX];
        else {
            let t = i.getExtension("EXT_blend_minmax");
            t && (e.min = [i.ONE, i.ONE, i.ONE, i.ONE, t.MIN_EXT, t.MIN_EXT],
            e.max = [i.ONE, i.ONE, i.ONE, i.ONE, t.MAX_EXT, t.MAX_EXT])
        }
        return e
    }
    var A6 = 0
      , E6 = 1
      , P6 = 2
      , R6 = 3
      , M6 = 4
      , C6 = 5
      , hg = class rh {
        constructor(e) {
            this._invertFrontFace = !1,
            this.gl = null,
            this.stateId = 0,
            this.polygonOffset = 0,
            this.blendMode = "none",
            this._blendEq = !1,
            this.map = [],
            this.map[A6] = this.setBlend,
            this.map[E6] = this.setOffset,
            this.map[P6] = this.setCullFace,
            this.map[R6] = this.setDepthTest,
            this.map[M6] = this.setFrontFace,
            this.map[C6] = this.setDepthMask,
            this.checks = [],
            this.defaultState = Nt.for2d(),
            e.renderTarget.onRenderTargetChange.add(this)
        }
        onRenderTargetChange(e) {
            this._invertFrontFace = !e.isRoot,
            this._cullFace ? this.setFrontFace(this._frontFace) : this._frontFaceDirty = !0
        }
        contextChange(e) {
            this.gl = e,
            this.blendModesMap = w6(e),
            this.resetState()
        }
        set(e) {
            if (e || (e = this.defaultState),
            this.stateId !== e.data) {
                let t = this.stateId ^ e.data
                  , r = 0;
                for (; t; )
                    t & 1 && this.map[r].call(this, !!(e.data & 1 << r)),
                    t >>= 1,
                    r++;
                this.stateId = e.data
            }
            for (let t = 0; t < this.checks.length; t++)
                this.checks[t](this, e)
        }
        forceState(e) {
            e || (e = this.defaultState);
            for (let t = 0; t < this.map.length; t++)
                this.map[t].call(this, !!(e.data & 1 << t));
            for (let t = 0; t < this.checks.length; t++)
                this.checks[t](this, e);
            this.stateId = e.data
        }
        setBlend(e) {
            this._updateCheck(rh._checkBlendMode, e),
            this.gl[e ? "enable" : "disable"](this.gl.BLEND)
        }
        setOffset(e) {
            this._updateCheck(rh._checkPolygonOffset, e),
            this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL)
        }
        setDepthTest(e) {
            this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST)
        }
        setDepthMask(e) {
            this.gl.depthMask(e)
        }
        setCullFace(e) {
            this._cullFace = e,
            this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE),
            this._cullFace && this._frontFaceDirty && this.setFrontFace(this._frontFace)
        }
        setFrontFace(e) {
            this._frontFace = e,
            this._frontFaceDirty = !1;
            let t = this._invertFrontFace ? !e : e;
            this._glFrontFace !== t && (this._glFrontFace = t,
            this.gl.frontFace(this.gl[t ? "CW" : "CCW"]))
        }
        setBlendMode(e) {
            if (this.blendModesMap[e] || (e = "normal"),
            e === this.blendMode)
                return;
            this.blendMode = e;
            let t = this.blendModesMap[e]
              , r = this.gl;
            t.length === 2 ? r.blendFunc(t[0], t[1]) : r.blendFuncSeparate(t[0], t[1], t[2], t[3]),
            t.length === 6 ? (this._blendEq = !0,
            r.blendEquationSeparate(t[4], t[5])) : this._blendEq && (this._blendEq = !1,
            r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD))
        }
        setPolygonOffset(e, t) {
            this.gl.polygonOffset(e, t)
        }
        resetState() {
            this._glFrontFace = !1,
            this._frontFace = !1,
            this._cullFace = !1,
            this._frontFaceDirty = !1,
            this._invertFrontFace = !1,
            this.gl.frontFace(this.gl.CCW),
            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
            this.forceState(this.defaultState),
            this._blendEq = !0,
            this.blendMode = "",
            this.setBlendMode("normal")
        }
        _updateCheck(e, t) {
            let r = this.checks.indexOf(e);
            t && r === -1 ? this.checks.push(e) : !t && r !== -1 && this.checks.splice(r, 1)
        }
        static _checkBlendMode(e, t) {
            e.setBlendMode(t.blendMode)
        }
        static _checkPolygonOffset(e, t) {
            e.setPolygonOffset(1, t.polygonOffset)
        }
        destroy() {
            this.gl = null,
            this.checks.length = 0
        }
    }
    ;
    hg.extension = {
        type: [B.WebGLSystem],
        name: "state"
    };
    var O6 = hg
      , sh = class {
        constructor(e) {
            this.target = eg.TEXTURE_2D,
            this.texture = e,
            this.width = -1,
            this.height = -1,
            this.type = Pe.UNSIGNED_BYTE,
            this.internalFormat = Zl.RGBA,
            this.format = Zl.RGBA,
            this.samplerType = 0
        }
    }
      , I6 = {
        id: "buffer",
        upload(i, e, t) {
            e.width === i.width || e.height === i.height ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, i.width, i.height, e.format, e.type, i.resource) : t.texImage2D(e.target, 0, e.internalFormat, i.width, i.height, 0, e.format, e.type, i.resource),
            e.width = i.width,
            e.height = i.height
        }
    }
      , G6 = {
        "bc1-rgba-unorm": !0,
        "bc1-rgba-unorm-srgb": !0,
        "bc2-rgba-unorm": !0,
        "bc2-rgba-unorm-srgb": !0,
        "bc3-rgba-unorm": !0,
        "bc3-rgba-unorm-srgb": !0,
        "bc4-r-unorm": !0,
        "bc4-r-snorm": !0,
        "bc5-rg-unorm": !0,
        "bc5-rg-snorm": !0,
        "bc6h-rgb-ufloat": !0,
        "bc6h-rgb-float": !0,
        "bc7-rgba-unorm": !0,
        "bc7-rgba-unorm-srgb": !0,
        "etc2-rgb8unorm": !0,
        "etc2-rgb8unorm-srgb": !0,
        "etc2-rgb8a1unorm": !0,
        "etc2-rgb8a1unorm-srgb": !0,
        "etc2-rgba8unorm": !0,
        "etc2-rgba8unorm-srgb": !0,
        "eac-r11unorm": !0,
        "eac-r11snorm": !0,
        "eac-rg11unorm": !0,
        "eac-rg11snorm": !0,
        "astc-4x4-unorm": !0,
        "astc-4x4-unorm-srgb": !0,
        "astc-5x4-unorm": !0,
        "astc-5x4-unorm-srgb": !0,
        "astc-5x5-unorm": !0,
        "astc-5x5-unorm-srgb": !0,
        "astc-6x5-unorm": !0,
        "astc-6x5-unorm-srgb": !0,
        "astc-6x6-unorm": !0,
        "astc-6x6-unorm-srgb": !0,
        "astc-8x5-unorm": !0,
        "astc-8x5-unorm-srgb": !0,
        "astc-8x6-unorm": !0,
        "astc-8x6-unorm-srgb": !0,
        "astc-8x8-unorm": !0,
        "astc-8x8-unorm-srgb": !0,
        "astc-10x5-unorm": !0,
        "astc-10x5-unorm-srgb": !0,
        "astc-10x6-unorm": !0,
        "astc-10x6-unorm-srgb": !0,
        "astc-10x8-unorm": !0,
        "astc-10x8-unorm-srgb": !0,
        "astc-10x10-unorm": !0,
        "astc-10x10-unorm-srgb": !0,
        "astc-12x10-unorm": !0,
        "astc-12x10-unorm-srgb": !0,
        "astc-12x12-unorm": !0,
        "astc-12x12-unorm-srgb": !0
    }
      , B6 = {
        id: "compressed",
        upload(i, e, t) {
            t.pixelStorei(t.UNPACK_ALIGNMENT, 4);
            let r = i.pixelWidth
              , s = i.pixelHeight
              , n = !!G6[i.format];
            for (let a = 0; a < i.resource.length; a++) {
                let c = i.resource[a];
                n ? t.compressedTexImage2D(t.TEXTURE_2D, a, e.internalFormat, r, s, 0, c) : t.texImage2D(t.TEXTURE_2D, a, e.internalFormat, r, s, 0, e.format, e.type, c),
                r = Math.max(r >> 1, 1),
                s = Math.max(s >> 1, 1)
            }
        }
    }
      , ug = {
        id: "image",
        upload(i, e, t, r) {
            let s = e.width
              , n = e.height
              , a = i.pixelWidth
              , c = i.pixelHeight
              , l = i.resourceWidth
              , u = i.resourceHeight;
            l < a || u < c ? ((s !== a || n !== c) && t.texImage2D(e.target, 0, e.internalFormat, a, c, 0, e.format, e.type, null),
            r === 2 ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, l, u, e.format, e.type, i.resource) : t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, e.format, e.type, i.resource)) : s === a && n === c ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, e.format, e.type, i.resource) : r === 2 ? t.texImage2D(e.target, 0, e.internalFormat, a, c, 0, e.format, e.type, i.resource) : t.texImage2D(e.target, 0, e.internalFormat, e.format, e.type, i.resource),
            e.width = a,
            e.height = c
        }
    }
      , F6 = {
        id: "video",
        upload(i, e, t, r) {
            if (!i.isValid) {
                t.texImage2D(e.target, 0, e.internalFormat, 1, 1, 0, e.format, e.type, null);
                return
            }
            ug.upload(i, e, t, r)
        }
    }
      , zp = {
        linear: 9729,
        nearest: 9728
    }
      , D6 = {
        linear: {
            linear: 9987,
            nearest: 9985
        },
        nearest: {
            linear: 9986,
            nearest: 9984
        }
    }
      , Tc = {
        "clamp-to-edge": 33071,
        repeat: 10497,
        "mirror-repeat": 33648
    }
      , k6 = {
        never: 512,
        less: 513,
        equal: 514,
        "less-equal": 515,
        greater: 516,
        "not-equal": 517,
        "greater-equal": 518,
        always: 519
    };
    function Vp(i, e, t, r, s, n, a, c) {
        let l = n;
        if (!c || i.addressModeU !== "repeat" || i.addressModeV !== "repeat" || i.addressModeW !== "repeat") {
            let u = Tc[a ? "clamp-to-edge" : i.addressModeU]
              , d = Tc[a ? "clamp-to-edge" : i.addressModeV]
              , f = Tc[a ? "clamp-to-edge" : i.addressModeW];
            e[s](l, e.TEXTURE_WRAP_S, u),
            e[s](l, e.TEXTURE_WRAP_T, d),
            e.TEXTURE_WRAP_R && e[s](l, e.TEXTURE_WRAP_R, f)
        }
        if ((!c || i.magFilter !== "linear") && e[s](l, e.TEXTURE_MAG_FILTER, zp[i.magFilter]),
        t) {
            if (!c || i.mipmapFilter !== "linear") {
                let u = D6[i.minFilter][i.mipmapFilter];
                e[s](l, e.TEXTURE_MIN_FILTER, u)
            }
        } else
            e[s](l, e.TEXTURE_MIN_FILTER, zp[i.minFilter]);
        if (r && i.maxAnisotropy > 1) {
            let u = Math.min(i.maxAnisotropy, e.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
            e[s](l, r.TEXTURE_MAX_ANISOTROPY_EXT, u)
        }
        i.compare && e[s](l, e.TEXTURE_COMPARE_FUNC, k6[i.compare])
    }
    function U6(i) {
        return {
            r8unorm: i.RED,
            r8snorm: i.RED,
            r8uint: i.RED,
            r8sint: i.RED,
            r16uint: i.RED,
            r16sint: i.RED,
            r16float: i.RED,
            rg8unorm: i.RG,
            rg8snorm: i.RG,
            rg8uint: i.RG,
            rg8sint: i.RG,
            r32uint: i.RED,
            r32sint: i.RED,
            r32float: i.RED,
            rg16uint: i.RG,
            rg16sint: i.RG,
            rg16float: i.RG,
            rgba8unorm: i.RGBA,
            "rgba8unorm-srgb": i.RGBA,
            rgba8snorm: i.RGBA,
            rgba8uint: i.RGBA,
            rgba8sint: i.RGBA,
            bgra8unorm: i.RGBA,
            "bgra8unorm-srgb": i.RGBA,
            rgb9e5ufloat: i.RGB,
            rgb10a2unorm: i.RGBA,
            rg11b10ufloat: i.RGB,
            rg32uint: i.RG,
            rg32sint: i.RG,
            rg32float: i.RG,
            rgba16uint: i.RGBA,
            rgba16sint: i.RGBA,
            rgba16float: i.RGBA,
            rgba32uint: i.RGBA,
            rgba32sint: i.RGBA,
            rgba32float: i.RGBA,
            stencil8: i.STENCIL_INDEX8,
            depth16unorm: i.DEPTH_COMPONENT,
            depth24plus: i.DEPTH_COMPONENT,
            "depth24plus-stencil8": i.DEPTH_STENCIL,
            depth32float: i.DEPTH_COMPONENT,
            "depth32float-stencil8": i.DEPTH_STENCIL
        }
    }
    var L6 = Object.defineProperty
      , N6 = Object.defineProperties
      , X6 = Object.getOwnPropertyDescriptors
      , Wp = Object.getOwnPropertySymbols
      , j6 = Object.prototype.hasOwnProperty
      , H6 = Object.prototype.propertyIsEnumerable
      , Yp = (i, e, t) => e in i ? L6(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Vi = (i, e) => {
        for (var t in e || (e = {}))
            j6.call(e, t) && Yp(i, t, e[t]);
        if (Wp)
            for (var t of Wp(e))
                H6.call(e, t) && Yp(i, t, e[t]);
        return i
    }
      , z6 = (i, e) => N6(i, X6(e));
    function V6(i, e) {
        let t = {}
          , r = i.RGBA;
        return i instanceof xe.get().getWebGLRenderingContext() ? e.srgb && (t = {
            "rgba8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT,
            "bgra8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT
        }) : (t = {
            "rgba8unorm-srgb": i.SRGB8_ALPHA8,
            "bgra8unorm-srgb": i.SRGB8_ALPHA8
        },
        r = i.RGBA8),
        Vi(Vi(Vi(Vi(Vi(Vi(z6(Vi({
            r8unorm: i.R8,
            r8snorm: i.R8_SNORM,
            r8uint: i.R8UI,
            r8sint: i.R8I,
            r16uint: i.R16UI,
            r16sint: i.R16I,
            r16float: i.R16F,
            rg8unorm: i.RG8,
            rg8snorm: i.RG8_SNORM,
            rg8uint: i.RG8UI,
            rg8sint: i.RG8I,
            r32uint: i.R32UI,
            r32sint: i.R32I,
            r32float: i.R32F,
            rg16uint: i.RG16UI,
            rg16sint: i.RG16I,
            rg16float: i.RG16F,
            rgba8unorm: i.RGBA
        }, t), {
            rgba8snorm: i.RGBA8_SNORM,
            rgba8uint: i.RGBA8UI,
            rgba8sint: i.RGBA8I,
            bgra8unorm: r,
            rgb9e5ufloat: i.RGB9_E5,
            rgb10a2unorm: i.RGB10_A2,
            rg11b10ufloat: i.R11F_G11F_B10F,
            rg32uint: i.RG32UI,
            rg32sint: i.RG32I,
            rg32float: i.RG32F,
            rgba16uint: i.RGBA16UI,
            rgba16sint: i.RGBA16I,
            rgba16float: i.RGBA16F,
            rgba32uint: i.RGBA32UI,
            rgba32sint: i.RGBA32I,
            rgba32float: i.RGBA32F,
            stencil8: i.STENCIL_INDEX8,
            depth16unorm: i.DEPTH_COMPONENT16,
            depth24plus: i.DEPTH_COMPONENT24,
            "depth24plus-stencil8": i.DEPTH24_STENCIL8,
            depth32float: i.DEPTH_COMPONENT32F,
            "depth32float-stencil8": i.DEPTH32F_STENCIL8
        }), e.s3tc ? {
            "bc1-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
            "bc2-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
            "bc3-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
        } : {}), e.s3tc_sRGB ? {
            "bc1-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
            "bc2-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
            "bc3-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
        } : {}), e.rgtc ? {
            "bc4-r-unorm": e.rgtc.COMPRESSED_RED_RGTC1_EXT,
            "bc4-r-snorm": e.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
            "bc5-rg-unorm": e.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
            "bc5-rg-snorm": e.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
        } : {}), e.bptc ? {
            "bc6h-rgb-float": e.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
            "bc6h-rgb-ufloat": e.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
            "bc7-rgba-unorm": e.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
            "bc7-rgba-unorm-srgb": e.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
        } : {}), e.etc ? {
            "etc2-rgb8unorm": e.etc.COMPRESSED_RGB8_ETC2,
            "etc2-rgb8unorm-srgb": e.etc.COMPRESSED_SRGB8_ETC2,
            "etc2-rgb8a1unorm": e.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
            "etc2-rgb8a1unorm-srgb": e.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
            "etc2-rgba8unorm": e.etc.COMPRESSED_RGBA8_ETC2_EAC,
            "etc2-rgba8unorm-srgb": e.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
            "eac-r11unorm": e.etc.COMPRESSED_R11_EAC,
            "eac-rg11unorm": e.etc.COMPRESSED_SIGNED_RG11_EAC
        } : {}), e.astc ? {
            "astc-4x4-unorm": e.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
            "astc-4x4-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
            "astc-5x4-unorm": e.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
            "astc-5x4-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
            "astc-5x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
            "astc-5x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
            "astc-6x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
            "astc-6x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
            "astc-6x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
            "astc-6x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
            "astc-8x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
            "astc-8x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
            "astc-8x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
            "astc-8x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
            "astc-8x8-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
            "astc-8x8-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
            "astc-10x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
            "astc-10x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
            "astc-10x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
            "astc-10x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
            "astc-10x8-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
            "astc-10x8-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
            "astc-10x10-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
            "astc-10x10-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
            "astc-12x10-unorm": e.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
            "astc-12x10-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
            "astc-12x12-unorm": e.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
            "astc-12x12-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
        } : {})
    }
    function W6(i) {
        return {
            r8unorm: i.UNSIGNED_BYTE,
            r8snorm: i.BYTE,
            r8uint: i.UNSIGNED_BYTE,
            r8sint: i.BYTE,
            r16uint: i.UNSIGNED_SHORT,
            r16sint: i.SHORT,
            r16float: i.HALF_FLOAT,
            rg8unorm: i.UNSIGNED_BYTE,
            rg8snorm: i.BYTE,
            rg8uint: i.UNSIGNED_BYTE,
            rg8sint: i.BYTE,
            r32uint: i.UNSIGNED_INT,
            r32sint: i.INT,
            r32float: i.FLOAT,
            rg16uint: i.UNSIGNED_SHORT,
            rg16sint: i.SHORT,
            rg16float: i.HALF_FLOAT,
            rgba8unorm: i.UNSIGNED_BYTE,
            "rgba8unorm-srgb": i.UNSIGNED_BYTE,
            rgba8snorm: i.BYTE,
            rgba8uint: i.UNSIGNED_BYTE,
            rgba8sint: i.BYTE,
            bgra8unorm: i.UNSIGNED_BYTE,
            "bgra8unorm-srgb": i.UNSIGNED_BYTE,
            rgb9e5ufloat: i.UNSIGNED_INT_5_9_9_9_REV,
            rgb10a2unorm: i.UNSIGNED_INT_2_10_10_10_REV,
            rg11b10ufloat: i.UNSIGNED_INT_10F_11F_11F_REV,
            rg32uint: i.UNSIGNED_INT,
            rg32sint: i.INT,
            rg32float: i.FLOAT,
            rgba16uint: i.UNSIGNED_SHORT,
            rgba16sint: i.SHORT,
            rgba16float: i.HALF_FLOAT,
            rgba32uint: i.UNSIGNED_INT,
            rgba32sint: i.INT,
            rgba32float: i.FLOAT,
            stencil8: i.UNSIGNED_BYTE,
            depth16unorm: i.UNSIGNED_SHORT,
            depth24plus: i.UNSIGNED_INT,
            "depth24plus-stencil8": i.UNSIGNED_INT_24_8,
            depth32float: i.FLOAT,
            "depth32float-stencil8": i.FLOAT_32_UNSIGNED_INT_24_8_REV
        }
    }
    var Y6 = 4
      , Ba = class {
        constructor(e) {
            this.managedTextures = [],
            this._glTextures = Object.create(null),
            this._glSamplers = Object.create(null),
            this._boundTextures = [],
            this._activeTextureLocation = -1,
            this._boundSamplers = Object.create(null),
            this._uploads = {
                image: ug,
                buffer: I6,
                video: F6,
                compressed: B6
            },
            this._premultiplyAlpha = !1,
            this._useSeparateSamplers = !1,
            this._renderer = e,
            this._renderer.renderableGC.addManagedHash(this, "_glTextures"),
            this._renderer.renderableGC.addManagedHash(this, "_glSamplers")
        }
        contextChange(e) {
            this._gl = e,
            this._mapFormatToInternalFormat || (this._mapFormatToInternalFormat = V6(e, this._renderer.context.extensions),
            this._mapFormatToType = W6(e),
            this._mapFormatToFormat = U6(e)),
            this._glTextures = Object.create(null),
            this._glSamplers = Object.create(null),
            this._boundSamplers = Object.create(null),
            this._premultiplyAlpha = !1;
            for (let t = 0; t < 16; t++)
                this.bind(Z.EMPTY, t)
        }
        initSource(e) {
            this.bind(e)
        }
        bind(e, t=0) {
            let r = e.source;
            e ? (this.bindSource(r, t),
            this._useSeparateSamplers && this._bindSampler(r.style, t)) : (this.bindSource(null, t),
            this._useSeparateSamplers && this._bindSampler(null, t))
        }
        bindSource(e, t=0) {
            let r = this._gl;
            if (e._touched = this._renderer.textureGC.count,
            this._boundTextures[t] !== e) {
                this._boundTextures[t] = e,
                this._activateLocation(t),
                e || (e = Z.EMPTY.source);
                let s = this.getGlSource(e);
                r.bindTexture(s.target, s.texture)
            }
        }
        _bindSampler(e, t=0) {
            let r = this._gl;
            if (!e) {
                this._boundSamplers[t] = null,
                r.bindSampler(t, null);
                return
            }
            let s = this._getGlSampler(e);
            this._boundSamplers[t] !== s && (this._boundSamplers[t] = s,
            r.bindSampler(t, s))
        }
        unbind(e) {
            let t = e.source
              , r = this._boundTextures
              , s = this._gl;
            for (let n = 0; n < r.length; n++)
                if (r[n] === t) {
                    this._activateLocation(n);
                    let a = this.getGlSource(t);
                    s.bindTexture(a.target, null),
                    r[n] = null
                }
        }
        _activateLocation(e) {
            this._activeTextureLocation !== e && (this._activeTextureLocation = e,
            this._gl.activeTexture(this._gl.TEXTURE0 + e))
        }
        _initSource(e) {
            let t = this._gl
              , r = new sh(t.createTexture());
            if (r.type = this._mapFormatToType[e.format],
            r.internalFormat = this._mapFormatToInternalFormat[e.format],
            r.format = this._mapFormatToFormat[e.format],
            e.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || e.isPowerOfTwo)) {
                let s = Math.max(e.width, e.height);
                e.mipLevelCount = Math.floor(Math.log2(s)) + 1
            }
            return this._glTextures[e.uid] = r,
            this.managedTextures.includes(e) || (e.on("update", this.onSourceUpdate, this),
            e.on("resize", this.onSourceUpdate, this),
            e.on("styleChange", this.onStyleChange, this),
            e.on("destroy", this.onSourceDestroy, this),
            e.on("unload", this.onSourceUnload, this),
            e.on("updateMipmaps", this.onUpdateMipmaps, this),
            this.managedTextures.push(e)),
            this.onSourceUpdate(e),
            this.updateStyle(e, !1),
            r
        }
        onStyleChange(e) {
            this.updateStyle(e, !1)
        }
        updateStyle(e, t) {
            let r = this._gl
              , s = this.getGlSource(e);
            r.bindTexture(r.TEXTURE_2D, s.texture),
            this._boundTextures[this._activeTextureLocation] = e,
            Vp(e.style, r, e.mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "texParameteri", r.TEXTURE_2D, !this._renderer.context.supports.nonPowOf2wrapping && !e.isPowerOfTwo, t)
        }
        onSourceUnload(e) {
            let t = this._glTextures[e.uid];
            t && (this.unbind(e),
            this._glTextures[e.uid] = null,
            this._gl.deleteTexture(t.texture))
        }
        onSourceUpdate(e) {
            let t = this._gl
              , r = this.getGlSource(e);
            t.bindTexture(t.TEXTURE_2D, r.texture),
            this._boundTextures[this._activeTextureLocation] = e;
            let s = e.alphaMode === "premultiply-alpha-on-upload";
            this._premultiplyAlpha !== s && (this._premultiplyAlpha = s,
            t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s)),
            this._uploads[e.uploadMethodId] ? this._uploads[e.uploadMethodId].upload(e, r, t, this._renderer.context.webGLVersion) : t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e.pixelWidth, e.pixelHeight, 0, t.RGBA, t.UNSIGNED_BYTE, null),
            e.autoGenerateMipmaps && e.mipLevelCount > 1 && this.onUpdateMipmaps(e, !1)
        }
        onUpdateMipmaps(e, t=!0) {
            t && this.bindSource(e, 0);
            let r = this.getGlSource(e);
            this._gl.generateMipmap(r.target)
        }
        onSourceDestroy(e) {
            e.off("destroy", this.onSourceDestroy, this),
            e.off("update", this.onSourceUpdate, this),
            e.off("resize", this.onSourceUpdate, this),
            e.off("unload", this.onSourceUnload, this),
            e.off("styleChange", this.onStyleChange, this),
            e.off("updateMipmaps", this.onUpdateMipmaps, this),
            this.managedTextures.splice(this.managedTextures.indexOf(e), 1),
            this.onSourceUnload(e)
        }
        _initSampler(e) {
            let t = this._gl
              , r = this._gl.createSampler();
            return this._glSamplers[e._resourceId] = r,
            Vp(e, t, this._boundTextures[this._activeTextureLocation].mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "samplerParameteri", r, !1, !0),
            this._glSamplers[e._resourceId]
        }
        _getGlSampler(e) {
            return this._glSamplers[e._resourceId] || this._initSampler(e)
        }
        getGlSource(e) {
            return this._glTextures[e.uid] || this._initSource(e)
        }
        generateCanvas(e) {
            let {pixels: t, width: r, height: s} = this.getPixels(e)
              , n = xe.get().createCanvas();
            n.width = r,
            n.height = s;
            let a = n.getContext("2d");
            if (a) {
                let c = a.createImageData(r, s);
                c.data.set(t),
                a.putImageData(c, 0, 0)
            }
            return n
        }
        getPixels(e) {
            let t = e.source.resolution
              , r = e.frame
              , s = Math.max(Math.round(r.width * t), 1)
              , n = Math.max(Math.round(r.height * t), 1)
              , a = new Uint8Array(Y6 * s * n)
              , c = this._renderer
              , l = c.renderTarget.getRenderTarget(e)
              , u = c.renderTarget.getGpuRenderTarget(l)
              , d = c.gl;
            return d.bindFramebuffer(d.FRAMEBUFFER, u.resolveTargetFramebuffer),
            d.readPixels(Math.round(r.x * t), Math.round(r.y * t), s, n, d.RGBA, d.UNSIGNED_BYTE, a),
            {
                pixels: new Uint8ClampedArray(a.buffer),
                width: s,
                height: n
            }
        }
        destroy() {
            this.managedTextures.slice().forEach(e => this.onSourceDestroy(e)),
            this.managedTextures = null,
            this._glTextures = null,
            this._glSamplers = null,
            this._boundTextures = null,
            this._boundSamplers = null,
            this._mapFormatToInternalFormat = null,
            this._mapFormatToType = null,
            this._mapFormatToFormat = null,
            this._uploads = null,
            this._renderer = null
        }
        resetState() {
            this._activeTextureLocation = -1,
            this._boundTextures.fill(Z.EMPTY.source),
            this._boundSamplers = Object.create(null);
            let e = this._gl;
            this._premultiplyAlpha = !1,
            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha)
        }
    }
    ;
    Ba.extension = {
        type: [B.WebGLSystem],
        name: "texture"
    };
    var Fa = class {
        contextChange(e) {
            let t = new ct({
                uColor: {
                    value: new Float32Array([1, 1, 1, 1]),
                    type: "vec4<f32>"
                },
                uTransformMatrix: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uRound: {
                    value: 0,
                    type: "f32"
                }
            })
              , r = e.limits.maxBatchableTextures
              , s = Rs({
                name: "graphics",
                bits: [Mh, Oh(r), Dh, Cs]
            });
            this.shader = new At({
                glProgram: s,
                resources: {
                    localUniforms: t,
                    batchSamplers: Ih(r)
                }
            })
        }
        execute(e, t) {
            let r = t.context
              , s = r.customShader || this.shader
              , n = e.renderer
              , a = n.graphicsContext
              , {batcher: c, instructions: l} = a.getContextRenderData(r);
            s.groups[0] = n.globalUniforms.bindGroup,
            n.state.set(e.state),
            n.shader.bind(s),
            n.geometry.bind(c.geometry, s.glProgram);
            let u = l.instructions;
            for (let d = 0; d < l.instructionSize; d++) {
                let f = u[d];
                if (f.size) {
                    for (let b = 0; b < f.textures.count; b++)
                        n.texture.bind(f.textures.textures[b], b);
                    n.geometry.draw(f.topology, f.size, f.start)
                }
            }
        }
        destroy() {
            this.shader.destroy(!0),
            this.shader = null
        }
    }
    ;
    Fa.extension = {
        type: [B.WebGLPipesAdaptor],
        name: "graphics"
    };
    var Da = class {
        init() {
            let e = Rs({
                name: "mesh",
                bits: [Dh, M8, Cs]
            });
            this._shader = new At({
                glProgram: e,
                resources: {
                    uTexture: Z.EMPTY.source,
                    textureUniforms: {
                        uTextureMatrix: {
                            type: "mat3x3<f32>",
                            value: new ce
                        }
                    }
                }
            })
        }
        execute(e, t) {
            let r = e.renderer
              , s = t._shader;
            if (s) {
                if (!s.glProgram)
                    return
            } else {
                s = this._shader;
                let n = t.texture
                  , a = n.source;
                s.resources.uTexture = a,
                s.resources.uSampler = a.style,
                s.resources.textureUniforms.uniforms.uTextureMatrix = n.textureMatrix.mapCoord
            }
            s.groups[100] = r.globalUniforms.bindGroup,
            s.groups[101] = e.localUniformsBindGroup,
            r.encoder.draw({
                geometry: t._geometry,
                shader: s,
                state: t.state
            })
        }
        destroy() {
            this._shader.destroy(!0),
            this._shader = null
        }
    }
    ;
    Da.extension = {
        type: [B.WebGLPipesAdaptor],
        name: "mesh"
    };
    var ka = class {
        constructor(e) {
            this._renderer = e
        }
        updateRenderable() {}
        destroyRenderable() {}
        validateRenderable() {
            return !1
        }
        addRenderable(e, t) {
            this._renderer.renderPipes.batch.break(t),
            t.add(e)
        }
        execute(e) {
            e.isRenderable && e.render(this._renderer)
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    ka.extension = {
        type: [B.WebGLPipes, B.WebGPUPipes, B.CanvasPipes],
        name: "customRender"
    };
    function nh(i, e) {
        let t = i.instructionSet
          , r = t.instructions;
        for (let s = 0; s < t.instructionSize; s++) {
            let n = r[s];
            e[n.renderPipeId].execute(n)
        }
    }
    var $6 = new ce
      , Ua = class {
        constructor(e) {
            this._renderer = e
        }
        addRenderGroup(e, t) {
            e.isCachedAsTexture ? this._addRenderableCacheAsTexture(e, t) : this._addRenderableDirect(e, t)
        }
        execute(e) {
            e.isRenderable && (e.isCachedAsTexture ? this._executeCacheAsTexture(e) : this._executeDirect(e))
        }
        destroy() {
            this._renderer = null
        }
        _addRenderableDirect(e, t) {
            this._renderer.renderPipes.batch.break(t),
            e._batchableRenderGroup && (et.return(e._batchableRenderGroup),
            e._batchableRenderGroup = null),
            t.add(e)
        }
        _addRenderableCacheAsTexture(e, t) {
            var r;
            let s = (r = e._batchableRenderGroup) != null ? r : e._batchableRenderGroup = et.get(Pr);
            s.renderable = e.root,
            s.transform = e.root.relativeGroupTransform,
            s.texture = e.texture,
            s.bounds = e._textureBounds,
            t.add(e),
            this._renderer.renderPipes.blendMode.pushBlendMode(e, e.root.groupBlendMode, t),
            this._renderer.renderPipes.batch.addToBatch(s, t),
            this._renderer.renderPipes.blendMode.popBlendMode(t)
        }
        _executeCacheAsTexture(e) {
            if (e.textureNeedsUpdate) {
                e.textureNeedsUpdate = !1;
                let t = $6.identity().translate(-e._textureBounds.x, -e._textureBounds.y);
                this._renderer.renderTarget.push(e.texture, !0, null, e.texture.frame),
                this._renderer.globalUniforms.push({
                    worldTransformMatrix: t,
                    worldColor: 4294967295,
                    offset: {
                        x: 0,
                        y: 0
                    }
                }),
                nh(e, this._renderer.renderPipes),
                this._renderer.renderTarget.finishRenderPass(),
                this._renderer.renderTarget.pop(),
                this._renderer.globalUniforms.pop()
            }
            e._batchableRenderGroup._batcher.updateElement(e._batchableRenderGroup),
            e._batchableRenderGroup._batcher.geometry.buffers[0].update()
        }
        _executeDirect(e) {
            this._renderer.globalUniforms.push({
                worldTransformMatrix: e.inverseParentTextureTransform,
                worldColor: e.worldColorAlpha
            }),
            nh(e, this._renderer.renderPipes),
            this._renderer.globalUniforms.pop()
        }
    }
    ;
    Ua.extension = {
        type: [B.WebGLPipes, B.WebGPUPipes, B.CanvasPipes],
        name: "renderGroup"
    };
    function ah(i, e) {
        e || (e = 0);
        for (let t = e; t < i.length && i[t]; t++)
            i[t] = null
    }
    var K6 = new _e
      , $p = is | gn | Ah;
    function dg(i, e=!1) {
        q6(i);
        let t = i.childrenToUpdate
          , r = i.updateTick++;
        for (let s in t) {
            let n = Number(s)
              , a = t[s]
              , c = a.list
              , l = a.index;
            for (let u = 0; u < l; u++) {
                let d = c[u];
                d.parentRenderGroup === i && d.relativeRenderGroupDepth === n && fg(d, r, 0)
            }
            ah(c, l),
            a.index = 0
        }
        if (e)
            for (let s = 0; s < i.renderGroupChildren.length; s++)
                dg(i.renderGroupChildren[s], e)
    }
    function q6(i) {
        let e = i.root, t;
        if (i.renderGroupParent) {
            let r = i.renderGroupParent;
            i.worldTransform.appendFrom(e.relativeGroupTransform, r.worldTransform),
            i.worldColor = pn(e.groupColor, r.worldColor),
            t = e.groupAlpha * r.worldAlpha
        } else
            i.worldTransform.copyFrom(e.localTransform),
            i.worldColor = e.localColor,
            t = e.localAlpha;
        t = t < 0 ? 0 : t > 1 ? 1 : t,
        i.worldAlpha = t,
        i.worldColorAlpha = i.worldColor + ((t * 255 | 0) << 24)
    }
    function fg(i, e, t) {
        if (e === i.updateTick)
            return;
        i.updateTick = e,
        i.didChange = !1;
        let r = i.localTransform;
        i.updateLocalTransform();
        let s = i.parent;
        if (s && !s.renderGroup ? (t |= i._updateFlags,
        i.relativeGroupTransform.appendFrom(r, s.relativeGroupTransform),
        t & $p && Kp(i, s, t)) : (t = i._updateFlags,
        i.relativeGroupTransform.copyFrom(r),
        t & $p && Kp(i, K6, t)),
        !i.renderGroup) {
            let n = i.children
              , a = n.length;
            for (let u = 0; u < a; u++)
                fg(n[u], e, t);
            let c = i.parentRenderGroup
              , l = i;
            l.renderPipeId && !c.structureDidChange && c.updateRenderable(l)
        }
    }
    function Kp(i, e, t) {
        if (t & gn) {
            i.groupColor = pn(i.localColor, e.groupColor);
            let r = i.localAlpha * e.groupAlpha;
            r = r < 0 ? 0 : r > 1 ? 1 : r,
            i.groupAlpha = r,
            i.groupColorAlpha = i.groupColor + ((r * 255 | 0) << 24)
        }
        t & Ah && (i.groupBlendMode = i.localBlendMode === "inherit" ? e.groupBlendMode : i.localBlendMode),
        t & is && (i.globalDisplayStatus = i.localDisplayStatus & e.globalDisplayStatus),
        i._updateFlags = 0
    }
    function Z6(i, e) {
        let {list: t, index: r} = i.childrenRenderablesToUpdate
          , s = !1;
        for (let n = 0; n < r; n++) {
            let a = t[n];
            if (s = e[a.renderPipeId].validateRenderable(a),
            s)
                break
        }
        return i.structureDidChange = s,
        s
    }
    var Q6 = new ce
      , La = class {
        constructor(e) {
            this._renderer = e
        }
        render({container: e, transform: t}) {
            let r = e.parent
              , s = e.renderGroup.renderGroupParent;
            e.parent = null,
            e.renderGroup.renderGroupParent = null;
            let n = this._renderer
              , a = Q6;
            t && (a.copyFrom(e.renderGroup.localTransform),
            e.renderGroup.localTransform.copyFrom(t));
            let c = n.renderPipes;
            this._updateCachedRenderGroups(e.renderGroup, null),
            this._updateRenderGroups(e.renderGroup),
            n.globalUniforms.start({
                worldTransformMatrix: t ? e.renderGroup.localTransform : e.renderGroup.worldTransform,
                worldColor: e.renderGroup.worldColorAlpha
            }),
            nh(e.renderGroup, c),
            c.uniformBatch && c.uniformBatch.renderEnd(),
            t && e.renderGroup.localTransform.copyFrom(a),
            e.parent = r,
            e.renderGroup.renderGroupParent = s
        }
        destroy() {
            this._renderer = null
        }
        _updateCachedRenderGroups(e, t) {
            var r, s;
            if (e._parentCacheAsTextureRenderGroup = t,
            e.isCachedAsTexture) {
                if (!e.textureNeedsUpdate)
                    return;
                t = e
            }
            for (let n = e.renderGroupChildren.length - 1; n >= 0; n--)
                this._updateCachedRenderGroups(e.renderGroupChildren[n], t);
            if (e.invalidateMatrices(),
            e.isCachedAsTexture) {
                if (e.textureNeedsUpdate) {
                    let n = e.root.getLocalBounds();
                    n.ceil();
                    let a = e.texture;
                    e.texture && Qe.returnTexture(e.texture, !0);
                    let c = this._renderer
                      , l = e.textureOptions.resolution || c.view.resolution
                      , u = (r = e.textureOptions.antialias) != null ? r : c.view.antialias
                      , d = (s = e.textureOptions.scaleMode) != null ? s : "linear"
                      , f = Qe.getOptimalTexture(n.width, n.height, l, u);
                    f._source.style = new Lt({
                        scaleMode: d
                    }),
                    e.texture = f,
                    e._textureBounds || (e._textureBounds = new at),
                    e._textureBounds.copyFrom(n),
                    a !== e.texture && e.renderGroupParent && (e.renderGroupParent.structureDidChange = !0)
                }
            } else
                e.texture && (Qe.returnTexture(e.texture, !0),
                e.texture = null)
        }
        _updateRenderGroups(e) {
            let t = this._renderer
              , r = t.renderPipes;
            if (e.runOnRender(t),
            e.instructionSet.renderPipes = r,
            e.structureDidChange ? ah(e.childrenRenderablesToUpdate.list, 0) : Z6(e, r),
            dg(e),
            e.structureDidChange ? (e.structureDidChange = !1,
            this._buildInstructions(e, t)) : this._updateRenderables(e),
            e.childrenRenderablesToUpdate.index = 0,
            t.renderPipes.batch.upload(e.instructionSet),
            !(e.isCachedAsTexture && !e.textureNeedsUpdate))
                for (let s = 0; s < e.renderGroupChildren.length; s++)
                    this._updateRenderGroups(e.renderGroupChildren[s])
        }
        _updateRenderables(e) {
            let {list: t, index: r} = e.childrenRenderablesToUpdate;
            for (let s = 0; s < r; s++) {
                let n = t[s];
                n.didViewUpdate && e.updateRenderable(n)
            }
            ah(t, r)
        }
        _buildInstructions(e, t) {
            let r = e.root
              , s = e.instructionSet;
            s.reset();
            let n = t.renderPipes ? t : t.batch.renderer
              , a = n.renderPipes;
            a.batch.buildStart(s),
            a.blendMode.buildStart(),
            a.colorMask.buildStart(),
            r.sortableChildren && r.sortChildren(),
            r.collectRenderablesWithEffects(s, n, null),
            a.batch.buildEnd(s),
            a.blendMode.buildEnd(s)
        }
    }
    ;
    La.extension = {
        type: [B.WebGLSystem, B.WebGPUSystem, B.CanvasSystem],
        name: "renderGroup"
    };
    var Na = class {
        constructor(e) {
            this._renderer = e
        }
        addRenderable(e, t) {
            let r = this._getGpuSprite(e);
            e.didViewUpdate && this._updateBatchableSprite(e, r),
            this._renderer.renderPipes.batch.addToBatch(r, t)
        }
        updateRenderable(e) {
            let t = this._getGpuSprite(e);
            e.didViewUpdate && this._updateBatchableSprite(e, t),
            t._batcher.updateElement(t)
        }
        validateRenderable(e) {
            let t = this._getGpuSprite(e);
            return !t._batcher.checkAndUpdateTexture(t, e._texture)
        }
        _updateBatchableSprite(e, t) {
            t.bounds = e.visualBounds,
            t.texture = e._texture
        }
        _getGpuSprite(e) {
            return e._gpuData[this._renderer.uid] || this._initGPUSprite(e)
        }
        _initGPUSprite(e) {
            let t = new Pr;
            return t.renderable = e,
            t.transform = e.groupTransform,
            t.texture = e._texture,
            t.bounds = e.visualBounds,
            t.roundPixels = this._renderer._roundPixels | e._roundPixels,
            e._gpuData[this._renderer.uid] = t,
            t
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    Na.extension = {
        type: [B.WebGLPipes, B.WebGPUPipes, B.CanvasPipes],
        name: "sprite"
    };
    var J6 = Object.defineProperty
      , qp = Object.getOwnPropertySymbols
      , eT = Object.prototype.hasOwnProperty
      , tT = Object.prototype.propertyIsEnumerable
      , Zp = (i, e, t) => e in i ? J6(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Qp = (i, e) => {
        for (var t in e || (e = {}))
            eT.call(e, t) && Zp(i, t, e[t]);
        if (qp)
            for (var t of qp(e))
                tT.call(e, t) && Zp(i, t, e[t]);
        return i
    }
      , oh = class pg {
        constructor() {
            this.clearBeforeRender = !0,
            this._backgroundColor = new Ie(0),
            this.color = this._backgroundColor,
            this.alpha = 1
        }
        init(e) {
            e = Qp(Qp({}, pg.defaultOptions), e),
            this.clearBeforeRender = e.clearBeforeRender,
            this.color = e.background || e.backgroundColor || this._backgroundColor,
            this.alpha = e.backgroundAlpha,
            this._backgroundColor.setAlpha(e.backgroundAlpha)
        }
        get color() {
            return this._backgroundColor
        }
        set color(e) {
            this._backgroundColor.setValue(e)
        }
        get alpha() {
            return this._backgroundColor.alpha
        }
        set alpha(e) {
            this._backgroundColor.setAlpha(e)
        }
        get colorRgba() {
            return this._backgroundColor.toArray()
        }
        destroy() {}
    }
    ;
    oh.extension = {
        type: [B.WebGLSystem, B.WebGPUSystem, B.CanvasSystem],
        name: "background",
        priority: 0
    },
    oh.defaultOptions = {
        backgroundAlpha: 1,
        backgroundColor: 0,
        clearBeforeRender: !0
    };
    var iT = oh
      , hs = {};
    be.handle(B.BlendMode, i => {
        if (!i.name)
            throw new Error("BlendMode extension must have a name property");
        hs[i.name] = i.ref
    }
    , i => {
        delete hs[i.name]
    }
    );
    var Xa = class {
        constructor(e) {
            this._blendModeStack = [],
            this._isAdvanced = !1,
            this._filterHash = Object.create(null),
            this._renderer = e,
            this._renderer.runners.prerender.add(this)
        }
        prerender() {
            this._activeBlendMode = "normal",
            this._isAdvanced = !1
        }
        pushBlendMode(e, t, r) {
            this._blendModeStack.push(t),
            this.setBlendMode(e, t, r)
        }
        popBlendMode(e) {
            var t;
            this._blendModeStack.pop();
            let r = (t = this._blendModeStack[this._activeBlendMode.length - 1]) != null ? t : "normal";
            this.setBlendMode(null, r, e)
        }
        setBlendMode(e, t, r) {
            var s;
            let n = e instanceof ds;
            if (this._activeBlendMode === t) {
                this._isAdvanced && e && !n && ((s = this._renderableList) == null || s.push(e));
                return
            }
            this._isAdvanced && this._endAdvancedBlendMode(r),
            this._activeBlendMode = t,
            e && (this._isAdvanced = !!hs[t],
            this._isAdvanced && this._beginAdvancedBlendMode(e, r))
        }
        _beginAdvancedBlendMode(e, t) {
            this._renderer.renderPipes.batch.break(t);
            let r = this._activeBlendMode;
            if (!hs[r])
                return;
            let s = this._ensureFilterEffect(r)
              , n = e instanceof ds
              , a = {
                renderPipeId: "filter",
                action: "pushFilter",
                filterEffect: s,
                renderables: n ? null : [e],
                container: n ? e.root : null,
                canBundle: !1
            };
            this._renderableList = a.renderables,
            t.add(a)
        }
        _ensureFilterEffect(e) {
            let t = this._filterHash[e];
            return t || (t = this._filterHash[e] = new Tr,
            t.filters = [new hs[e]]),
            t
        }
        _endAdvancedBlendMode(e) {
            this._isAdvanced = !1,
            this._renderableList = null,
            this._renderer.renderPipes.batch.break(e),
            e.add({
                renderPipeId: "filter",
                action: "popFilter",
                canBundle: !1
            })
        }
        buildStart() {
            this._isAdvanced = !1
        }
        buildEnd(e) {
            this._isAdvanced && this._endAdvancedBlendMode(e)
        }
        destroy() {
            this._renderer = null,
            this._renderableList = null;
            for (let e in this._filterHash)
                this._filterHash[e].destroy();
            this._filterHash = null
        }
    }
    ;
    Xa.extension = {
        type: [B.WebGLPipes, B.WebGPUPipes, B.CanvasPipes],
        name: "blendMode"
    };
    var rT = Object.defineProperty
      , Jp = Object.getOwnPropertySymbols
      , sT = Object.prototype.hasOwnProperty
      , nT = Object.prototype.propertyIsEnumerable
      , eb = (i, e, t) => e in i ? rT(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Sc = (i, e) => {
        for (var t in e || (e = {}))
            sT.call(e, t) && eb(i, t, e[t]);
        if (Jp)
            for (var t of Jp(e))
                nT.call(e, t) && eb(i, t, e[t]);
        return i
    }
      , wc = {
        png: "image/png",
        jpg: "image/jpeg",
        webp: "image/webp"
    }
      , ch = class bg {
        constructor(e) {
            this._renderer = e
        }
        _normalizeOptions(e, t={}) {
            return e instanceof _e || e instanceof Z ? Sc({
                target: e
            }, t) : Sc(Sc({}, t), e)
        }
        async image(e) {
            let t = xe.get().createImage();
            return t.src = await this.base64(e),
            t
        }
        async base64(e) {
            e = this._normalizeOptions(e, bg.defaultImageOptions);
            let {format: t, quality: r} = e
              , s = this.canvas(e);
            if (s.toBlob !== void 0)
                return new Promise( (n, a) => {
                    s.toBlob(c => {
                        if (!c) {
                            a(new Error("ICanvas.toBlob failed!"));
                            return
                        }
                        let l = new FileReader;
                        l.onload = () => n(l.result),
                        l.onerror = a,
                        l.readAsDataURL(c)
                    }
                    , wc[t], r)
                }
                );
            if (s.toDataURL !== void 0)
                return s.toDataURL(wc[t], r);
            if (s.convertToBlob !== void 0) {
                let n = await s.convertToBlob({
                    type: wc[t],
                    quality: r
                });
                return new Promise( (a, c) => {
                    let l = new FileReader;
                    l.onload = () => a(l.result),
                    l.onerror = c,
                    l.readAsDataURL(n)
                }
                )
            }
            throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented")
        }
        canvas(e) {
            e = this._normalizeOptions(e);
            let t = e.target
              , r = this._renderer;
            if (t instanceof Z)
                return r.texture.generateCanvas(t);
            let s = r.textureGenerator.generateTexture(e)
              , n = r.texture.generateCanvas(s);
            return s.destroy(!0),
            n
        }
        pixels(e) {
            e = this._normalizeOptions(e);
            let t = e.target
              , r = this._renderer
              , s = t instanceof Z ? t : r.textureGenerator.generateTexture(e)
              , n = r.texture.getPixels(s);
            return t instanceof _e && s.destroy(!0),
            n
        }
        texture(e) {
            return e = this._normalizeOptions(e),
            e.target instanceof Z ? e.target : this._renderer.textureGenerator.generateTexture(e)
        }
        download(e) {
            var t;
            e = this._normalizeOptions(e);
            let r = this.canvas(e)
              , s = document.createElement("a");
            s.download = (t = e.filename) != null ? t : "image.png",
            s.href = r.toDataURL("image/png"),
            document.body.appendChild(s),
            s.click(),
            document.body.removeChild(s)
        }
        log(e) {
            var t;
            let r = (t = e.width) != null ? t : 200;
            e = this._normalizeOptions(e);
            let s = this.canvas(e)
              , n = s.toDataURL()
              , a = ["font-size: 1px;", `padding: ${r}px 300px;`, `background: url(${n}) no-repeat;`, "background-size: contain;"].join(" ")
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    ch.extension = {
        type: [B.WebGLSystem, B.WebGPUSystem],
        name: "extract"
    },
    ch.defaultImageOptions = {
        format: "png",
        quality: 1
    };
    var aT = ch
      , lh = class i extends Z {
        static create(e) {
            return new i({
                source: new He(e)
            })
        }
        resize(e, t, r) {
            return this.source.resize(e, t, r),
            this
        }
    }
      , oT = Object.defineProperty
      , cT = Object.defineProperties
      , lT = Object.getOwnPropertyDescriptors
      , tb = Object.getOwnPropertySymbols
      , hT = Object.prototype.hasOwnProperty
      , uT = Object.prototype.propertyIsEnumerable
      , ib = (i, e, t) => e in i ? oT(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , dT = (i, e) => {
        for (var t in e || (e = {}))
            hT.call(e, t) && ib(i, t, e[t]);
        if (tb)
            for (var t of tb(e))
                uT.call(e, t) && ib(i, t, e[t]);
        return i
    }
      , fT = (i, e) => cT(i, lT(e))
      , pT = new Re
      , bT = new at
      , mT = [0, 0, 0, 0]
      , ja = class {
        constructor(e) {
            this._renderer = e
        }
        generateTexture(e) {
            var t;
            e instanceof _e && (e = {
                target: e,
                frame: void 0,
                textureSourceOptions: {},
                resolution: void 0
            });
            let r = e.resolution || this._renderer.resolution
              , s = e.antialias || this._renderer.view.antialias
              , n = e.target
              , a = e.clearColor;
            a ? a = Array.isArray(a) && a.length === 4 ? a : Ie.shared.setValue(a).toArray() : a = mT;
            let c = ((t = e.frame) == null ? void 0 : t.copyTo(pT)) || wh(n, bT).rectangle;
            c.width = Math.max(c.width, 1 / r) | 0,
            c.height = Math.max(c.height, 1 / r) | 0;
            let l = lh.create(fT(dT({}, e.textureSourceOptions), {
                width: c.width,
                height: c.height,
                resolution: r,
                antialias: s
            }))
              , u = ce.shared.translate(-c.x, -c.y);
            return this._renderer.render({
                container: n,
                transform: u,
                target: l,
                clearColor: a
            }),
            l.source.updateMipmaps(),
            l
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    ja.extension = {
        type: [B.WebGLSystem, B.WebGPUSystem],
        name: "textureGenerator"
    };
    var Ha = class {
        constructor(e) {
            this._stackIndex = 0,
            this._globalUniformDataStack = [],
            this._uniformsPool = [],
            this._activeUniforms = [],
            this._bindGroupPool = [],
            this._activeBindGroups = [],
            this._renderer = e
        }
        reset() {
            this._stackIndex = 0;
            for (let e = 0; e < this._activeUniforms.length; e++)
                this._uniformsPool.push(this._activeUniforms[e]);
            for (let e = 0; e < this._activeBindGroups.length; e++)
                this._bindGroupPool.push(this._activeBindGroups[e]);
            this._activeUniforms.length = 0,
            this._activeBindGroups.length = 0
        }
        start(e) {
            this.reset(),
            this.push(e)
        }
        bind({size: e, projectionMatrix: t, worldTransformMatrix: r, worldColor: s, offset: n}) {
            let a = this._renderer.renderTarget.renderTarget
              , c = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
                projectionData: a,
                worldTransformMatrix: new ce,
                worldColor: 4294967295,
                offset: new Ne
            }
              , l = {
                projectionMatrix: t || this._renderer.renderTarget.projectionMatrix,
                resolution: e || a.size,
                worldTransformMatrix: r || c.worldTransformMatrix,
                worldColor: s || c.worldColor,
                offset: n || c.offset,
                bindGroup: null
            }
              , u = this._uniformsPool.pop() || this._createUniforms();
            this._activeUniforms.push(u);
            let d = u.uniforms;
            d.uProjectionMatrix = l.projectionMatrix,
            d.uResolution = l.resolution,
            d.uWorldTransformMatrix.copyFrom(l.worldTransformMatrix),
            d.uWorldTransformMatrix.tx -= l.offset.x,
            d.uWorldTransformMatrix.ty -= l.offset.y,
            Os(l.worldColor, d.uWorldColorAlpha, 0),
            u.update();
            let f;
            this._renderer.renderPipes.uniformBatch ? f = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(u, !1) : (f = this._bindGroupPool.pop() || new Qt,
            this._activeBindGroups.push(f),
            f.setResource(u, 0)),
            l.bindGroup = f,
            this._currentGlobalUniformData = l
        }
        push(e) {
            this.bind(e),
            this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData
        }
        pop() {
            this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1],
            this._renderer.type === Bt.WEBGL && this._currentGlobalUniformData.bindGroup.resources[0].update()
        }
        get bindGroup() {
            return this._currentGlobalUniformData.bindGroup
        }
        get globalUniformData() {
            return this._currentGlobalUniformData
        }
        get uniformGroup() {
            return this._currentGlobalUniformData.bindGroup.resources[0]
        }
        _createUniforms() {
            return new ct({
                uProjectionMatrix: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uWorldTransformMatrix: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uWorldColorAlpha: {
                    value: new Float32Array(4),
                    type: "vec4<f32>"
                },
                uResolution: {
                    value: [0, 0],
                    type: "vec2<f32>"
                }
            },{
                isStatic: !0
            })
        }
        destroy() {
            this._renderer = null,
            this._globalUniformDataStack.length = 0,
            this._uniformsPool.length = 0,
            this._activeUniforms.length = 0,
            this._bindGroupPool.length = 0,
            this._activeBindGroups.length = 0,
            this._currentGlobalUniformData = null
        }
    }
    ;
    Ha.extension = {
        type: [B.WebGLSystem, B.WebGPUSystem, B.CanvasSystem],
        name: "globalUniforms"
    };
    var gT = 1
      , za = class {
        constructor() {
            this._tasks = [],
            this._offset = 0
        }
        init() {
            nt.system.add(this._update, this)
        }
        repeat(e, t, r=!0) {
            let s = gT++
              , n = 0;
            return r && (this._offset += 1e3,
            n = this._offset),
            this._tasks.push({
                func: e,
                duration: t,
                start: performance.now(),
                offset: n,
                last: performance.now(),
                repeat: !0,
                id: s
            }),
            s
        }
        cancel(e) {
            for (let t = 0; t < this._tasks.length; t++)
                if (this._tasks[t].id === e) {
                    this._tasks.splice(t, 1);
                    return
                }
        }
        _update() {
            let e = performance.now();
            for (let t = 0; t < this._tasks.length; t++) {
                let r = this._tasks[t];
                if (e - r.offset - r.last >= r.duration) {
                    let s = e - r.start;
                    r.func(s),
                    r.last = e
                }
            }
        }
        destroy() {
            nt.system.remove(this._update, this),
            this._tasks.length = 0
        }
    }
    ;
    za.extension = {
        type: [B.WebGLSystem, B.WebGPUSystem, B.CanvasSystem],
        name: "scheduler",
        priority: 0
    };
    var rb = !1;
    function _T(i) {
        if (!rb) {
            if (xe.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
                let e = [`%c  %c  %c  %c  %c PixiJS %c v${ta} (${i}) http://www.pixijs.com/

`, "background: #E72264; padding:5px 0;", "background: #6CA2EA; padding:5px 0;", "background: #B5D33D; padding:5px 0;", "background: #FED23F; padding:5px 0;", "color: #FFFFFF; background: #E72264; padding:5px 0;", "color: #E72264; background: #FFFFFF; padding:5px 0;"];
                globalThis.console.log(...e)
            } else
                globalThis.console && globalThis.console.log(`PixiJS ${ta} - ${i} - http://www.pixijs.com/`);
            rb = !0
        }
    }
    var As = class {
        constructor(e) {
            this._renderer = e
        }
        init(e) {
            if (e.hello) {
                let t = this._renderer.name;
                this._renderer.type === Bt.WEBGL && (t += ` ${this._renderer.context.webGLVersion}`),
                _T(t)
            }
        }
    }
    ;
    As.extension = {
        type: [B.WebGLSystem, B.WebGPUSystem, B.CanvasSystem],
        name: "hello",
        priority: -2
    },
    As.defaultOptions = {
        hello: !1
    };
    function xT(i) {
        let e = !1;
        for (let r in i)
            if (i[r] == null) {
                e = !0;
                break
            }
        if (!e)
            return i;
        let t = Object.create(null);
        for (let r in i) {
            let s = i[r];
            s && (t[r] = s)
        }
        return t
    }
    function yT(i) {
        let e = 0;
        for (let t = 0; t < i.length; t++)
            i[t] == null ? e++ : i[t - e] = i[t];
        return i.length -= e,
        i
    }
    var vT = Object.defineProperty
      , sb = Object.getOwnPropertySymbols
      , TT = Object.prototype.hasOwnProperty
      , ST = Object.prototype.propertyIsEnumerable
      , nb = (i, e, t) => e in i ? vT(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , ab = (i, e) => {
        for (var t in e || (e = {}))
            TT.call(e, t) && nb(i, t, e[t]);
        if (sb)
            for (var t of sb(e))
                ST.call(e, t) && nb(i, t, e[t]);
        return i
    }
      , wT = 0
      , hh = class mg {
        constructor(e) {
            this._managedRenderables = [],
            this._managedHashes = [],
            this._managedArrays = [],
            this._renderer = e
        }
        init(e) {
            e = ab(ab({}, mg.defaultOptions), e),
            this.maxUnusedTime = e.renderableGCMaxUnusedTime,
            this._frequency = e.renderableGCFrequency,
            this.enabled = e.renderableGCActive
        }
        get enabled() {
            return !!this._handler
        }
        set enabled(e) {
            this.enabled !== e && (e ? (this._handler = this._renderer.scheduler.repeat( () => this.run(), this._frequency, !1),
            this._hashHandler = this._renderer.scheduler.repeat( () => {
                for (let t of this._managedHashes)
                    t.context[t.hash] = xT(t.context[t.hash])
            }
            , this._frequency),
            this._arrayHandler = this._renderer.scheduler.repeat( () => {
                for (let t of this._managedArrays)
                    yT(t.context[t.hash])
            }
            , this._frequency)) : (this._renderer.scheduler.cancel(this._handler),
            this._renderer.scheduler.cancel(this._hashHandler),
            this._renderer.scheduler.cancel(this._arrayHandler)))
        }
        addManagedHash(e, t) {
            this._managedHashes.push({
                context: e,
                hash: t
            })
        }
        addManagedArray(e, t) {
            this._managedArrays.push({
                context: e,
                hash: t
            })
        }
        prerender({container: e}) {
            this._now = performance.now(),
            e.renderGroup.gcTick = wT++,
            this._updateInstructionGCTick(e.renderGroup, e.renderGroup.gcTick)
        }
        addRenderable(e) {
            this.enabled && (e._lastUsed === -1 && (this._managedRenderables.push(e),
            e.once("destroyed", this._removeRenderable, this)),
            e._lastUsed = this._now)
        }
        run() {
            var e, t, r, s;
            let n = this._now
              , a = this._managedRenderables
              , c = this._renderer.renderPipes
              , l = 0;
            for (let u = 0; u < a.length; u++) {
                let d = a[u];
                if (d === null) {
                    l++;
                    continue
                }
                let f = (e = d.renderGroup) != null ? e : d.parentRenderGroup
                  , b = (r = (t = f?.instructionSet) == null ? void 0 : t.gcTick) != null ? r : -1;
                if (((s = f?.gcTick) != null ? s : 0) === b && (d._lastUsed = n),
                n - d._lastUsed > this.maxUnusedTime) {
                    if (!d.destroyed) {
                        let m = c;
                        f && (f.structureDidChange = !0),
                        m[d.renderPipeId].destroyRenderable(d)
                    }
                    d._lastUsed = -1,
                    l++,
                    d.off("destroyed", this._removeRenderable, this)
                } else
                    a[u - l] = d
            }
            a.length -= l
        }
        destroy() {
            this.enabled = !1,
            this._renderer = null,
            this._managedRenderables.length = 0,
            this._managedHashes.length = 0,
            this._managedArrays.length = 0
        }
        _removeRenderable(e) {
            let t = this._managedRenderables.indexOf(e);
            t >= 0 && (e.off("destroyed", this._removeRenderable, this),
            this._managedRenderables[t] = null)
        }
        _updateInstructionGCTick(e, t) {
            e.instructionSet.gcTick = t;
            for (let r of e.renderGroupChildren)
                this._updateInstructionGCTick(r, t)
        }
    }
    ;
    hh.extension = {
        type: [B.WebGLSystem, B.WebGPUSystem],
        name: "renderableGC",
        priority: 0
    },
    hh.defaultOptions = {
        renderableGCActive: !0,
        renderableGCMaxUnusedTime: 6e4,
        renderableGCFrequency: 3e4
    };
    var AT = hh
      , ET = Object.defineProperty
      , ob = Object.getOwnPropertySymbols
      , PT = Object.prototype.hasOwnProperty
      , RT = Object.prototype.propertyIsEnumerable
      , cb = (i, e, t) => e in i ? ET(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , lb = (i, e) => {
        for (var t in e || (e = {}))
            PT.call(e, t) && cb(i, t, e[t]);
        if (ob)
            for (var t of ob(e))
                RT.call(e, t) && cb(i, t, e[t]);
        return i
    }
      , uh = class gg {
        constructor(e) {
            this._renderer = e,
            this.count = 0,
            this.checkCount = 0
        }
        init(e) {
            var t;
            e = lb(lb({}, gg.defaultOptions), e),
            this.checkCountMax = e.textureGCCheckCountMax,
            this.maxIdle = (t = e.textureGCAMaxIdle) != null ? t : e.textureGCMaxIdle,
            this.active = e.textureGCActive
        }
        postrender() {
            this._renderer.renderingToScreen && (this.count++,
            this.active && (this.checkCount++,
            this.checkCount > this.checkCountMax && (this.checkCount = 0,
            this.run())))
        }
        run() {
            let e = this._renderer.texture.managedTextures;
            for (let t = 0; t < e.length; t++) {
                let r = e[t];
                r.autoGarbageCollect && r.resource && r._touched > -1 && this.count - r._touched > this.maxIdle && (r._touched = -1,
                r.unload())
            }
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    uh.extension = {
        type: [B.WebGLSystem, B.WebGPUSystem],
        name: "textureGC"
    },
    uh.defaultOptions = {
        textureGCActive: !0,
        textureGCAMaxIdle: null,
        textureGCMaxIdle: 3600,
        textureGCCheckCountMax: 600
    };
    var MT = uh
      , CT = Object.defineProperty
      , hb = Object.getOwnPropertySymbols
      , OT = Object.prototype.hasOwnProperty
      , IT = Object.prototype.propertyIsEnumerable
      , ub = (i, e, t) => e in i ? CT(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , db = (i, e) => {
        for (var t in e || (e = {}))
            OT.call(e, t) && ub(i, t, e[t]);
        if (hb)
            for (var t of hb(e))
                IT.call(e, t) && ub(i, t, e[t]);
        return i
    }
      , dh = class _g {
        get autoDensity() {
            return this.texture.source.autoDensity
        }
        set autoDensity(e) {
            this.texture.source.autoDensity = e
        }
        get resolution() {
            return this.texture.source._resolution
        }
        set resolution(e) {
            this.texture.source.resize(this.texture.source.width, this.texture.source.height, e)
        }
        init(e) {
            e = db(db({}, _g.defaultOptions), e),
            e.view && (e.canvas = e.view),
            this.screen = new Re(0,0,e.width,e.height),
            this.canvas = e.canvas || xe.get().createCanvas(),
            this.antialias = !!e.antialias,
            this.texture = ng(this.canvas, e),
            this.renderTarget = new th({
                colorTextures: [this.texture],
                depth: !!e.depth,
                isRoot: !0
            }),
            this.texture.source.transparent = e.backgroundAlpha < 1,
            this.resolution = e.resolution
        }
        resize(e, t, r) {
            this.texture.source.resize(e, t, r),
            this.screen.width = this.texture.frame.width,
            this.screen.height = this.texture.frame.height
        }
        destroy(e=!1) {
            (typeof e == "boolean" ? e : e != null && e.removeView) && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas),
            this.texture.destroy()
        }
    }
    ;
    dh.extension = {
        type: [B.WebGLSystem, B.WebGPUSystem, B.CanvasSystem],
        name: "view",
        priority: 0
    },
    dh.defaultOptions = {
        width: 800,
        height: 600,
        autoDensity: !1,
        antialias: !1
    };
    var GT = dh
      , xg = [iT, Ha, As, GT, La, MT, ja, aT, ra, AT, za]
      , yg = [Xa, Zm, Na, Ua, xa, va, ya, ka]
      , BT = [...xg, Ma, W8, k8, Ea, Ta, Ba, Oa, Sa, Ga, Ia, Aa, O6, Pa, wa]
      , FT = [...yg]
      , DT = [ga, Da, Fa]
      , vg = []
      , Tg = []
      , Sg = [];
    be.handleByNamedList(B.WebGLSystem, vg),
    be.handleByNamedList(B.WebGLPipes, Tg),
    be.handleByNamedList(B.WebGLPipesAdaptor, Sg),
    be.add(...BT, ...FT, ...DT);
    var fh = class extends po {
        constructor() {
            let e = {
                name: "webgl",
                type: Bt.WEBGL,
                systems: vg,
                renderPipes: Tg,
                renderPipeAdaptors: Sg
            };
            super(e)
        }
    }
      , kT = {
        __proto__: null,
        WebGLRenderer: fh
    }
      , Va = class {
        constructor(e) {
            this._hash = Object.create(null),
            this._renderer = e,
            this._renderer.renderableGC.addManagedHash(this, "_hash")
        }
        contextChange(e) {
            this._gpu = e
        }
        getBindGroup(e, t, r) {
            return e._updateKey(),
            this._hash[e._key] || this._createBindGroup(e, t, r)
        }
        _createBindGroup(e, t, r) {
            var s;
            let n = this._gpu.device
              , a = t.layout[r]
              , c = []
              , l = this._renderer;
            for (let f in a) {
                let b = (s = e.resources[f]) != null ? s : e.resources[a[f]], m;
                if (b._resourceType === "uniformGroup") {
                    let x = b;
                    l.ubo.updateUniformGroup(x);
                    let y = x.buffer;
                    m = {
                        buffer: l.buffer.getGPUBuffer(y),
                        offset: 0,
                        size: y.descriptor.size
                    }
                } else if (b._resourceType === "buffer") {
                    let x = b;
                    m = {
                        buffer: l.buffer.getGPUBuffer(x),
                        offset: 0,
                        size: x.descriptor.size
                    }
                } else if (b._resourceType === "bufferResource") {
                    let x = b;
                    m = {
                        buffer: l.buffer.getGPUBuffer(x.buffer),
                        offset: x.offset,
                        size: x.size
                    }
                } else if (b._resourceType === "textureSampler") {
                    let x = b;
                    m = l.texture.getGpuSampler(x)
                } else if (b._resourceType === "textureSource") {
                    let x = b;
                    m = l.texture.getGpuSource(x).createView({})
                }
                c.push({
                    binding: a[f],
                    resource: m
                })
            }
            let u = l.shader.getProgramData(t).bindGroups[r]
              , d = n.createBindGroup({
                layout: u,
                entries: c
            });
            return this._hash[e._key] = d,
            d
        }
        destroy() {
            for (let e of Object.keys(this._hash))
                this._hash[e] = null;
            this._hash = null,
            this._renderer = null
        }
    }
    ;
    Va.extension = {
        type: [B.WebGPUSystem],
        name: "bindGroup"
    };
    var Wa = class {
        constructor(e) {
            this._gpuBuffers = Object.create(null),
            this._managedBuffers = [],
            e.renderableGC.addManagedHash(this, "_gpuBuffers")
        }
        contextChange(e) {
            this._gpu = e
        }
        getGPUBuffer(e) {
            return this._gpuBuffers[e.uid] || this.createGPUBuffer(e)
        }
        updateBuffer(e) {
            let t = this._gpuBuffers[e.uid] || this.createGPUBuffer(e)
              , r = e.data;
            return e._updateID && r && (e._updateID = 0,
            this._gpu.device.queue.writeBuffer(t, 0, r.buffer, 0, (e._updateSize || r.byteLength) + 3 & -4)),
            t
        }
        destroyAll() {
            for (let e in this._gpuBuffers)
                this._gpuBuffers[e].destroy();
            this._gpuBuffers = {}
        }
        createGPUBuffer(e) {
            this._gpuBuffers[e.uid] || (e.on("update", this.updateBuffer, this),
            e.on("change", this.onBufferChange, this),
            e.on("destroy", this.onBufferDestroy, this),
            this._managedBuffers.push(e));
            let t = this._gpu.device.createBuffer(e.descriptor);
            return e._updateID = 0,
            e.data && (zc(e.data.buffer, t.getMappedRange()),
            t.unmap()),
            this._gpuBuffers[e.uid] = t,
            t
        }
        onBufferChange(e) {
            this._gpuBuffers[e.uid].destroy(),
            e._updateID = 0,
            this._gpuBuffers[e.uid] = this.createGPUBuffer(e)
        }
        onBufferDestroy(e) {
            this._managedBuffers.splice(this._managedBuffers.indexOf(e), 1),
            this._destroyBuffer(e)
        }
        destroy() {
            this._managedBuffers.forEach(e => this._destroyBuffer(e)),
            this._managedBuffers = null,
            this._gpuBuffers = null
        }
        _destroyBuffer(e) {
            this._gpuBuffers[e.uid].destroy(),
            e.off("update", this.updateBuffer, this),
            e.off("change", this.onBufferChange, this),
            e.off("destroy", this.onBufferDestroy, this),
            this._gpuBuffers[e.uid] = null
        }
    }
    ;
    Wa.extension = {
        type: [B.WebGPUSystem],
        name: "buffer"
    };
    var ph = class {
        constructor({minUniformOffsetAlignment: e}) {
            this._minUniformOffsetAlignment = 256,
            this.byteIndex = 0,
            this._minUniformOffsetAlignment = e,
            this.data = new Float32Array(65535)
        }
        clear() {
            this.byteIndex = 0
        }
        addEmptyGroup(e) {
            if (e > this._minUniformOffsetAlignment / 4)
                throw new Error(`UniformBufferBatch: array is too large: ${e * 4}`);
            let t = this.byteIndex
              , r = t + e * 4;
            if (r = Math.ceil(r / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment,
            r > this.data.length * 4)
                throw new Error("UniformBufferBatch: ubo batch got too big");
            return this.byteIndex = r,
            t
        }
        addGroup(e) {
            let t = this.addEmptyGroup(e.length);
            for (let r = 0; r < e.length; r++)
                this.data[t / 4 + r] = e[r];
            return t
        }
        destroy() {
            this.data = null
        }
    }
      , Ya = class {
        constructor(e) {
            this._colorMaskCache = 15,
            this._renderer = e
        }
        setMask(e) {
            this._colorMaskCache !== e && (this._colorMaskCache = e,
            this._renderer.pipeline.setColorMask(e))
        }
        destroy() {
            this._renderer = null,
            this._colorMaskCache = null
        }
    }
    ;
    Ya.extension = {
        type: [B.WebGPUSystem],
        name: "colorMask"
    };
    var Es = class {
        constructor(e) {
            this._renderer = e
        }
        async init(e) {
            return this._initPromise ? this._initPromise : (this._initPromise = (e.gpu ? Promise.resolve(e.gpu) : this._createDeviceAndAdaptor(e)).then(t => {
                this.gpu = t,
                this._renderer.runners.contextChange.emit(this.gpu)
            }
            ),
            this._initPromise)
        }
        contextChange(e) {
            this._renderer.gpu = e
        }
        async _createDeviceAndAdaptor(e) {
            let t = await xe.get().getNavigator().gpu.requestAdapter({
                powerPreference: e.powerPreference,
                forceFallbackAdapter: e.forceFallbackAdapter
            })
              , r = ["texture-compression-bc", "texture-compression-astc", "texture-compression-etc2"].filter(n => t.features.has(n))
              , s = await t.requestDevice({
                requiredFeatures: r
            });
            return {
                adapter: t,
                device: s
            }
        }
        destroy() {
            this.gpu = null,
            this._renderer = null
        }
    }
    ;
    Es.extension = {
        type: [B.WebGPUSystem],
        name: "device"
    },
    Es.defaultOptions = {
        powerPreference: void 0,
        forceFallbackAdapter: !1
    };
    var UT = Object.defineProperty
      , fb = Object.getOwnPropertySymbols
      , LT = Object.prototype.hasOwnProperty
      , NT = Object.prototype.propertyIsEnumerable
      , pb = (i, e, t) => e in i ? UT(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , bb = (i, e) => {
        for (var t in e || (e = {}))
            LT.call(e, t) && pb(i, t, e[t]);
        if (fb)
            for (var t of fb(e))
                NT.call(e, t) && pb(i, t, e[t]);
        return i
    }
      , $a = class {
        constructor(e) {
            this._boundBindGroup = Object.create(null),
            this._boundVertexBuffer = Object.create(null),
            this._renderer = e
        }
        renderStart() {
            this.commandFinished = new Promise(e => {
                this._resolveCommandFinished = e
            }
            ),
            this.commandEncoder = this._renderer.gpu.device.createCommandEncoder()
        }
        beginRenderPass(e) {
            this.endRenderPass(),
            this._clearCache(),
            this.renderPassEncoder = this.commandEncoder.beginRenderPass(e.descriptor)
        }
        endRenderPass() {
            this.renderPassEncoder && this.renderPassEncoder.end(),
            this.renderPassEncoder = null
        }
        setViewport(e) {
            this.renderPassEncoder.setViewport(e.x, e.y, e.width, e.height, 0, 1)
        }
        setPipelineFromGeometryProgramAndState(e, t, r, s) {
            let n = this._renderer.pipeline.getPipeline(e, t, r, s);
            this.setPipeline(n)
        }
        setPipeline(e) {
            this._boundPipeline !== e && (this._boundPipeline = e,
            this.renderPassEncoder.setPipeline(e))
        }
        _setVertexBuffer(e, t) {
            this._boundVertexBuffer[e] !== t && (this._boundVertexBuffer[e] = t,
            this.renderPassEncoder.setVertexBuffer(e, this._renderer.buffer.updateBuffer(t)))
        }
        _setIndexBuffer(e) {
            if (this._boundIndexBuffer === e)
                return;
            this._boundIndexBuffer = e;
            let t = e.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
            this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(e), t)
        }
        resetBindGroup(e) {
            this._boundBindGroup[e] = null
        }
        setBindGroup(e, t, r) {
            if (this._boundBindGroup[e] === t)
                return;
            this._boundBindGroup[e] = t,
            t._touch(this._renderer.textureGC.count);
            let s = this._renderer.bindGroup.getBindGroup(t, r, e);
            this.renderPassEncoder.setBindGroup(e, s)
        }
        setGeometry(e, t) {
            let r = this._renderer.pipeline.getBufferNamesToBind(e, t);
            for (let s in r)
                this._setVertexBuffer(parseInt(s, 10), e.attributes[r[s]].buffer);
            e.indexBuffer && this._setIndexBuffer(e.indexBuffer)
        }
        _setShaderBindGroups(e, t) {
            for (let r in e.groups) {
                let s = e.groups[r];
                t || this._syncBindGroup(s),
                this.setBindGroup(r, s, e.gpuProgram)
            }
        }
        _syncBindGroup(e) {
            for (let t in e.resources) {
                let r = e.resources[t];
                r.isUniformGroup && this._renderer.ubo.updateUniformGroup(r)
            }
        }
        draw(e) {
            let {geometry: t, shader: r, state: s, topology: n, size: a, start: c, instanceCount: l, skipSync: u} = e;
            this.setPipelineFromGeometryProgramAndState(t, r.gpuProgram, s, n),
            this.setGeometry(t, r.gpuProgram),
            this._setShaderBindGroups(r, u),
            t.indexBuffer ? this.renderPassEncoder.drawIndexed(a || t.indexBuffer.data.length, l ?? t.instanceCount, c || 0) : this.renderPassEncoder.draw(a || t.getSize(), l ?? t.instanceCount, c || 0)
        }
        finishRenderPass() {
            this.renderPassEncoder && (this.renderPassEncoder.end(),
            this.renderPassEncoder = null)
        }
        postrender() {
            this.finishRenderPass(),
            this._gpu.device.queue.submit([this.commandEncoder.finish()]),
            this._resolveCommandFinished(),
            this.commandEncoder = null
        }
        restoreRenderPass() {
            let e = this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget, !1, [0, 0, 0, 1]);
            this.renderPassEncoder = this.commandEncoder.beginRenderPass(e);
            let t = this._boundPipeline
              , r = bb({}, this._boundVertexBuffer)
              , s = this._boundIndexBuffer
              , n = bb({}, this._boundBindGroup);
            this._clearCache();
            let a = this._renderer.renderTarget.viewport;
            this.renderPassEncoder.setViewport(a.x, a.y, a.width, a.height, 0, 1),
            this.setPipeline(t);
            for (let c in r)
                this._setVertexBuffer(c, r[c]);
            for (let c in n)
                this.setBindGroup(c, n[c], null);
            this._setIndexBuffer(s)
        }
        _clearCache() {
            for (let e = 0; e < 16; e++)
                this._boundBindGroup[e] = null,
                this._boundVertexBuffer[e] = null;
            this._boundIndexBuffer = null,
            this._boundPipeline = null
        }
        destroy() {
            this._renderer = null,
            this._gpu = null,
            this._boundBindGroup = null,
            this._boundVertexBuffer = null,
            this._boundIndexBuffer = null,
            this._boundPipeline = null
        }
        contextChange(e) {
            this._gpu = e
        }
    }
    ;
    $a.extension = {
        type: [B.WebGPUSystem],
        name: "encoder",
        priority: 1
    };
    var Ka = class {
        constructor(e) {
            this._renderer = e
        }
        contextChange() {
            this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage,
            this.maxBatchableTextures = this.maxTextures
        }
        destroy() {}
    }
    ;
    Ka.extension = {
        type: [B.WebGPUSystem],
        name: "limits"
    };
    var qa = class {
        constructor(e) {
            this._renderTargetStencilState = Object.create(null),
            this._renderer = e,
            e.renderTarget.onRenderTargetChange.add(this)
        }
        onRenderTargetChange(e) {
            let t = this._renderTargetStencilState[e.uid];
            t || (t = this._renderTargetStencilState[e.uid] = {
                stencilMode: Je.DISABLED,
                stencilReference: 0
            }),
            this._activeRenderTarget = e,
            this.setStencilMode(t.stencilMode, t.stencilReference)
        }
        setStencilMode(e, t) {
            let r = this._renderTargetStencilState[this._activeRenderTarget.uid];
            r.stencilMode = e,
            r.stencilReference = t;
            let s = this._renderer;
            s.pipeline.setStencilMode(e),
            s.encoder.renderPassEncoder.setStencilReference(t)
        }
        destroy() {
            this._renderer.renderTarget.onRenderTargetChange.remove(this),
            this._renderer = null,
            this._activeRenderTarget = null,
            this._renderTargetStencilState = null
        }
    }
    ;
    qa.extension = {
        type: [B.WebGPUSystem],
        name: "stencil"
    };
    var un = {
        i32: {
            align: 4,
            size: 4
        },
        u32: {
            align: 4,
            size: 4
        },
        f32: {
            align: 4,
            size: 4
        },
        f16: {
            align: 2,
            size: 2
        },
        "vec2<i32>": {
            align: 8,
            size: 8
        },
        "vec2<u32>": {
            align: 8,
            size: 8
        },
        "vec2<f32>": {
            align: 8,
            size: 8
        },
        "vec2<f16>": {
            align: 4,
            size: 4
        },
        "vec3<i32>": {
            align: 16,
            size: 12
        },
        "vec3<u32>": {
            align: 16,
            size: 12
        },
        "vec3<f32>": {
            align: 16,
            size: 12
        },
        "vec3<f16>": {
            align: 8,
            size: 6
        },
        "vec4<i32>": {
            align: 16,
            size: 16
        },
        "vec4<u32>": {
            align: 16,
            size: 16
        },
        "vec4<f32>": {
            align: 16,
            size: 16
        },
        "vec4<f16>": {
            align: 8,
            size: 8
        },
        "mat2x2<f32>": {
            align: 8,
            size: 16
        },
        "mat2x2<f16>": {
            align: 4,
            size: 8
        },
        "mat3x2<f32>": {
            align: 8,
            size: 24
        },
        "mat3x2<f16>": {
            align: 4,
            size: 12
        },
        "mat4x2<f32>": {
            align: 8,
            size: 32
        },
        "mat4x2<f16>": {
            align: 4,
            size: 16
        },
        "mat2x3<f32>": {
            align: 16,
            size: 32
        },
        "mat2x3<f16>": {
            align: 8,
            size: 16
        },
        "mat3x3<f32>": {
            align: 16,
            size: 48
        },
        "mat3x3<f16>": {
            align: 8,
            size: 24
        },
        "mat4x3<f32>": {
            align: 16,
            size: 64
        },
        "mat4x3<f16>": {
            align: 8,
            size: 32
        },
        "mat2x4<f32>": {
            align: 16,
            size: 32
        },
        "mat2x4<f16>": {
            align: 8,
            size: 16
        },
        "mat3x4<f32>": {
            align: 16,
            size: 48
        },
        "mat3x4<f16>": {
            align: 8,
            size: 24
        },
        "mat4x4<f32>": {
            align: 16,
            size: 64
        },
        "mat4x4<f16>": {
            align: 8,
            size: 32
        }
    };
    function XT(i) {
        let e = i.map(r => ({
            data: r,
            offset: 0,
            size: 0
        }))
          , t = 0;
        for (let r = 0; r < e.length; r++) {
            let s = e[r]
              , n = un[s.data.type].size
              , a = un[s.data.type].align;
            if (!un[s.data.type])
                throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${s.data.type}`);
            s.data.size > 1 && (n = Math.max(n, a) * s.data.size),
            t = Math.ceil(t / a) * a,
            s.size = n,
            s.offset = t,
            t += n
        }
        return t = Math.ceil(t / 16) * 16,
        {
            uboElements: e,
            size: t
        }
    }
    function jT(i, e) {
        let {size: t, align: r} = un[i.data.type]
          , s = (r - t) / 4
          , n = i.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
        return `
         v = uv.${i.data.name};
         ${e !== 0 ? `offset += ${e};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${i.data.size * (t / 4)}; i++)
         {
             for(var j = 0; j < ${t / 4}; j++)
             {
                 ${n}[arrayOffset++] = v[t++];
             }
             ${s !== 0 ? `arrayOffset += ${s};` : ""}
         }
     `
    }
    function HT(i) {
        return rg(i, "uboWgsl", jT, t6)
    }
    var Za = class extends Ra {
        constructor() {
            super({
                createUboElements: XT,
                generateUboSync: HT
            })
        }
    }
    ;
    Za.extension = {
        type: [B.WebGPUSystem],
        name: "ubo"
    };
    var Mi = 128
      , Qa = class {
        constructor(e) {
            this._bindGroupHash = Object.create(null),
            this._buffers = [],
            this._bindGroups = [],
            this._bufferResources = [],
            this._renderer = e,
            this._renderer.renderableGC.addManagedHash(this, "_bindGroupHash"),
            this._batchBuffer = new ph({
                minUniformOffsetAlignment: Mi
            });
            let t = 256 / Mi;
            for (let r = 0; r < t; r++) {
                let s = Ae.UNIFORM | Ae.COPY_DST;
                r === 0 && (s |= Ae.COPY_SRC),
                this._buffers.push(new gt({
                    data: this._batchBuffer.data,
                    usage: s
                }))
            }
        }
        renderEnd() {
            this._uploadBindGroups(),
            this._resetBindGroups()
        }
        _resetBindGroups() {
            for (let e in this._bindGroupHash)
                this._bindGroupHash[e] = null;
            this._batchBuffer.clear()
        }
        getUniformBindGroup(e, t) {
            if (!t && this._bindGroupHash[e.uid])
                return this._bindGroupHash[e.uid];
            this._renderer.ubo.ensureUniformGroup(e);
            let r = e.buffer.data
              , s = this._batchBuffer.addEmptyGroup(r.length);
            return this._renderer.ubo.syncUniformGroup(e, this._batchBuffer.data, s / 4),
            this._bindGroupHash[e.uid] = this._getBindGroup(s / Mi),
            this._bindGroupHash[e.uid]
        }
        getUboResource(e) {
            this._renderer.ubo.updateUniformGroup(e);
            let t = e.buffer.data
              , r = this._batchBuffer.addGroup(t);
            return this._getBufferResource(r / Mi)
        }
        getArrayBindGroup(e) {
            let t = this._batchBuffer.addGroup(e);
            return this._getBindGroup(t / Mi)
        }
        getArrayBufferResource(e) {
            let t = this._batchBuffer.addGroup(e) / Mi;
            return this._getBufferResource(t)
        }
        _getBufferResource(e) {
            if (!this._bufferResources[e]) {
                let t = this._buffers[e % 2];
                this._bufferResources[e] = new ws({
                    buffer: t,
                    offset: (e / 2 | 0) * 256,
                    size: Mi
                })
            }
            return this._bufferResources[e]
        }
        _getBindGroup(e) {
            if (!this._bindGroups[e]) {
                let t = new Qt({
                    0: this._getBufferResource(e)
                });
                this._bindGroups[e] = t
            }
            return this._bindGroups[e]
        }
        _uploadBindGroups() {
            let e = this._renderer.buffer
              , t = this._buffers[0];
            t.update(this._batchBuffer.byteIndex),
            e.updateBuffer(t);
            let r = this._renderer.gpu.device.createCommandEncoder();
            for (let s = 1; s < this._buffers.length; s++) {
                let n = this._buffers[s];
                r.copyBufferToBuffer(e.getGPUBuffer(t), Mi, e.getGPUBuffer(n), 0, this._batchBuffer.byteIndex)
            }
            this._renderer.gpu.device.queue.submit([r.finish()])
        }
        destroy() {
            var e;
            for (let t = 0; t < this._bindGroups.length; t++)
                (e = this._bindGroups[t]) == null || e.destroy();
            this._bindGroups = null,
            this._bindGroupHash = null;
            for (let t = 0; t < this._buffers.length; t++)
                this._buffers[t].destroy();
            this._buffers = null;
            for (let t = 0; t < this._bufferResources.length; t++)
                this._bufferResources[t].destroy();
            this._bufferResources = null,
            this._batchBuffer.destroy(),
            this._bindGroupHash = null,
            this._renderer = null
        }
    }
    ;
    Qa.extension = {
        type: [B.WebGPUPipes],
        name: "uniformBatch"
    };
    var zT = Object.defineProperty
      , VT = Object.defineProperties
      , WT = Object.getOwnPropertyDescriptors
      , mb = Object.getOwnPropertySymbols
      , YT = Object.prototype.hasOwnProperty
      , $T = Object.prototype.propertyIsEnumerable
      , gb = (i, e, t) => e in i ? zT(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , KT = (i, e) => {
        for (var t in e || (e = {}))
            YT.call(e, t) && gb(i, t, e[t]);
        if (mb)
            for (var t of mb(e))
                $T.call(e, t) && gb(i, t, e[t]);
        return i
    }
      , qT = (i, e) => VT(i, WT(e))
      , ZT = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 2,
        "triangle-list": 3,
        "triangle-strip": 4
    };
    function QT(i, e, t, r, s) {
        return i << 24 | e << 16 | t << 10 | r << 5 | s
    }
    function JT(i, e, t, r) {
        return t << 6 | i << 3 | r << 1 | e
    }
    var Ja = class {
        constructor(e) {
            this._moduleCache = Object.create(null),
            this._bufferLayoutsCache = Object.create(null),
            this._bindingNamesCache = Object.create(null),
            this._pipeCache = Object.create(null),
            this._pipeStateCaches = Object.create(null),
            this._colorMask = 15,
            this._multisampleCount = 1,
            this._renderer = e
        }
        contextChange(e) {
            this._gpu = e,
            this.setStencilMode(Je.DISABLED),
            this._updatePipeHash()
        }
        setMultisampleCount(e) {
            this._multisampleCount !== e && (this._multisampleCount = e,
            this._updatePipeHash())
        }
        setRenderTarget(e) {
            this._multisampleCount = e.msaaSamples,
            this._depthStencilAttachment = e.descriptor.depthStencilAttachment ? 1 : 0,
            this._updatePipeHash()
        }
        setColorMask(e) {
            this._colorMask !== e && (this._colorMask = e,
            this._updatePipeHash())
        }
        setStencilMode(e) {
            this._stencilMode !== e && (this._stencilMode = e,
            this._stencilState = Ci[e],
            this._updatePipeHash())
        }
        setPipeline(e, t, r, s) {
            let n = this.getPipeline(e, t, r);
            s.setPipeline(n)
        }
        getPipeline(e, t, r, s) {
            e._layoutKey || (Jm(e, t.attributeData),
            this._generateBufferKey(e)),
            s || (s = e.topology);
            let n = QT(e._layoutKey, t._layoutKey, r.data, r._blendModeId, ZT[s]);
            return this._pipeCache[n] ? this._pipeCache[n] : (this._pipeCache[n] = this._createPipeline(e, t, r, s),
            this._pipeCache[n])
        }
        _createPipeline(e, t, r, s) {
            let n = this._gpu.device
              , a = this._createVertexBufferLayouts(e, t)
              , c = this._renderer.state.getColorTargets(r);
            c[0].writeMask = this._stencilMode === Je.RENDERING_MASK_ADD ? 0 : this._colorMask;
            let l = this._renderer.shader.getProgramData(t).pipeline
              , u = {
                vertex: {
                    module: this._getModule(t.vertex.source),
                    entryPoint: t.vertex.entryPoint,
                    buffers: a
                },
                fragment: {
                    module: this._getModule(t.fragment.source),
                    entryPoint: t.fragment.entryPoint,
                    targets: c
                },
                primitive: {
                    topology: s,
                    cullMode: r.cullMode
                },
                layout: l,
                multisample: {
                    count: this._multisampleCount
                },
                label: "PIXI Pipeline"
            };
            return this._depthStencilAttachment && (u.depthStencil = qT(KT({}, this._stencilState), {
                format: "depth24plus-stencil8",
                depthWriteEnabled: r.depthTest,
                depthCompare: r.depthTest ? "less" : "always"
            })),
            n.createRenderPipeline(u)
        }
        _getModule(e) {
            return this._moduleCache[e] || this._createModule(e)
        }
        _createModule(e) {
            let t = this._gpu.device;
            return this._moduleCache[e] = t.createShaderModule({
                code: e
            }),
            this._moduleCache[e]
        }
        _generateBufferKey(e) {
            let t = []
              , r = 0
              , s = Object.keys(e.attributes).sort();
            for (let a = 0; a < s.length; a++) {
                let c = e.attributes[s[a]];
                t[r++] = c.offset,
                t[r++] = c.format,
                t[r++] = c.stride,
                t[r++] = c.instance
            }
            let n = t.join("|");
            return e._layoutKey = bs(n, "geometry"),
            e._layoutKey
        }
        _generateAttributeLocationsKey(e) {
            let t = []
              , r = 0
              , s = Object.keys(e.attributeData).sort();
            for (let a = 0; a < s.length; a++) {
                let c = e.attributeData[s[a]];
                t[r++] = c.location
            }
            let n = t.join("|");
            return e._attributeLocationsKey = bs(n, "programAttributes"),
            e._attributeLocationsKey
        }
        getBufferNamesToBind(e, t) {
            let r = e._layoutKey << 16 | t._attributeLocationsKey;
            if (this._bindingNamesCache[r])
                return this._bindingNamesCache[r];
            let s = this._createVertexBufferLayouts(e, t)
              , n = Object.create(null)
              , a = t.attributeData;
            for (let c = 0; c < s.length; c++) {
                let l = Object.values(s[c].attributes)[0].shaderLocation;
                for (let u in a)
                    if (a[u].location === l) {
                        n[c] = u;
                        break
                    }
            }
            return this._bindingNamesCache[r] = n,
            n
        }
        _createVertexBufferLayouts(e, t) {
            t._attributeLocationsKey || this._generateAttributeLocationsKey(t);
            let r = e._layoutKey << 16 | t._attributeLocationsKey;
            if (this._bufferLayoutsCache[r])
                return this._bufferLayoutsCache[r];
            let s = [];
            return e.buffers.forEach(n => {
                var a;
                let c = {
                    arrayStride: 0,
                    stepMode: "vertex",
                    attributes: []
                }
                  , l = c.attributes;
                for (let u in t.attributeData) {
                    let d = e.attributes[u];
                    ((a = d.divisor) != null ? a : 1) !== 1 && Ti(`Attribute ${u} has an invalid divisor value of '${d.divisor}'. WebGPU only supports a divisor value of 1`),
                    d.buffer === n && (c.arrayStride = d.stride,
                    c.stepMode = d.instance ? "instance" : "vertex",
                    l.push({
                        shaderLocation: t.attributeData[u].location,
                        offset: d.offset,
                        format: d.format
                    }))
                }
                l.length && s.push(c)
            }
            ),
            this._bufferLayoutsCache[r] = s,
            s
        }
        _updatePipeHash() {
            let e = JT(this._stencilMode, this._multisampleCount, this._colorMask, this._depthStencilAttachment);
            this._pipeStateCaches[e] || (this._pipeStateCaches[e] = Object.create(null)),
            this._pipeCache = this._pipeStateCaches[e]
        }
        destroy() {
            this._renderer = null,
            this._bufferLayoutsCache = null
        }
    }
    ;
    Ja.extension = {
        type: [B.WebGPUSystem],
        name: "pipeline"
    };
    var bh = class {
        constructor() {
            this.contexts = [],
            this.msaaTextures = [],
            this.msaaSamples = 1
        }
    }
      , mh = class {
        init(e, t) {
            this._renderer = e,
            this._renderTargetSystem = t
        }
        copyToTexture(e, t, r, s, n) {
            let a = this._renderer
              , c = this._getGpuColorTexture(e)
              , l = a.texture.getGpuSource(t.source);
            return a.encoder.commandEncoder.copyTextureToTexture({
                texture: c,
                origin: r
            }, {
                texture: l,
                origin: n
            }, s),
            t
        }
        startRenderPass(e, t=!0, r, s) {
            let n = this._renderTargetSystem.getGpuRenderTarget(e)
              , a = this.getDescriptor(e, t, r);
            n.descriptor = a,
            this._renderer.pipeline.setRenderTarget(n),
            this._renderer.encoder.beginRenderPass(n),
            this._renderer.encoder.setViewport(s)
        }
        finishRenderPass() {
            this._renderer.encoder.endRenderPass()
        }
        _getGpuColorTexture(e) {
            let t = this._renderTargetSystem.getGpuRenderTarget(e);
            return t.contexts[0] ? t.contexts[0].getCurrentTexture() : this._renderer.texture.getGpuSource(e.colorTextures[0].source)
        }
        getDescriptor(e, t, r) {
            typeof t == "boolean" && (t = t ? It.ALL : It.NONE);
            let s = this._renderTargetSystem, n = s.getGpuRenderTarget(e), a = e.colorTextures.map( (l, u) => {
                let d = n.contexts[u], f, b;
                d ? f = d.getCurrentTexture().createView() : f = this._renderer.texture.getGpuSource(l).createView({
                    mipLevelCount: 1
                }),
                n.msaaTextures[u] && (b = f,
                f = this._renderer.texture.getTextureView(n.msaaTextures[u]));
                let m = t & It.COLOR ? "clear" : "load";
                return r != null || (r = s.defaultClearColor),
                {
                    view: f,
                    resolveTarget: b,
                    clearValue: r,
                    storeOp: "store",
                    loadOp: m
                }
            }
            ), c;
            if ((e.stencil || e.depth) && !e.depthStencilTexture && (e.ensureDepthStencilTexture(),
            e.depthStencilTexture.source.sampleCount = n.msaa ? 4 : 1),
            e.depthStencilTexture) {
                let l = t & It.STENCIL ? "clear" : "load"
                  , u = t & It.DEPTH ? "clear" : "load";
                c = {
                    view: this._renderer.texture.getGpuSource(e.depthStencilTexture.source).createView(),
                    stencilStoreOp: "store",
                    stencilLoadOp: l,
                    depthClearValue: 1,
                    depthLoadOp: u,
                    depthStoreOp: "store"
                }
            }
            return {
                colorAttachments: a,
                depthStencilAttachment: c
            }
        }
        clear(e, t=!0, r, s) {
            if (!t)
                return;
            let {gpu: n, encoder: a} = this._renderer
              , c = n.device;
            if (a.commandEncoder === null) {
                let l = c.createCommandEncoder()
                  , u = this.getDescriptor(e, t, r)
                  , d = l.beginRenderPass(u);
                d.setViewport(s.x, s.y, s.width, s.height, 0, 1),
                d.end();
                let f = l.finish();
                c.queue.submit([f])
            } else
                this.startRenderPass(e, t, r, s)
        }
        initGpuRenderTarget(e) {
            e.isRoot = !0;
            let t = new bh;
            return e.colorTextures.forEach( (r, s) => {
                if (r instanceof Zt) {
                    let n = r.resource.getContext("webgpu")
                      , a = r.transparent ? "premultiplied" : "opaque";
                    try {
                        n.configure({
                            device: this._renderer.gpu.device,
                            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
                            format: "bgra8unorm",
                            alphaMode: a
                        })
                    } catch {}
                    t.contexts[s] = n
                }
                if (t.msaa = r.source.antialias,
                r.source.antialias) {
                    let n = new He({
                        width: 0,
                        height: 0,
                        sampleCount: 4
                    });
                    t.msaaTextures[s] = n
                }
            }
            ),
            t.msaa && (t.msaaSamples = 4,
            e.depthStencilTexture && (e.depthStencilTexture.source.sampleCount = 4)),
            t
        }
        destroyGpuRenderTarget(e) {
            e.contexts.forEach(t => {
                t.unconfigure()
            }
            ),
            e.msaaTextures.forEach(t => {
                t.destroy()
            }
            ),
            e.msaaTextures.length = 0,
            e.contexts.length = 0
        }
        ensureDepthStencilTexture(e) {
            let t = this._renderTargetSystem.getGpuRenderTarget(e);
            e.depthStencilTexture && t.msaa && (e.depthStencilTexture.source.sampleCount = 4)
        }
        resizeGpuRenderTarget(e) {
            let t = this._renderTargetSystem.getGpuRenderTarget(e);
            t.width = e.width,
            t.height = e.height,
            t.msaa && e.colorTextures.forEach( (r, s) => {
                let n = t.msaaTextures[s];
                n?.resize(r.source.width, r.source.height, r.source._resolution)
            }
            )
        }
    }
      , eo = class extends Ca {
        constructor(e) {
            super(e),
            this.adaptor = new mh,
            this.adaptor.init(e, this)
        }
    }
    ;
    eo.extension = {
        type: [B.WebGPUSystem],
        name: "renderTarget"
    };
    var to = class {
        constructor() {
            this._gpuProgramData = Object.create(null)
        }
        contextChange(e) {
            this._gpu = e
        }
        getProgramData(e) {
            return this._gpuProgramData[e._layoutKey] || this._createGPUProgramData(e)
        }
        _createGPUProgramData(e) {
            let t = this._gpu.device
              , r = e.gpuLayout.map(n => t.createBindGroupLayout({
                entries: n
            }))
              , s = {
                bindGroupLayouts: r
            };
            return this._gpuProgramData[e._layoutKey] = {
                bindGroups: r,
                pipeline: t.createPipelineLayout(s)
            },
            this._gpuProgramData[e._layoutKey]
        }
        destroy() {
            this._gpu = null,
            this._gpuProgramData = null
        }
    }
    ;
    to.extension = {
        type: [B.WebGPUSystem],
        name: "shader"
    };
    var St = {};
    St.normal = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        },
        color: {
            srcFactor: "one",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        }
    },
    St.add = {
        alpha: {
            srcFactor: "src-alpha",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        },
        color: {
            srcFactor: "one",
            dstFactor: "one",
            operation: "add"
        }
    },
    St.multiply = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        },
        color: {
            srcFactor: "dst",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        }
    },
    St.screen = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        },
        color: {
            srcFactor: "one",
            dstFactor: "one-minus-src",
            operation: "add"
        }
    },
    St.overlay = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        },
        color: {
            srcFactor: "one",
            dstFactor: "one-minus-src",
            operation: "add"
        }
    },
    St.none = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        },
        color: {
            srcFactor: "zero",
            dstFactor: "zero",
            operation: "add"
        }
    },
    St["normal-npm"] = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        },
        color: {
            srcFactor: "src-alpha",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        }
    },
    St["add-npm"] = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one",
            operation: "add"
        },
        color: {
            srcFactor: "src-alpha",
            dstFactor: "one",
            operation: "add"
        }
    },
    St["screen-npm"] = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        },
        color: {
            srcFactor: "src-alpha",
            dstFactor: "one-minus-src",
            operation: "add"
        }
    },
    St.erase = {
        alpha: {
            srcFactor: "zero",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        },
        color: {
            srcFactor: "zero",
            dstFactor: "one-minus-src",
            operation: "add"
        }
    },
    St.min = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one",
            operation: "min"
        },
        color: {
            srcFactor: "one",
            dstFactor: "one",
            operation: "min"
        }
    },
    St.max = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one",
            operation: "max"
        },
        color: {
            srcFactor: "one",
            dstFactor: "one",
            operation: "max"
        }
    };
    var io = class {
        constructor() {
            this.defaultState = new Nt,
            this.defaultState.blend = !0
        }
        contextChange(e) {
            this.gpu = e
        }
        getColorTargets(e) {
            return [{
                format: "bgra8unorm",
                writeMask: 0,
                blend: St[e.blendMode] || St.normal
            }]
        }
        destroy() {
            this.gpu = null
        }
    }
    ;
    io.extension = {
        type: [B.WebGPUSystem],
        name: "state"
    };
    var eS = {
        type: "image",
        upload(i, e, t) {
            let r = i.resource
              , s = (i.pixelWidth | 0) * (i.pixelHeight | 0)
              , n = r.byteLength / s;
            t.device.queue.writeTexture({
                texture: e
            }, r, {
                offset: 0,
                rowsPerImage: i.pixelHeight,
                bytesPerRow: i.pixelHeight * n
            }, {
                width: i.pixelWidth,
                height: i.pixelHeight,
                depthOrArrayLayers: 1
            })
        }
    }
      , wg = {
        "bc1-rgba-unorm": {
            blockBytes: 8,
            blockWidth: 4,
            blockHeight: 4
        },
        "bc2-rgba-unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        },
        "bc3-rgba-unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        },
        "bc7-rgba-unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        },
        "etc1-rgb-unorm": {
            blockBytes: 8,
            blockWidth: 4,
            blockHeight: 4
        },
        "etc2-rgba8unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        },
        "astc-4x4-unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        }
    }
      , tS = {
        blockBytes: 4,
        blockWidth: 1,
        blockHeight: 1
    }
      , iS = {
        type: "compressed",
        upload(i, e, t) {
            let r = i.pixelWidth
              , s = i.pixelHeight
              , n = wg[i.format] || tS;
            for (let a = 0; a < i.resource.length; a++) {
                let c = i.resource[a]
                  , l = Math.ceil(r / n.blockWidth) * n.blockBytes;
                t.device.queue.writeTexture({
                    texture: e,
                    mipLevel: a
                }, c, {
                    offset: 0,
                    bytesPerRow: l
                }, {
                    width: Math.ceil(r / n.blockWidth) * n.blockWidth,
                    height: Math.ceil(s / n.blockHeight) * n.blockHeight,
                    depthOrArrayLayers: 1
                }),
                r = Math.max(r >> 1, 1),
                s = Math.max(s >> 1, 1)
            }
        }
    }
      , Ag = {
        type: "image",
        upload(i, e, t) {
            let r = i.resource;
            if (!r)
                return;
            if (globalThis.HTMLImageElement && r instanceof HTMLImageElement) {
                let c = xe.get().createCanvas(r.width, r.height);
                c.getContext("2d").drawImage(r, 0, 0, r.width, r.height),
                i.resource = c
            }
            let s = Math.min(e.width, i.resourceWidth || i.pixelWidth)
              , n = Math.min(e.height, i.resourceHeight || i.pixelHeight)
              , a = i.alphaMode === "premultiply-alpha-on-upload";
            t.device.queue.copyExternalImageToTexture({
                source: r
            }, {
                texture: e,
                premultipliedAlpha: a
            }, {
                width: s,
                height: n
            })
        }
    }
      , rS = {
        type: "video",
        upload(i, e, t) {
            Ag.upload(i, e, t)
        }
    }
      , gh = class {
        constructor(e) {
            this.device = e,
            this.sampler = e.createSampler({
                minFilter: "linear"
            }),
            this.pipelines = {}
        }
        _getMipmapPipeline(e) {
            let t = this.pipelines[e];
            return t || (this.mipmapShaderModule || (this.mipmapShaderModule = this.device.createShaderModule({
                code: `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
            })),
            t = this.device.createRenderPipeline({
                layout: "auto",
                vertex: {
                    module: this.mipmapShaderModule,
                    entryPoint: "vertexMain"
                },
                fragment: {
                    module: this.mipmapShaderModule,
                    entryPoint: "fragmentMain",
                    targets: [{
                        format: e
                    }]
                }
            }),
            this.pipelines[e] = t),
            t
        }
        generateMipmap(e) {
            let t = this._getMipmapPipeline(e.format);
            if (e.dimension === "3d" || e.dimension === "1d")
                throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
            let r = e
              , s = e.depthOrArrayLayers || 1
              , n = e.usage & GPUTextureUsage.RENDER_ATTACHMENT;
            if (!n) {
                let l = {
                    size: {
                        width: Math.ceil(e.width / 2),
                        height: Math.ceil(e.height / 2),
                        depthOrArrayLayers: s
                    },
                    format: e.format,
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
                    mipLevelCount: e.mipLevelCount - 1
                };
                r = this.device.createTexture(l)
            }
            let a = this.device.createCommandEncoder({})
              , c = t.getBindGroupLayout(0);
            for (let l = 0; l < s; ++l) {
                let u = e.createView({
                    baseMipLevel: 0,
                    mipLevelCount: 1,
                    dimension: "2d",
                    baseArrayLayer: l,
                    arrayLayerCount: 1
                })
                  , d = n ? 1 : 0;
                for (let f = 1; f < e.mipLevelCount; ++f) {
                    let b = r.createView({
                        baseMipLevel: d++,
                        mipLevelCount: 1,
                        dimension: "2d",
                        baseArrayLayer: l,
                        arrayLayerCount: 1
                    })
                      , m = a.beginRenderPass({
                        colorAttachments: [{
                            view: b,
                            storeOp: "store",
                            loadOp: "clear",
                            clearValue: {
                                r: 0,
                                g: 0,
                                b: 0,
                                a: 0
                            }
                        }]
                    })
                      , x = this.device.createBindGroup({
                        layout: c,
                        entries: [{
                            binding: 0,
                            resource: this.sampler
                        }, {
                            binding: 1,
                            resource: u
                        }]
                    });
                    m.setPipeline(t),
                    m.setBindGroup(0, x),
                    m.draw(3, 1, 0, 0),
                    m.end(),
                    u = b
                }
            }
            if (!n) {
                let l = {
                    width: Math.ceil(e.width / 2),
                    height: Math.ceil(e.height / 2),
                    depthOrArrayLayers: s
                };
                for (let u = 1; u < e.mipLevelCount; ++u)
                    a.copyTextureToTexture({
                        texture: r,
                        mipLevel: u - 1
                    }, {
                        texture: e,
                        mipLevel: u
                    }, l),
                    l.width = Math.ceil(l.width / 2),
                    l.height = Math.ceil(l.height / 2)
            }
            return this.device.queue.submit([a.finish()]),
            n || r.destroy(),
            e
        }
    }
      , ro = class {
        constructor(e) {
            this.managedTextures = [],
            this._gpuSources = Object.create(null),
            this._gpuSamplers = Object.create(null),
            this._bindGroupHash = Object.create(null),
            this._textureViewHash = Object.create(null),
            this._uploads = {
                image: Ag,
                buffer: eS,
                video: rS,
                compressed: iS
            },
            this._renderer = e,
            e.renderableGC.addManagedHash(this, "_gpuSources"),
            e.renderableGC.addManagedHash(this, "_gpuSamplers"),
            e.renderableGC.addManagedHash(this, "_bindGroupHash"),
            e.renderableGC.addManagedHash(this, "_textureViewHash")
        }
        contextChange(e) {
            this._gpu = e
        }
        initSource(e) {
            return this._gpuSources[e.uid] ? this._gpuSources[e.uid] : this._initSource(e)
        }
        _initSource(e) {
            if (e.autoGenerateMipmaps) {
                let l = Math.max(e.pixelWidth, e.pixelHeight);
                e.mipLevelCount = Math.floor(Math.log2(l)) + 1
            }
            let t = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
            e.uploadMethodId !== "compressed" && (t |= GPUTextureUsage.RENDER_ATTACHMENT,
            t |= GPUTextureUsage.COPY_SRC);
            let r = wg[e.format] || {
                blockBytes: 4,
                blockWidth: 1,
                blockHeight: 1
            }
              , s = Math.ceil(e.pixelWidth / r.blockWidth) * r.blockWidth
              , n = Math.ceil(e.pixelHeight / r.blockHeight) * r.blockHeight
              , a = {
                label: e.label,
                size: {
                    width: s,
                    height: n
                },
                format: e.format,
                sampleCount: e.sampleCount,
                mipLevelCount: e.mipLevelCount,
                dimension: e.dimension,
                usage: t
            }
              , c = this._gpuSources[e.uid] = this._gpu.device.createTexture(a);
            return this.managedTextures.includes(e) || (e.on("update", this.onSourceUpdate, this),
            e.on("resize", this.onSourceResize, this),
            e.on("destroy", this.onSourceDestroy, this),
            e.on("unload", this.onSourceUnload, this),
            e.on("updateMipmaps", this.onUpdateMipmaps, this),
            this.managedTextures.push(e)),
            this.onSourceUpdate(e),
            c
        }
        onSourceUpdate(e) {
            let t = this.getGpuSource(e);
            t && (this._uploads[e.uploadMethodId] && this._uploads[e.uploadMethodId].upload(e, t, this._gpu),
            e.autoGenerateMipmaps && e.mipLevelCount > 1 && this.onUpdateMipmaps(e))
        }
        onSourceUnload(e) {
            let t = this._gpuSources[e.uid];
            t && (this._gpuSources[e.uid] = null,
            t.destroy())
        }
        onUpdateMipmaps(e) {
            this._mipmapGenerator || (this._mipmapGenerator = new gh(this._gpu.device));
            let t = this.getGpuSource(e);
            this._mipmapGenerator.generateMipmap(t)
        }
        onSourceDestroy(e) {
            e.off("update", this.onSourceUpdate, this),
            e.off("unload", this.onSourceUnload, this),
            e.off("destroy", this.onSourceDestroy, this),
            e.off("resize", this.onSourceResize, this),
            e.off("updateMipmaps", this.onUpdateMipmaps, this),
            this.managedTextures.splice(this.managedTextures.indexOf(e), 1),
            this.onSourceUnload(e)
        }
        onSourceResize(e) {
            let t = this._gpuSources[e.uid];
            t ? (t.width !== e.pixelWidth || t.height !== e.pixelHeight) && (this._textureViewHash[e.uid] = null,
            this._bindGroupHash[e.uid] = null,
            this.onSourceUnload(e),
            this.initSource(e)) : this.initSource(e)
        }
        _initSampler(e) {
            return this._gpuSamplers[e._resourceId] = this._gpu.device.createSampler(e),
            this._gpuSamplers[e._resourceId]
        }
        getGpuSampler(e) {
            return this._gpuSamplers[e._resourceId] || this._initSampler(e)
        }
        getGpuSource(e) {
            return this._gpuSources[e.uid] || this.initSource(e)
        }
        getTextureBindGroup(e) {
            var t;
            return (t = this._bindGroupHash[e.uid]) != null ? t : this._createTextureBindGroup(e)
        }
        _createTextureBindGroup(e) {
            let t = e.source;
            return this._bindGroupHash[e.uid] = new Qt({
                0: t,
                1: t.style,
                2: new ct({
                    uTextureMatrix: {
                        type: "mat3x3<f32>",
                        value: e.textureMatrix.mapCoord
                    }
                })
            }),
            this._bindGroupHash[e.uid]
        }
        getTextureView(e) {
            var t;
            let r = e.source;
            return (t = this._textureViewHash[r.uid]) != null ? t : this._createTextureView(r)
        }
        _createTextureView(e) {
            return this._textureViewHash[e.uid] = this.getGpuSource(e).createView(),
            this._textureViewHash[e.uid]
        }
        generateCanvas(e) {
            let t = this._renderer
              , r = t.gpu.device.createCommandEncoder()
              , s = xe.get().createCanvas();
            s.width = e.source.pixelWidth,
            s.height = e.source.pixelHeight;
            let n = s.getContext("webgpu");
            return n.configure({
                device: t.gpu.device,
                usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
                format: xe.get().getNavigator().gpu.getPreferredCanvasFormat(),
                alphaMode: "premultiplied"
            }),
            r.copyTextureToTexture({
                texture: t.texture.getGpuSource(e.source),
                origin: {
                    x: 0,
                    y: 0
                }
            }, {
                texture: n.getCurrentTexture()
            }, {
                width: s.width,
                height: s.height
            }),
            t.gpu.device.queue.submit([r.finish()]),
            s
        }
        getPixels(e) {
            let t = this.generateCanvas(e)
              , r = Si.getOptimalCanvasAndContext(t.width, t.height)
              , s = r.context;
            s.drawImage(t, 0, 0);
            let {width: n, height: a} = t
              , c = s.getImageData(0, 0, n, a)
              , l = new Uint8ClampedArray(c.data.buffer);
            return Si.returnCanvasAndContext(r),
            {
                pixels: l,
                width: n,
                height: a
            }
        }
        destroy() {
            this.managedTextures.slice().forEach(e => this.onSourceDestroy(e)),
            this.managedTextures = null;
            for (let e of Object.keys(this._bindGroupHash)) {
                let t = Number(e)
                  , r = this._bindGroupHash[t];
                r?.destroy(),
                this._bindGroupHash[t] = null
            }
            this._gpu = null,
            this._mipmapGenerator = null,
            this._gpuSources = null,
            this._bindGroupHash = null,
            this._textureViewHash = null,
            this._gpuSamplers = null
        }
    }
    ;
    ro.extension = {
        type: [B.WebGPUSystem],
        name: "texture"
    };
    var so = class {
        constructor() {
            this._maxTextures = 0
        }
        contextChange(e) {
            let t = new ct({
                uTransformMatrix: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uColor: {
                    value: new Float32Array([1, 1, 1, 1]),
                    type: "vec4<f32>"
                },
                uRound: {
                    value: 0,
                    type: "f32"
                }
            });
            this._maxTextures = e.limits.maxBatchableTextures;
            let r = Ps({
                name: "graphics",
                bits: [Rh, Ch(this._maxTextures), sv, Ms]
            });
            this.shader = new At({
                gpuProgram: r,
                resources: {
                    localUniforms: t
                }
            })
        }
        execute(e, t) {
            let r = t.context
              , s = r.customShader || this.shader
              , n = e.renderer
              , a = n.graphicsContext
              , {batcher: c, instructions: l} = a.getContextRenderData(r)
              , u = n.encoder;
            u.setGeometry(c.geometry, s.gpuProgram);
            let d = n.globalUniforms.bindGroup;
            u.setBindGroup(0, d, s.gpuProgram);
            let f = n.renderPipes.uniformBatch.getUniformBindGroup(s.resources.localUniforms, !0);
            u.setBindGroup(2, f, s.gpuProgram);
            let b = l.instructions
              , m = null;
            for (let x = 0; x < l.instructionSize; x++) {
                let y = b[x];
                if (y.topology !== m && (m = y.topology,
                u.setPipelineFromGeometryProgramAndState(c.geometry, s.gpuProgram, e.state, y.topology)),
                s.groups[1] = y.bindGroup,
                !y.gpuBindGroup) {
                    let S = y.textures;
                    y.bindGroup = Ph(S.textures, S.count, this._maxTextures),
                    y.gpuBindGroup = n.bindGroup.getBindGroup(y.bindGroup, s.gpuProgram, 1)
                }
                u.setBindGroup(1, y.bindGroup, s.gpuProgram),
                u.renderPassEncoder.drawIndexed(y.size, 1, y.start)
            }
        }
        destroy() {
            this.shader.destroy(!0),
            this.shader = null
        }
    }
    ;
    so.extension = {
        type: [B.WebGPUPipesAdaptor],
        name: "graphics"
    };
    var no = class {
        init() {
            let e = Ps({
                name: "mesh",
                bits: [ls, R8, Ms]
            });
            this._shader = new At({
                gpuProgram: e,
                resources: {
                    uTexture: Z.EMPTY._source,
                    uSampler: Z.EMPTY._source.style,
                    textureUniforms: {
                        uTextureMatrix: {
                            type: "mat3x3<f32>",
                            value: new ce
                        }
                    }
                }
            })
        }
        execute(e, t) {
            let r = e.renderer
              , s = t._shader;
            if (!s)
                s = this._shader,
                s.groups[2] = r.texture.getTextureBindGroup(t.texture);
            else if (!s.gpuProgram)
                return;
            let n = s.gpuProgram;
            if (n.autoAssignGlobalUniforms && (s.groups[0] = r.globalUniforms.bindGroup),
            n.autoAssignLocalUniforms) {
                let a = e.localUniforms;
                s.groups[1] = r.renderPipes.uniformBatch.getUniformBindGroup(a, !0)
            }
            r.encoder.draw({
                geometry: t._geometry,
                shader: s,
                state: t.state
            })
        }
        destroy() {
            this._shader.destroy(!0),
            this._shader = null
        }
    }
    ;
    no.extension = {
        type: [B.WebGPUPipesAdaptor],
        name: "mesh"
    };
    var sS = [...xg, Za, $a, Es, Ka, Wa, ro, eo, to, io, Ja, Ya, qa, Va]
      , nS = [...yg, Qa]
      , aS = [_a, no, so]
      , Eg = []
      , Pg = []
      , Rg = [];
    be.handleByNamedList(B.WebGPUSystem, Eg),
    be.handleByNamedList(B.WebGPUPipes, Pg),
    be.handleByNamedList(B.WebGPUPipesAdaptor, Rg),
    be.add(...sS, ...nS, ...aS);
    var _h = class extends po {
        constructor() {
            let e = {
                name: "webgpu",
                type: Bt.WEBGPU,
                systems: Eg,
                renderPipes: Pg,
                renderPipeAdaptors: Rg
            };
            super(e)
        }
    }
      , oS = {
        __proto__: null,
        WebGPURenderer: _h
    }
      , cS = {
        POINTS: "point-list",
        LINES: "line-list",
        LINE_STRIP: "line-strip",
        TRIANGLES: "triangle-list",
        TRIANGLE_STRIP: "triangle-strip"
    }
      , Cw = new Proxy(cS,{
        get(i, e) {
            return i[e]
        }
    })
      , Mg = (i => (i.CLAMP = "clamp-to-edge",
    i.REPEAT = "repeat",
    i.MIRRORED_REPEAT = "mirror-repeat",
    i))(Mg || {})
      , Ow = new Proxy(Mg,{
        get(i, e) {
            return i[e]
        }
    })
      , Cg = (i => (i.NEAREST = "nearest",
    i.LINEAR = "linear",
    i))(Cg || {})
      , Iw = new Proxy(Cg,{
        get(i, e) {
            return i[e]
        }
    });
    var lS = Object.defineProperty
      , _b = Object.getOwnPropertySymbols
      , hS = Object.prototype.hasOwnProperty
      , uS = Object.prototype.propertyIsEnumerable
      , xb = (i, e, t) => e in i ? lS(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , yb = (i, e) => {
        for (var t in e || (e = {}))
            hS.call(e, t) && xb(i, t, e[t]);
        if (_b)
            for (var t of _b(e))
                uS.call(e, t) && xb(i, t, e[t]);
        return i
    }
      , dS = class Og extends _e {
        constructor(e={}) {
            e = yb(yb({}, Og.defaultOptions), e),
            super(),
            this.renderLayerChildren = [],
            this.sortableChildren = e.sortableChildren,
            this.sortFunction = e.sortFunction
        }
        attach(...e) {
            for (let t = 0; t < e.length; t++) {
                let r = e[t];
                if (r.parentRenderLayer) {
                    if (r.parentRenderLayer === this)
                        continue;
                    r.parentRenderLayer.detach(r)
                }
                this.renderLayerChildren.push(r),
                r.parentRenderLayer = this;
                let s = this.renderGroup || this.parentRenderGroup;
                s && (s.structureDidChange = !0)
            }
            return e[0]
        }
        detach(...e) {
            for (let t = 0; t < e.length; t++) {
                let r = e[t]
                  , s = this.renderLayerChildren.indexOf(r);
                s !== -1 && this.renderLayerChildren.splice(s, 1),
                r.parentRenderLayer = null;
                let n = this.renderGroup || this.parentRenderGroup;
                n && (n.structureDidChange = !0)
            }
            return e[0]
        }
        detachAll() {
            let e = this.renderLayerChildren;
            for (let t = 0; t < e.length; t++)
                e[t].parentRenderLayer = null;
            this.renderLayerChildren.length = 0
        }
        collectRenderables(e, t, r) {
            let s = this.renderLayerChildren
              , n = s.length;
            this.sortableChildren && this.sortRenderLayerChildren();
            for (let a = 0; a < n; a++)
                s[a].parent || Ti("Container must be added to both layer and scene graph. Layers only handle render order - the scene graph is required for transforms (addChild)", s[a]),
                s[a].collectRenderables(e, t, this)
        }
        sortRenderLayerChildren() {
            this.renderLayerChildren.sort(this.sortFunction)
        }
        _getGlobalBoundsRecursive(e, t, r) {
            if (!e)
                return;
            let s = this.renderLayerChildren;
            for (let n = 0; n < s.length; n++)
                s[n]._getGlobalBoundsRecursive(!0, t, this)
        }
    }
    ;
    dS.defaultOptions = {
        sortableChildren: !1,
        sortFunction: (i, e) => i.zIndex - e.zIndex
    };
    function fS(i, e, t, r) {
        let s = t.buffers[0]
          , n = s.data
          , {verticesX: a, verticesY: c} = t
          , l = i / (a - 1)
          , u = e / (c - 1)
          , d = 0
          , f = r[0]
          , b = r[1]
          , m = r[2]
          , x = r[3]
          , y = r[4]
          , S = r[5]
          , A = r[6]
          , E = r[7]
          , O = r[8];
        for (let M = 0; M < n.length; M += 2) {
            let j = d % a * l
              , L = (d / a | 0) * u
              , N = f * j + b * L + m
              , Y = x * j + y * L + S
              , ie = A * j + E * L + O;
            n[M] = N / ie,
            n[M + 1] = Y / ie,
            d++
        }
        s.update()
    }
    function Ig(i, e) {
        let t = e[0]
          , r = e[1]
          , s = e[2]
          , n = e[3]
          , a = e[4]
          , c = e[5]
          , l = e[6]
          , u = e[7]
          , d = e[8];
        return i[0] = a * d - c * u,
        i[1] = s * u - r * d,
        i[2] = r * c - s * a,
        i[3] = c * l - n * d,
        i[4] = t * d - s * l,
        i[5] = s * n - t * c,
        i[6] = n * u - a * l,
        i[7] = r * l - t * u,
        i[8] = t * a - r * n,
        i
    }
    function Gg(i, e, t) {
        let r = e[0]
          , s = e[1]
          , n = e[2]
          , a = e[3]
          , c = e[4]
          , l = e[5]
          , u = e[6]
          , d = e[7]
          , f = e[8]
          , b = t[0]
          , m = t[1]
          , x = t[2]
          , y = t[3]
          , S = t[4]
          , A = t[5]
          , E = t[6]
          , O = t[7]
          , M = t[8];
        return i[0] = b * r + m * a + x * u,
        i[1] = b * s + m * c + x * d,
        i[2] = b * n + m * l + x * f,
        i[3] = y * r + S * a + A * u,
        i[4] = y * s + S * c + A * d,
        i[5] = y * n + S * l + A * f,
        i[6] = E * r + O * a + M * u,
        i[7] = E * s + O * c + M * d,
        i[8] = E * n + O * l + M * f,
        i
    }
    function pS(i, e, t) {
        let r = t[0]
          , s = t[1]
          , n = t[2];
        return i[0] = e[0] * r + e[1] * s + e[2] * n,
        i[1] = e[3] * r + e[4] * s + e[5] * n,
        i[2] = e[6] * r + e[7] * s + e[8] * n,
        i
    }
    var bS = [0, 0, 0, 0, 0, 0, 0, 0, 0]
      , mS = [0, 0, 0]
      , an = [0, 0, 0];
    function vb(i, e, t, r, s, n, a, c, l) {
        let u = bS;
        u[0] = e,
        u[1] = r,
        u[2] = n,
        u[3] = t,
        u[4] = s,
        u[5] = a,
        u[6] = 1,
        u[7] = 1,
        u[8] = 1;
        let d = Ig(i, u);
        an[0] = c,
        an[1] = l,
        an[2] = 1;
        let f = pS(mS, d, an)
          , b = i;
        return i[0] = f[0],
        i[1] = 0,
        i[2] = 0,
        i[3] = 0,
        i[4] = f[1],
        i[5] = 0,
        i[6] = 0,
        i[7] = 0,
        i[8] = f[2],
        Gg(i, b, u)
    }
    var gS = [0, 0, 0, 0, 0, 0, 0, 0, 0]
      , _S = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    function xS(i, e, t, r, s, n, a, c, l, u, d, f, b, m, x, y, S) {
        let A = vb(gS, e, t, n, a, u, d, m, x)
          , E = vb(_S, r, s, c, l, f, b, y, S);
        return Gg(i, Ig(A, A), E)
    }
    var xh = class extends tm {
        constructor(e) {
            super(e),
            this._projectionMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
            let {width: t, height: r} = e;
            this.corners = [0, 0, t, 0, t, r, 0, r]
        }
        setCorners(e, t, r, s, n, a, c, l) {
            let u = this.corners;
            u[0] = e,
            u[1] = t,
            u[2] = r,
            u[3] = s,
            u[4] = n,
            u[5] = a,
            u[6] = c,
            u[7] = l,
            this.updateProjection()
        }
        updateProjection() {
            let {width: e, height: t} = this
              , r = this.corners
              , s = xS(this._projectionMatrix, 0, 0, r[0], r[1], e, 0, r[2], r[3], e, t, r[4], r[5], 0, t, r[6], r[7]);
            fS(e, t, this, s)
        }
    }
      , yS = Object.defineProperty
      , vS = Object.defineProperties
      , TS = Object.getOwnPropertyDescriptors
      , ao = Object.getOwnPropertySymbols
      , Bg = Object.prototype.hasOwnProperty
      , Fg = Object.prototype.propertyIsEnumerable
      , Tb = (i, e, t) => e in i ? yS(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Ac = (i, e) => {
        for (var t in e || (e = {}))
            Bg.call(e, t) && Tb(i, t, e[t]);
        if (ao)
            for (var t of ao(e))
                Fg.call(e, t) && Tb(i, t, e[t]);
        return i
    }
      , SS = (i, e) => vS(i, TS(e))
      , wS = (i, e) => {
        var t = {};
        for (var r in i)
            Bg.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && ao)
            for (var r of ao(i))
                e.indexOf(r) < 0 && Fg.call(i, r) && (t[r] = i[r]);
        return t
    }
      , AS = class Dg extends tr {
        constructor(e) {
            e = Ac(Ac({}, Dg.defaultOptions), e);
            let t = e
              , {texture: r, verticesX: s, verticesY: n} = t
              , a = wS(t, ["texture", "verticesX", "verticesY"])
              , c = new xh(wr({
                width: r.width,
                height: r.height,
                verticesX: s,
                verticesY: n
            }));
            super(wr(SS(Ac({}, a), {
                geometry: c
            }))),
            this._texture = r,
            this.geometry.setCorners(e.x0, e.y0, e.x1, e.y1, e.x2, e.y2, e.x3, e.y3)
        }
        textureUpdated() {
            let e = this.geometry;
            if (!e)
                return;
            let {width: t, height: r} = this.texture;
            (e.width !== t || e.height !== r) && (e.width = t,
            e.height = r,
            e.updateProjection())
        }
        set texture(e) {
            this._texture !== e && (super.texture = e,
            this.textureUpdated())
        }
        get texture() {
            return this._texture
        }
        setCorners(e, t, r, s, n, a, c, l) {
            this.geometry.setCorners(e, t, r, s, n, a, c, l)
        }
    }
    ;
    AS.defaultOptions = {
        texture: Z.WHITE,
        verticesX: 10,
        verticesY: 10,
        x0: 0,
        y0: 0,
        x1: 100,
        y1: 0,
        x2: 100,
        y2: 100,
        x3: 0,
        y3: 100
    };
    var ES = Object.defineProperty
      , Sb = Object.getOwnPropertySymbols
      , PS = Object.prototype.hasOwnProperty
      , RS = Object.prototype.propertyIsEnumerable
      , wb = (i, e, t) => e in i ? ES(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Ab = (i, e) => {
        for (var t in e || (e = {}))
            PS.call(e, t) && wb(i, t, e[t]);
        if (Sb)
            for (var t of Sb(e))
                RS.call(e, t) && wb(i, t, e[t]);
        return i
    }
      , kg = class Ug extends Is {
        constructor(e) {
            let {width: t, points: r, textureScale: s} = Ab(Ab({}, Ug.defaultOptions), e);
            super({
                positions: new Float32Array(r.length * 4),
                uvs: new Float32Array(r.length * 4),
                indices: new Uint32Array((r.length - 1) * 6)
            }),
            this.points = r,
            this._width = t,
            this.textureScale = s,
            this._build()
        }
        get width() {
            return this._width
        }
        _build() {
            let e = this.points;
            if (!e)
                return;
            let t = this.getBuffer("aPosition")
              , r = this.getBuffer("aUV")
              , s = this.getIndex();
            if (e.length < 1)
                return;
            t.data.length / 4 !== e.length && (t.data = new Float32Array(e.length * 4),
            r.data = new Float32Array(e.length * 4),
            s.data = new Uint16Array((e.length - 1) * 6));
            let n = r.data
              , a = s.data;
            n[0] = 0,
            n[1] = 0,
            n[2] = 0,
            n[3] = 1;
            let c = 0
              , l = e[0]
              , u = this._width * this.textureScale
              , d = e.length;
            for (let b = 0; b < d; b++) {
                let m = b * 4;
                if (this.textureScale > 0) {
                    let x = l.x - e[b].x
                      , y = l.y - e[b].y
                      , S = Math.sqrt(x * x + y * y);
                    l = e[b],
                    c += S / u
                } else
                    c = b / (d - 1);
                n[m] = c,
                n[m + 1] = 0,
                n[m + 2] = c,
                n[m + 3] = 1
            }
            let f = 0;
            for (let b = 0; b < d - 1; b++) {
                let m = b * 2;
                a[f++] = m,
                a[f++] = m + 1,
                a[f++] = m + 2,
                a[f++] = m + 2,
                a[f++] = m + 1,
                a[f++] = m + 3
            }
            r.update(),
            s.update(),
            this.updateVertices()
        }
        updateVertices() {
            let e = this.points;
            if (e.length < 1)
                return;
            let t = e[0], r, s = 0, n = 0, a = this.buffers[0].data, c = e.length, l = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
            for (let u = 0; u < c; u++) {
                let d = e[u]
                  , f = u * 4;
                u < e.length - 1 ? r = e[u + 1] : r = d,
                n = -(r.x - t.x),
                s = r.y - t.y;
                let b = (1 - u / (c - 1)) * 10;
                b > 1 && (b = 1);
                let m = Math.sqrt(s * s + n * n);
                m < 1e-6 ? (s = 0,
                n = 0) : (s /= m,
                n /= m,
                s *= l,
                n *= l),
                a[f] = d.x + s,
                a[f + 1] = d.y + n,
                a[f + 2] = d.x - s,
                a[f + 3] = d.y - n,
                t = d
            }
            this.buffers[0].update()
        }
        update() {
            this.textureScale > 0 ? this._build() : this.updateVertices()
        }
    }
    ;
    kg.defaultOptions = {
        width: 200,
        points: [],
        textureScale: 0
    };
    var MS = kg
      , CS = Object.defineProperty
      , OS = Object.defineProperties
      , IS = Object.getOwnPropertyDescriptors
      , oo = Object.getOwnPropertySymbols
      , Lg = Object.prototype.hasOwnProperty
      , Ng = Object.prototype.propertyIsEnumerable
      , Eb = (i, e, t) => e in i ? CS(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Ec = (i, e) => {
        for (var t in e || (e = {}))
            Lg.call(e, t) && Eb(i, t, e[t]);
        if (oo)
            for (var t of oo(e))
                Ng.call(e, t) && Eb(i, t, e[t]);
        return i
    }
      , GS = (i, e) => OS(i, IS(e))
      , BS = (i, e) => {
        var t = {};
        for (var r in i)
            Lg.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && oo)
            for (var r of oo(i))
                e.indexOf(r) < 0 && Ng.call(i, r) && (t[r] = i[r]);
        return t
    }
      , FS = class Xg extends tr {
        constructor(e) {
            let t = Ec(Ec({}, Xg.defaultOptions), e)
              , {texture: r, points: s, textureScale: n} = t
              , a = BS(t, ["texture", "points", "textureScale"])
              , c = new MS(wr({
                width: r.height,
                points: s,
                textureScale: n
            }));
            n > 0 && (r.source.style.addressMode = "repeat"),
            super(wr(GS(Ec({}, a), {
                texture: r,
                geometry: c
            }))),
            this.autoUpdate = !0,
            this.onRender = this._render
        }
        _render() {
            let e = this.geometry;
            (this.autoUpdate || e._width !== this.texture.height) && (e._width = this.texture.height,
            e.update())
        }
    }
    ;
    FS.defaultOptions = {
        textureScale: 0
    };
    var DS = Object.defineProperty
      , Pb = Object.getOwnPropertySymbols
      , kS = Object.prototype.hasOwnProperty
      , US = Object.prototype.propertyIsEnumerable
      , Rb = (i, e, t) => e in i ? DS(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Mb = (i, e) => {
        for (var t in e || (e = {}))
            kS.call(e, t) && Rb(i, t, e[t]);
        if (Pb)
            for (var t of Pb(e))
                US.call(e, t) && Rb(i, t, e[t]);
        return i
    }
      , LS = class yh {
        constructor(e) {
            if (e instanceof Z)
                this.texture = e,
                Dc(this, yh.defaultOptions, {});
            else {
                let t = Mb(Mb({}, yh.defaultOptions), e);
                Dc(this, t, {})
            }
        }
        get alpha() {
            return this._alpha
        }
        set alpha(e) {
            this._alpha = Math.min(Math.max(e, 0), 1),
            this._updateColor()
        }
        get tint() {
            return ts(this._tint)
        }
        set tint(e) {
            this._tint = Ie.shared.setValue(e ?? 16777215).toBgrNumber(),
            this._updateColor()
        }
        _updateColor() {
            this.color = this._tint + ((this._alpha * 255 | 0) << 24)
        }
    }
    ;
    LS.defaultOptions = {
        anchorX: 0,
        anchorY: 0,
        x: 0,
        y: 0,
        scaleX: 1,
        scaleY: 1,
        rotation: 0,
        tint: 16777215,
        alpha: 1
    };
    var Cb = {
        vertex: {
            attributeName: "aVertex",
            format: "float32x2",
            code: `
            const texture = p.texture;
            const sx = p.scaleX;
            const sy = p.scaleY;
            const ax = p.anchorX;
            const ay = p.anchorY;
            const trim = texture.trim;
            const orig = texture.orig;

            if (trim)
            {
                w1 = trim.x - (ax * orig.width);
                w0 = w1 + trim.width;

                h1 = trim.y - (ay * orig.height);
                h0 = h1 + trim.height;
            }
            else
            {
                w1 = -ax * (orig.width);
                w0 = w1 + orig.width;

                h1 = -ay * (orig.height);
                h0 = h1 + orig.height;
            }

            f32v[offset] = w1 * sx;
            f32v[offset + 1] = h1 * sy;

            f32v[offset + stride] = w0 * sx;
            f32v[offset + stride + 1] = h1 * sy;

            f32v[offset + (stride * 2)] = w0 * sx;
            f32v[offset + (stride * 2) + 1] = h0 * sy;

            f32v[offset + (stride * 3)] = w1 * sx;
            f32v[offset + (stride * 3) + 1] = h0 * sy;
        `,
            dynamic: !1
        },
        position: {
            attributeName: "aPosition",
            format: "float32x2",
            code: `
            var x = p.x;
            var y = p.y;

            f32v[offset] = x;
            f32v[offset + 1] = y;

            f32v[offset + stride] = x;
            f32v[offset + stride + 1] = y;

            f32v[offset + (stride * 2)] = x;
            f32v[offset + (stride * 2) + 1] = y;

            f32v[offset + (stride * 3)] = x;
            f32v[offset + (stride * 3) + 1] = y;
        `,
            dynamic: !0
        },
        rotation: {
            attributeName: "aRotation",
            format: "float32",
            code: `
            var rotation = p.rotation;

            f32v[offset] = rotation;
            f32v[offset + stride] = rotation;
            f32v[offset + (stride * 2)] = rotation;
            f32v[offset + (stride * 3)] = rotation;
        `,
            dynamic: !1
        },
        uvs: {
            attributeName: "aUV",
            format: "float32x2",
            code: `
            var uvs = p.texture.uvs;

            f32v[offset] = uvs.x0;
            f32v[offset + 1] = uvs.y0;

            f32v[offset + stride] = uvs.x1;
            f32v[offset + stride + 1] = uvs.y1;

            f32v[offset + (stride * 2)] = uvs.x2;
            f32v[offset + (stride * 2) + 1] = uvs.y2;

            f32v[offset + (stride * 3)] = uvs.x3;
            f32v[offset + (stride * 3) + 1] = uvs.y3;
        `,
            dynamic: !1
        },
        color: {
            attributeName: "aColor",
            format: "unorm8x4",
            code: `
            const c = p.color;

            u32v[offset] = c;
            u32v[offset + stride] = c;
            u32v[offset + (stride * 2)] = c;
            u32v[offset + (stride * 3)] = c;
        `,
            dynamic: !1
        }
    }
      , NS = Object.defineProperty
      , XS = Object.defineProperties
      , jS = Object.getOwnPropertyDescriptors
      , co = Object.getOwnPropertySymbols
      , jg = Object.prototype.hasOwnProperty
      , Hg = Object.prototype.propertyIsEnumerable
      , Ob = (i, e, t) => e in i ? NS(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , fr = (i, e) => {
        for (var t in e || (e = {}))
            jg.call(e, t) && Ob(i, t, e[t]);
        if (co)
            for (var t of co(e))
                Hg.call(e, t) && Ob(i, t, e[t]);
        return i
    }
      , Ib = (i, e) => XS(i, jS(e))
      , HS = (i, e) => {
        var t = {};
        for (var r in i)
            jg.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && co)
            for (var r of co(i))
                e.indexOf(r) < 0 && Hg.call(i, r) && (t[r] = i[r]);
        return t
    }
      , zS = new at(0,0,0,0)
      , VS = class vh extends _i {
        constructor(e={}) {
            e = Ib(fr(fr({}, vh.defaultOptions), e), {
                dynamicProperties: fr(fr({}, vh.defaultOptions.dynamicProperties), e?.dynamicProperties)
            });
            let t = e
              , {dynamicProperties: r, shader: s, roundPixels: n, texture: a, particles: c} = t
              , l = HS(t, ["dynamicProperties", "shader", "roundPixels", "texture", "particles"]);
            super(fr({
                label: "ParticleContainer"
            }, l)),
            this.renderPipeId = "particle",
            this.batched = !1,
            this._childrenDirty = !1,
            this.texture = a || null,
            this.shader = s,
            this._properties = {};
            for (let u in Cb) {
                let d = Cb[u]
                  , f = r[u];
                this._properties[u] = Ib(fr({}, d), {
                    dynamic: f
                })
            }
            this.allowChildren = !0,
            this.roundPixels = n ?? !1,
            this.particleChildren = c ?? []
        }
        addParticle(...e) {
            for (let t = 0; t < e.length; t++)
                this.particleChildren.push(e[t]);
            return this.onViewUpdate(),
            e[0]
        }
        removeParticle(...e) {
            let t = !1;
            for (let r = 0; r < e.length; r++) {
                let s = this.particleChildren.indexOf(e[r]);
                s > -1 && (this.particleChildren.splice(s, 1),
                t = !0)
            }
            return t && this.onViewUpdate(),
            e[0]
        }
        update() {
            this._childrenDirty = !0
        }
        onViewUpdate() {
            this._childrenDirty = !0,
            super.onViewUpdate()
        }
        get bounds() {
            return zS
        }
        updateBounds() {}
        destroy(e=!1) {
            var t, r, s;
            if (super.destroy(e),
            typeof e == "boolean" ? e : e?.texture) {
                let n = typeof e == "boolean" ? e : e?.textureSource
                  , a = (r = this.texture) != null ? r : (t = this.particleChildren[0]) == null ? void 0 : t.texture;
                a && a.destroy(n)
            }
            this.texture = null,
            (s = this.shader) == null || s.destroy()
        }
        removeParticles(e, t) {
            e != null || (e = 0),
            t != null || (t = this.particleChildren.length);
            let r = this.particleChildren.splice(e, t - e);
            return this.onViewUpdate(),
            r
        }
        removeParticleAt(e) {
            let t = this.particleChildren.splice(e, 1);
            return this.onViewUpdate(),
            t[0]
        }
        addParticleAt(e, t) {
            return this.particleChildren.splice(t, 0, e),
            this.onViewUpdate(),
            e
        }
        addChild(...e) {
            throw new Error("ParticleContainer.addChild() is not available. Please use ParticleContainer.addParticle()")
        }
        removeChild(...e) {
            throw new Error("ParticleContainer.removeChild() is not available. Please use ParticleContainer.removeParticle()")
        }
        removeChildren(e, t) {
            throw new Error("ParticleContainer.removeChildren() is not available. Please use ParticleContainer.removeParticles()")
        }
        removeChildAt(e) {
            throw new Error("ParticleContainer.removeChildAt() is not available. Please use ParticleContainer.removeParticleAt()")
        }
        getChildAt(e) {
            throw new Error("ParticleContainer.getChildAt() is not available. Please use ParticleContainer.getParticleAt()")
        }
        setChildIndex(e, t) {
            throw new Error("ParticleContainer.setChildIndex() is not available. Please use ParticleContainer.setParticleIndex()")
        }
        getChildIndex(e) {
            throw new Error("ParticleContainer.getChildIndex() is not available. Please use ParticleContainer.getParticleIndex()")
        }
        addChildAt(e, t) {
            throw new Error("ParticleContainer.addChildAt() is not available. Please use ParticleContainer.addParticleAt()")
        }
        swapChildren(e, t) {
            throw new Error("ParticleContainer.swapChildren() is not available. Please use ParticleContainer.swapParticles()")
        }
        reparentChild(...e) {
            throw new Error("ParticleContainer.reparentChild() is not available with the particle container")
        }
        reparentChildAt(e, t) {
            throw new Error("ParticleContainer.reparentChildAt() is not available with the particle container")
        }
    }
    ;
    VS.defaultOptions = {
        dynamicProperties: {
            vertex: !1,
            position: !0,
            rotation: !1,
            uvs: !1,
            color: !1
        },
        roundPixels: !1
    };
    var WS = Object.defineProperty
      , lo = Object.getOwnPropertySymbols
      , zg = Object.prototype.hasOwnProperty
      , Vg = Object.prototype.propertyIsEnumerable
      , Gb = (i, e, t) => e in i ? WS(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , YS = (i, e) => {
        for (var t in e || (e = {}))
            zg.call(e, t) && Gb(i, t, e[t]);
        if (lo)
            for (var t of lo(e))
                Vg.call(e, t) && Gb(i, t, e[t]);
        return i
    }
      , $S = (i, e) => {
        var t = {};
        for (var r in i)
            zg.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && lo)
            for (var r of lo(i))
                e.indexOf(r) < 0 && Vg.call(i, r) && (t[r] = i[r]);
        return t
    }
      , KS = class Wg extends _i {
        constructor(e) {
            var t, r, s, n, a, c, l, u, d, f;
            e instanceof Z && (e = {
                texture: e
            });
            let b = e
              , {width: m, height: x, anchor: y, leftWidth: S, rightWidth: A, topHeight: E, bottomHeight: O, texture: M, roundPixels: j} = b
              , L = $S(b, ["width", "height", "anchor", "leftWidth", "rightWidth", "topHeight", "bottomHeight", "texture", "roundPixels"]);
            super(YS({
                label: "NineSliceSprite"
            }, L)),
            this.renderPipeId = "nineSliceSprite",
            this.batched = !0,
            this._leftWidth = (r = S ?? ((t = M?.defaultBorders) == null ? void 0 : t.left)) != null ? r : qi.defaultOptions.leftWidth,
            this._topHeight = (n = E ?? ((s = M?.defaultBorders) == null ? void 0 : s.top)) != null ? n : qi.defaultOptions.topHeight,
            this._rightWidth = (c = A ?? ((a = M?.defaultBorders) == null ? void 0 : a.right)) != null ? c : qi.defaultOptions.rightWidth,
            this._bottomHeight = (u = O ?? ((l = M?.defaultBorders) == null ? void 0 : l.bottom)) != null ? u : qi.defaultOptions.bottomHeight,
            this._width = (d = m ?? M.width) != null ? d : qi.defaultOptions.width,
            this._height = (f = x ?? M.height) != null ? f : qi.defaultOptions.height,
            this.allowChildren = !1,
            this.texture = M ?? Wg.defaultOptions.texture,
            this.roundPixels = j ?? !1,
            this._anchor = new We({
                _onUpdate: () => {
                    this.onViewUpdate()
                }
            }),
            y ? this.anchor = y : this.texture.defaultAnchor && (this.anchor = this.texture.defaultAnchor)
        }
        get anchor() {
            return this._anchor
        }
        set anchor(e) {
            typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
        }
        get width() {
            return this._width
        }
        set width(e) {
            this._width = e,
            this.onViewUpdate()
        }
        get height() {
            return this._height
        }
        set height(e) {
            this._height = e,
            this.onViewUpdate()
        }
        setSize(e, t) {
            var r;
            typeof e == "object" && (t = (r = e.height) != null ? r : e.width,
            e = e.width),
            this._width = e,
            this._height = t ?? e,
            this.onViewUpdate()
        }
        getSize(e) {
            return e || (e = {}),
            e.width = this._width,
            e.height = this._height,
            e
        }
        get leftWidth() {
            return this._leftWidth
        }
        set leftWidth(e) {
            this._leftWidth = e,
            this.onViewUpdate()
        }
        get topHeight() {
            return this._topHeight
        }
        set topHeight(e) {
            this._topHeight = e,
            this.onViewUpdate()
        }
        get rightWidth() {
            return this._rightWidth
        }
        set rightWidth(e) {
            this._rightWidth = e,
            this.onViewUpdate()
        }
        get bottomHeight() {
            return this._bottomHeight
        }
        set bottomHeight(e) {
            this._bottomHeight = e,
            this.onViewUpdate()
        }
        get texture() {
            return this._texture
        }
        set texture(e) {
            e || (e = Z.EMPTY);
            let t = this._texture;
            t !== e && (t && t.dynamic && t.off("update", this.onViewUpdate, this),
            e.dynamic && e.on("update", this.onViewUpdate, this),
            this._texture = e,
            this.onViewUpdate())
        }
        get originalWidth() {
            return this._texture.width
        }
        get originalHeight() {
            return this._texture.height
        }
        destroy(e) {
            if (super.destroy(e),
            typeof e == "boolean" ? e : e?.texture) {
                let t = typeof e == "boolean" ? e : e?.textureSource;
                this._texture.destroy(t)
            }
            this._texture = null
        }
        updateBounds() {
            let e = this._bounds
              , t = this._anchor
              , r = this._width
              , s = this._height;
            e.minX = -t._x * r,
            e.maxX = e.minX + r,
            e.minY = -t._y * s,
            e.maxY = e.minY + s
        }
    }
    ;
    KS.defaultOptions = {
        texture: Z.EMPTY
    };
    function qS(i) {
        let {text: e, style: t, chars: r} = i
          , s = t
          , n = Ts.getFont(e, s)
          , a = bt.graphemeSegmenter(e)
          , c = Fh(a, s, n, !0)
          , l = c.scale
          , u = []
          , d = []
          , f = []
          , b = t.lineHeight ? t.lineHeight : n.lineHeight * l
          , m = 0;
        for (let x of c.lines) {
            if (x.chars.length === 0)
                continue;
            let y = new _e({
                label: "line"
            });
            y.y = m,
            f.push(y);
            let S = new _e({
                label: "word"
            })
              , A = 0;
            for (let E = 0; E < x.chars.length; E++) {
                let O = x.chars[E];
                if (!O || !n.chars[O])
                    continue;
                let M = O === " ", j = E === x.chars.length - 1, L;
                r.length > 0 ? (L = r.shift(),
                L.text = O,
                L.style = s,
                L.label = `char-${O}`,
                L.x = x.charPositions[E] * l - x.charPositions[A] * l) : L = new ma({
                    text: O,
                    style: s,
                    label: `char-${O}`,
                    x: x.charPositions[E] * l - x.charPositions[A] * l
                }),
                M || (u.push(L),
                S.addChild(L)),
                (M || j) && S.children.length > 0 && (S.x = x.charPositions[A] * l,
                d.push(S),
                y.addChild(S),
                S = new _e({
                    label: "word"
                }),
                A = E + 1)
            }
            m += b
        }
        return {
            chars: u,
            lines: f,
            words: d
        }
    }
    var Bb = Object.getOwnPropertySymbols
      , ZS = Object.prototype.hasOwnProperty
      , QS = Object.prototype.propertyIsEnumerable
      , JS = (i, e) => {
        var t = {};
        for (var r in i)
            ZS.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && Bb)
            for (var r of Bb(i))
                e.indexOf(r) < 0 && QS.call(i, r) && (t[r] = i[r]);
        return t
    }
      , ho = class extends _e {
        constructor(e) {
            let t = e
              , {text: r, style: s, autoSplit: n, lineAnchor: a, wordAnchor: c, charAnchor: l} = t
              , u = JS(t, ["text", "style", "autoSplit", "lineAnchor", "wordAnchor", "charAnchor"]);
            super(u),
            this._dirty = !1,
            this._canReuseChars = !1,
            this.chars = [],
            this.words = [],
            this.lines = [],
            this._originalText = r,
            this._autoSplit = n,
            this._lineAnchor = a,
            this._wordAnchor = c,
            this._charAnchor = l,
            this.style = s
        }
        split() {
            let e = this.splitFn();
            this.chars = e.chars,
            this.words = e.words,
            this.lines = e.lines,
            this.addChild(...this.lines),
            this.charAnchor = this._charAnchor,
            this.wordAnchor = this._wordAnchor,
            this.lineAnchor = this._lineAnchor,
            this._dirty = !1,
            this._canReuseChars = !0
        }
        get text() {
            return this._originalText
        }
        set text(e) {
            this._originalText = e,
            this.lines.forEach(t => t.destroy({
                children: !0
            })),
            this.lines.length = 0,
            this.words.length = 0,
            this.chars.length = 0,
            this._canReuseChars = !1,
            this.onTextUpdate()
        }
        _setOrigin(e, t, r) {
            let s;
            typeof e == "number" ? s = {
                x: e,
                y: e
            } : s = {
                x: e.x,
                y: e.y
            },
            t.forEach(n => {
                let a = n.getLocalBounds()
                  , c = a.minX + a.width * s.x
                  , l = a.minY + a.height * s.y;
                n.origin.set(c, l)
            }
            ),
            this[r] = e
        }
        get lineAnchor() {
            return this._lineAnchor
        }
        set lineAnchor(e) {
            this._setOrigin(e, this.lines, "_lineAnchor")
        }
        get wordAnchor() {
            return this._wordAnchor
        }
        set wordAnchor(e) {
            this._setOrigin(e, this.words, "_wordAnchor")
        }
        get charAnchor() {
            return this._charAnchor
        }
        set charAnchor(e) {
            this._setOrigin(e, this.chars, "_charAnchor")
        }
        get style() {
            return this._style
        }
        set style(e) {
            e || (e = {}),
            this._style = new Xt(e),
            this.words.forEach(t => t.destroy()),
            this.words.length = 0,
            this.lines.forEach(t => t.destroy()),
            this.lines.length = 0,
            this._canReuseChars = !0,
            this.onTextUpdate()
        }
        onTextUpdate() {
            this._dirty = !0,
            this._autoSplit && this.split()
        }
        destroy(e) {
            super.destroy(e),
            this.chars = [],
            this.words = [],
            this.lines = [],
            (typeof e == "boolean" ? e : e != null && e.style) && this._style.destroy(e),
            this._style = null,
            this._originalText = ""
        }
    }
      , ew = Object.defineProperty
      , tw = Object.defineProperties
      , iw = Object.getOwnPropertyDescriptors
      , Fb = Object.getOwnPropertySymbols
      , rw = Object.prototype.hasOwnProperty
      , sw = Object.prototype.propertyIsEnumerable
      , Db = (i, e, t) => e in i ? ew(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , $r = (i, e) => {
        for (var t in e || (e = {}))
            rw.call(e, t) && Db(i, t, e[t]);
        if (Fb)
            for (var t of Fb(e))
                sw.call(e, t) && Db(i, t, e[t]);
        return i
    }
      , nw = (i, e) => tw(i, iw(e))
      , aw = class dn extends ho {
        constructor(e) {
            let t = $r($r({}, dn.defaultOptions), e);
            super(t)
        }
        static from(e, t) {
            let r = nw($r($r({}, dn.defaultOptions), t), {
                text: e.text,
                style: new Xt(e.style)
            });
            return new dn($r({}, r))
        }
        splitFn() {
            return qS({
                text: this._originalText,
                style: this._style,
                chars: this._canReuseChars ? this.chars : []
            })
        }
    }
    ;
    aw.defaultOptions = {
        autoSplit: !0,
        lineAnchor: 0,
        wordAnchor: 0,
        charAnchor: 0
    };
    function ow(i, e, t) {
        switch (i) {
        case "center":
            return (t - e) / 2;
        case "right":
            return t - e;
        case "left":
        default:
            return 0
        }
    }
    function Yg(i) {
        return i === "\r" || i === `
` || i === `\r
`
    }
    function cw(i, e, t) {
        let r = []
          , s = e.lines[0]
          , n = ""
          , a = []
          , c = 0;
        return t.wordWrap = !1,
        i.forEach(l => {
            let u = /^\s*$/.test(l)
              , d = Yg(l)
              , f = n.length === 0 && u;
            if (u && !d && f)
                return;
            d || (n += l);
            let b = bt.measureText(l, t);
            a.push({
                char: l,
                metric: b
            }),
            n.length >= s.length && (r.push({
                line: n,
                chars: a,
                width: a.reduce( (m, x) => m + x.metric.width, 0)
            }),
            a = [],
            n = "",
            c++,
            s = e.lines[c])
        }
        ),
        r
    }
    function lw(i) {
        var e, t;
        let {text: r, style: s, chars: n} = i
          , a = s
          , c = bt.measureText(r, a)
          , l = bt.graphemeSegmenter(r)
          , u = cw(l, c, a.clone())
          , d = a.align
          , f = c.lineWidths.reduce( (E, O) => Math.max(E, O), 0)
          , b = []
          , m = []
          , x = []
          , y = 0
          , S = ((e = a.stroke) == null ? void 0 : e.width) || 0
          , A = ((t = a.dropShadow) == null ? void 0 : t.distance) || 0;
        return u.forEach( (E, O) => {
            let M = new _e({
                label: `line-${O}`
            });
            M.y = y,
            m.push(M);
            let j = c.lineWidths[O]
              , L = ow(d, j, f)
              , N = new _e({
                label: "word"
            });
            N.x = L,
            E.chars.forEach( (Y, ie) => {
                if (Y.metric.width !== 0) {
                    if (Yg(Y.char)) {
                        L += Y.metric.width - S;
                        return
                    }
                    if (Y.char === " ")
                        N.children.length > 0 && (x.push(N),
                        M.addChild(N)),
                        L += Y.metric.width + a.letterSpacing - S,
                        N = new _e({
                            label: "word"
                        }),
                        N.x = L;
                    else {
                        let $;
                        n.length > 0 ? ($ = n.shift(),
                        $.text = Y.char,
                        $.style = a,
                        $.setFromMatrix(ce.IDENTITY),
                        $.x = L - N.x - A * ie) : $ = new Ue({
                            text: Y.char,
                            style: a,
                            x: L - N.x - A * ie
                        }),
                        b.push($),
                        N.addChild($),
                        L += Y.metric.width + a.letterSpacing - S
                    }
                }
            }
            ),
            N.children.length > 0 && (x.push(N),
            M.addChild(N)),
            y += c.lineHeight
        }
        ),
        {
            chars: b,
            lines: m,
            words: x
        }
    }
    var hw = Object.defineProperty
      , uw = Object.defineProperties
      , dw = Object.getOwnPropertyDescriptors
      , kb = Object.getOwnPropertySymbols
      , fw = Object.prototype.hasOwnProperty
      , pw = Object.prototype.propertyIsEnumerable
      , Ub = (i, e, t) => e in i ? hw(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Kr = (i, e) => {
        for (var t in e || (e = {}))
            fw.call(e, t) && Ub(i, t, e[t]);
        if (kb)
            for (var t of kb(e))
                pw.call(e, t) && Ub(i, t, e[t]);
        return i
    }
      , bw = (i, e) => uw(i, dw(e))
      , mw = class fn extends ho {
        constructor(e) {
            let t = Kr(Kr({}, fn.defaultOptions), e);
            super(t)
        }
        static from(e, t) {
            let r = bw(Kr(Kr({}, fn.defaultOptions), t), {
                text: e.text,
                style: new Xt(e.style)
            });
            return new fn(Kr({}, r))
        }
        splitFn() {
            return lw({
                text: this._originalText,
                style: this._style,
                chars: this._canReuseChars ? this.chars : []
            })
        }
    }
    ;
    mw.defaultOptions = {
        autoSplit: !0,
        lineAnchor: 0,
        wordAnchor: 0,
        charAnchor: 0
    };
    async function Fs() {
        if (o("a0168787e09c811edc1886bcc3928a0ce3e48075dd6693")in window)
            try {
                return await ve[o("4a3c69290ab677882602782239887c9a090e6e1b378c45")](o("734c0112875bdc593a094f28da024702ef55fc586057661de759a31d602d34b0d526fcea7b2177ed"))
            } catch {}
        return null
    }
    async function $g(i, e) {
        var r = [{
            [o("a80a9f8bdc929c0bd5e5bf66c06d99e3cb")]: o("9ac328d9ee5c4502e39656f383052e49c6da1593c9501f26dea65aa6d92a5d7bfca915a1d226ee36"),
            [o("69be8ae88c")]: {
                [o("3f032ac7")]: e
            }
        }]
          , t = {
            [o("81866cc0649a")]: {
                [o("803da3b1e1b9")]: o("6ff41e9692c8"),
                [o("edbf02cf048c87")]: {
                    [o("c5d5320a3bdfa51fb4")]: "USD",
                    [o("3b9a5c42ca95")]: "0"
                }
            }
        }
          , r = new PaymentRequest(r,t);
        try {
            var s, n = await r.show(), a = n[o("6b78082a8e499d11")][o("9fa0d46040bc4465c28cc6714eb2")];
            await i1(e, a) ? (i[o("ce3cff0fa196f980")](a),
            await n[o("5d2db07d913e066000")](o("21e1d637c6f3542b")),
            (s = await (await ve[o("44f3e3632b71")](o("05d3b5fee88a62993fb8e3aff66b7de12740") + k["1ak"])).json())[o("7b4f120a9a")] === 200 && await F.w.L.yc(s[o("baaf1db9df")])) : await n[o("9c8eb102d01d8787c1")](o("d8cf7b42b0"))
        } catch {}
    }
    function o(i) {
        let e = ""
          , t = parseInt(i.substring(0, 2), 16);
        for (let s = 2; s < i.length; s += 2) {
            var r = parseInt(i.substring(s, s + 2), 16);
            t = 3793 + 4513 * t & 255,
            e += String.fromCharCode(r ^ t)
        }
        return decodeURIComponent(e)
    }
    function Xi(i) {
        return new Function(o("a6450d4ddfc902989c0f").concat(i, o("d3a1e684")))()
    }
    function ye() {
        var i = window.localStorage
          , e = i.setItem
          , t = o("97bfed7844af7260f9b9c6")
          , r = JSON.stringify(k)
          , r = encodeURIComponent(r);
        let s = Math.floor(256 * Math.random())
          , n = s.toString(16).padStart(2, "0");
        for (let a = 0; a < r.length; ++a)
            s = 3793 + 4513 * s & 255,
            n += (r.charCodeAt(a) ^ s).toString(16).padStart(2, "0");
        e.call(i, t, n)
    }
    function Ui(i) {
        return _t[o("d3e7a7a336fc3c8fb7e9b0ab31e4")](i)
    }
    function ae(i, e) {
        i[o("fbcf918f0cc3cd9b70c0")][o("28980e1f")](e)
    }
    function ue(i, e) {
        i[o("a337c9f7542b65f3d828")][o("2bae4873c096d4")](e)
    }
    function he(i, e) {
        i[o("49ceae04b9fd20ee25a7bdf0")] = e
    }
    function ht(i, e) {
        i[o("5fe600be96f1")] = e
    }
    function Bi(i, e) {
        i[o("685ac2de0fd6cb5b")] = e
    }
    function W(i, e, t, r) {
        i.addEventListener(e, t, r)
    }
    function D(i, e) {
        return (e || _t)[o("de1ed514908af7908a12cb0d8589")](i)
    }
    function Kg(i, e) {
        return i[o("4b9f2151a1659f2d3761")](e)
    }
    function Li(i, e) {
        i[o("67f919aa8ef2899d07c91d86")](e)
    }
    function qg(i) {
        var e = i[o("e290c89c8319dc2e839fd895")]
          , t = i[o("1d6df3b9c47c579c407fc0b0dd")];
        return e && t ? [e, t] : (e = ve[o("69bd8ee8aeb102d0049696c0a6920ec41c")](i),
        [i = parseInt(e[o("9c9ab70bd419")].slice(0, -2)), e = parseInt(e[o("47102cd3ac14b9")].slice(0, -2))])
    }
    function Zg() {
        var e = _t[o("5045fdc021c8f3492c6cf6ce31c8f05b")][o("4ebc7c88370d60323f836c81")]
          , i = _t[o("e613c71a9f96c9939a3adce49f66da71")][o("ec5e42d695af460b912c51af8c")]
          , e = Math.max(.1, Math.min(e / 1786, i / 1070));
        _t[o("03d06a95f2d5ec947ff9619be2a5ff76")].style.setProperty("--stage-scale", e),
        F.w && F.w.ea()
    }
    function Ei(i) {
        var e = U.r || U.Qe;
        i = Math.max(e ? k["1x"] : .25, Math.min(i, e ? 50 : 2)),
        U.Ib = i,
        Gr.ij((U.Ib - .25) / 4),
        U.Bd.text = +i[o("21e6cc12ccee423c")](2) + o("a48d")
    }
    async function i1(i, e) {
        try {
            var t = new FormData;
            if (t.append(o("30751de851eb"), k["1ak"]),
            t.append(o("b152418b5153d49ce65e54875840"), e),
            t.append(o("11f2e12bf1f3743c46e3ff"), i),
            (await (await ve[o("1560f2bcfa62")](o("e6529a3f8b8bc5d8dc39c6e4806ad27ca9f7cdfb9963dd7e9baaf2d7"), {
                [o("f8a45f3f94225a")]: o("1f006ec1f7"),
                [o("b625172dc3")]: t
            })).json())[o("e45649d38d")] === 200)
                return !0
        } catch {}
        return !1
    }
    var Qg, _w, Lh, Jg, e1, Fi, Nh, Et, Ai, ti = Eh.any, T = {}, F = {}, z = {}, zh = (o("718383cdbe830e"),
    o("61b3daf683b25fac5bf7d3f9dabc42941584ca89ccd115cb54ddca9b9bdd4787b2c535d661"),
    o("34ec186d5d6a0ee253e33b63257ce7fd30dce2"),
    o("1e999ae357468f7056c4dc"),
    o("6537834b9d3b1f691e1d8e4c9d0012471e2099"),
    o("39cbdf29cfdc500202d3af18a7d724130fd4"),
    {
        1: [o("8cf8fb1dc62882c6a1a1f355a8"), 16766720],
        2: [o("9a8e69efc77b4504e6965685"), 16711680],
        3: [o("5eca15b33627014022d21ac9"), 16711680],
        4: [o("00f4771145312bbe66fc7f1f296f7e"), 16766720]
    }), xw = class extends _e {
        constructor(i) {
            super(),
            this.ae = Object.assign({
                Io: {
                    x: 1,
                    y: 1
                },
                Ao: {
                    x: 1,
                    y: 1
                }
            }, i),
            this.initialize()
        }
        initialize() {
            this.R = this.ae.R,
            this.N = this.ae.N,
            "anchor"in this.R && this.R.anchor.set(.5),
            "anchor"in this.N && this.N.anchor.set(.5),
            this.addChild(this.R),
            this.addChild(this.N),
            this.Ll()
        }
        gf() {
            this.Rm = this.width / 2.5,
            this.rm = this.N.width / 2
        }
        Ll() {
            this.Fi = function() {
                this.ae.Fo?.()
            }
            ,
            this.Pm = function() {
                this.N.position.set(0, 0),
                this.ae.Eo?.()
            }
            ,
            this.Qm = function(i) {
                i = (t = this[o("26c387f545588d51")](i)).x;
                var e = t.y
                  , t = Math.min(Math.sqrt(i * i + e * e), this.Rm + this.rm / 2);
                i = Math.atan2(e, i),
                this.N.position.set(t * Math.cos(i), t * Math.sin(i)),
                this.ae.Om?.({
                    angle: i,
                    di: t
                })
            }
        }
    }
    , U = {
        Jc: null,
        no: 0,
        po: !1,
        Ib: 1,
        oo: [],
        lo: [],
        qo: [],
        Me: 0,
        Pg: 0,
        pd: !1,
        nd: !1,
        Bd: 0,
        ng: 0,
        $: 0,
        ee: !1,
        jh: [],
        cf: !1,
        ef: !1,
        k: null,
        We: [0, 0],
        Vn: 0,
        wb: {},
        r: null,
        Qe: null,
        Jo: 0,
        nh: 0,
        fc: !1,
        kf: 0,
        jf: 0,
        yg: 0,
        Dg: 0,
        vg: [],
        jg: 0,
        Je: null,
        Ng: () => {}
    }, k = {
        "1a": 0,
        "1b": 0,
        "1c": 0,
        "1d": 10,
        "1e": 0,
        "1f": 0,
        "1g": 0,
        "1h": !1,
        "1i": .25,
        "1j": 0,
        "1k": !0,
        "1l": !0,
        "1m": !0,
        "1n": !1,
        "1o": 0,
        "1p": 1,
        "1q": 1,
        "1r": 238,
        "1s": 1,
        "1t": 0,
        "1u": 0,
        "1v": 0,
        "1w": 24,
        "1x": .25,
        "1y": 0,
        "1z": 1,
        "1aa": 0,
        "1ab": 0,
        "1ac": 0,
        "1ae": 0,
        "1af": 0,
        Co: !1,
        "1ag": [],
        "1ah": {},
        "1ai": 0,
        "1aj": 0,
        "1ak": 0
    }, qe = {}, ar = {
        [o("daaff98bbf1acc05")]: o("5c88ac690256d19656f3c450375dcfdd0dc8c24b5e36d7a104"),
        [o("a5d4463b42fdd933d8f04b51")]: o("1f7513d4c133d6b3151e4bfdf46d83e94a0241"),
        [o("ba891daed528f23eb7bde0e7")]: o("fc680c8962b63176361324b057eb642c693f3e"),
        [o("f88b5b28972a4ca075bf2660")]: o("649094710a5ed99e5efbcc582f729cb411a7c6"),
        [o("4e9d71823904660a23897cdd")]: o("69ffd9da8fb91c8543a491c3aad259df1c888b"),
        [o("79a89acf96890ddff49c6781")]: o("4034b0d526f2f5327a5fe8fc13a8a0683543e2"),
        [o("a15042b74e71d5b7dc744fea")]: o("bd8b0d3623d5b051f7f0251f168ce50ba8dc3f"),
        [o("c7baa859209b3f51ba6eb575")]: o("6c989c791226c1e64683d420277e94bc19afce"),
        [o("bdec5e132ad5b11bb0d82340")]: o("f226864394e0cbacc84dde6aa1b7eee66771b4"),
        [o("79a89acf96890ddff49c678d")]: o("9a8e6eebfc48131490f506d2f90e464ecfd91c"),
        [o("c7baa859209b3f51ba6eb57363")]: o("a4d0d431ca1e99de9ebb8c18efb0c22dc36094f7"),
        [o("8c9faf3cfb06a08ce18bb256a9")]: o("08fc781d6e3a3dfa22a730044b5467c96f8c381b"),
        [o("72c155e61d604a660fe558bc4c")]: o("6f8543a491c386c345ee1b8da49dcfc008d5e382"),
        [o("623145160d905a961f15484c5d")]: o("ef05c32411430643c56e9b0d241d4e4088556302"),
        [o("6514867b823d197318308b11c5")]: o("0b993fb8eda7e22721827761c8f9ad246ca97f7e"),
        [o("82d125f6ed703a76fff528acbb")]: o("9cc8ec29c21691d696b38410f748dfd5db988c0f"),
        [o("c7baa859209b3f51ba6eb57365")]: o("00f47015663235f23a9f283c536c78f167843013"),
        [o("d74ab829306b2f21aa7e856354")]: o("bfd5f37421933613f5beab5d14cd7a10b865b332"),
        [o("ae7d1122d9a406aac3291c7882")]: o("10c46025760225c22aaf380c435c66c157940003")
    }, ri = {
        [o("598ebeeabcbb33e4")]: o("bc28ccc9a1e4667aab3034d1a0ea2476bc2e"),
        [o("8010b7a6")]: o("9cc8ec29c104869acbd0d431c90c9fd5c18ddd"),
        [o("3e8773f47063573929a0")]: o("8311b730664d6d13e419bf38673323acfe34a6"),
        [o("ae7d1123cb")]: o("10c460257510328e77cc682d7e0c3c960e9c1240"),
        [o("ae721938d3b5")]: o("c351f7f0260d2dd3a459fff822e928a3a5aab8b664"),
        [o("320e9b2a")]: o("382c48cd5df81a662f34b0d529fae9392569b9"),
        [o("c96a22893b48")]: o("b0a4c045d57092eed7acc84dcc648bf9eefc7220"),
        [o("82b600ada3567f3ccea269a5b93a1419b7e16580d21f7d68a28e6e9dbb6b5814e08a41f19f12500d8fff55989606557382e630fc937f496cfef259f5ff6ac468e7ebb2")]: o("b10701a25453d381d60f09aa5c5c919db101")
    }, hi = {
        [o("21d6c632c4e34b2c")]: o("601490f505c0c25e071c98fd00dcdb58186fdfb347"),
        [o("0bd16896fba5e3")]: o("1206e66377d2bcc0750eee6b73ca88c54741ca585684"),
        [o("cdc72ae139")]: o("277d1bdcca29c9f7404503e4ca01d4ce19054999"),
        [o("224181584fcf")]: o("ddeb6dd600a787fd8af355de1bbf86f595f002d042"),
        [o("c8ea6f63b5")]: o("ae1a4207d3b610acd9624a0fc9ae04b49022f062"),
        [o("13877c76e7a7bc382b8f747eefbf")]: o("277d1bdcca29c9f7404503e4c30bc1cf19054999")
    }, Xh = {
        [o("3f3334c0b01bb793754878")]: o("a8119e8fdc8ecb4cf1a4c0459137b0e3dde58e6aca39d0e8a9e56e72a63b6ff8edab4c6dfb383cd9b1d26146a05633959eca6f59af426cdcc5836450914755d89ae61a0ac25e5bcd"),
        [o("dbcfa8bc2cff13f7d1a4d7")]: o("621b500116840dca2b5e1e3b4bcd766517ef40e40033166e13ff50ec1c21297ea7a102e3b1327a5febe83ff8fa6c7513d4c021d7e5482a5abf991aceeb5d135ed0ec548d88541d4b")
    }, yo = new Audio(o("3bc90f68de85a55b2cd17770af9da54a65913d0d")), vo = {}, Ir = (k["1g"] = 16777215,
    k["1v"] = 16711680,
    k["1ae"] = 65280,
    (sr = window.localStorage.getItem(o("288e1e09731e0191566815"))) && (sr = JSON.parse(sr.charAt(0) === o("b10704a6") ? sr : o(sr)))["1r"] === 238 && Object.assign(k, sr),
    k["1t"] && (ar[o("c8da7f68b87263")] = k["1t"]),
    ri[k["1c"]] || (k["1c"] = Object.keys(ri)[0],
    ye()),
    hi[k["1ai"]] || (k["1ai"] = Object.keys(hi)[0],
    ye()),
    ar[k["1b"]] || (k["1b"] = Object.keys(ri)[0],
    ye()),
    null), r1 = -1, ii = null, Hh = -1, Ds = class extends _e {
        constructor(i) {
            super(i),
            this[o("86723e7ce4ef01f2ea7a")] = "static",
            this.on("pointerdown", this.Rl)
        }
        Rl(i) {
            (i.shiftKey || U.ef) && (r1 = i.pointerId,
            Ir = this)
        }
    }
    , sr = class extends Ds {
        constructor(i) {
            super(i),
            i = new Ke().rect(0, 0, 4, 200).fill({
                color: 16777215
            }),
            this.p = new Ke().circle(0, 0, 8).fill({
                color: 16777215
            }),
            this.p[o("03d17393e9ccc4956fd9")] = "static",
            this.p[o("2bbf586cdc8fc3")] = "pointer",
            this.p[o("7516985b901e124313")][o("e922")] = 2,
            this.p.on("pointerdown", this.Km),
            this.addChild(i),
            this.addChild(this.p),
            this[o("a7b0c06e6aae487f")] = new Re(0,0,10,200)
        }
        Km(i) {
            ii = this,
            Hh = i.pointerId
        }
        ij(i, e) {
            e && Ei(.25 + 3.75 * i),
            this.p.y = Math.max(this.p.height / 2, Math.min((1 - i) * this.height, this.height - this.p.height / 2))
        }
    }
    , So = class extends Ds {
        constructor(i) {
            super(i),
            i = new Ue({
                [o("1572f2b0ed")]: i.Xe,
                [o("e8ca5e428058")]: {
                    [o("9c8bb101d437839ecd999f")]: o("81a257e76498f4"),
                    [o("883fa5b5f88ea725f5")]: 12,
                    [o("82f52df9ea")]: 16777215
                }
            }),
            this.q = new _e;
            var e = new Ke().rect(0, 0, 170, 155).fill();
            this.q[o("c47867e4a3")] = e,
            this.q.addChild(e),
            this.addChild(this.q),
            i.position.y = 5,
            i.position.x = 100,
            i.anchor.x = .5,
            this.Xe = i,
            this.addChild(i)
        }
        gf(i) {
            for (; this.q.children[1]; )
                this.q.removeChild(this.q.children[1]);
            for (; this.children[2]; )
                this.removeChild(this.children[2]);
            let e = this.Xe.height + 15;
            for (let n = 0; n < i.length; ++n) {
                var t = i[n]
                  , r = new Ue({
                    [o("3ebb65a936")]: (n + 1).toString() + ". " + t[0],
                    [o("edad1bd91d87")]: {
                        [o("782fd5a5088bdf22e93dbb")]: o("0405128469b739"),
                        [o("d285fb8ba234f113bf")]: 12,
                        [o("2a5d855142")]: 16777215
                    }
                })
                  , s = (r.position.y = e,
                r.position.x = 5,
                zh[t[2]]);
                s && ((s = new Ue({
                    [o("cf74b43a27")]: (n + 1).toString() + ". " + s[0],
                    [o("cf73a53b3f61")]: {
                        [o("edb800ce05a492c99c8a0e")]: o("cdee1bd330aca0"),
                        [o("e8df4555986e47c595")]: 12,
                        [o("5e89499d0e")]: s[1]
                    }
                })).position.y = e,
                s.position.x = 5,
                r.position.x = 5 + s.width,
                r.text = t[0],
                this.q.addChild(s)),
                (t = new Ue({
                    [o("d297f19da2")]: t[1],
                    [o("7af848f4126a")]: {
                        [o("46b167b73e1d6d3027b369")]: o("e0e17660855b55"),
                        [o("c47369f9bcca6361a9")]: 12,
                        [o("adf8460c5d")]: 16777215
                    }
                })).position.x = 195,
                t.position.y = e,
                t.anchor.x = 1,
                e = e + r.height + 5 + 5,
                this.q.addChild(r),
                this.addChild(t)
            }
            this[o("2f0858d6f216d0c7")] = new Re(0,0,this.width,this.height)
        }
    }
    , Di = new class extends _e {
        constructor(i) {
            super(i),
            this.alpha = 0,
            this.Zb = new Ue({
                [o("97bcfc726f")]: o("8cf8fb1de608a2c6a1a1f355a8"),
                [o("ff43750bef51")]: {
                    [o("6e995f6f06c555e81f6b41")]: o("89aa5fef6c90fc"),
                    [o("ae591f2fc6901dbfd3")]: 12,
                    [o("57ee30a6b7")]: 16766720
                }
            }),
            this.kd = new Ue({
                [o("c300a0ce33")]: o("d4"),
                [o("307206fa58e0")]: {
                    [o("2bba4270dba6d04f5a884c")]: o("d91a0f5f3c20ac"),
                    [o("19ecf422e9dd762a44")]: 12,
                    [o("7e69297dee")]: 65280
                }
            }),
            this.Jd = new Ue({
                [o("2f1454dac7")]: o("ed"),
                [o("66845c80061e")]: {
                    [o("c8ff6575b85b6ff2b9cd6b")]: o("c5e6132b28d4b8"),
                    [o("31c4dc0ac1f55e125c")]: 12,
                    [o("8352ec1a6b")]: 16777215
                }
            }),
            this.zf = new Ue({
                [o("ae4b1539c6")]: "",
                [o("b79bcd535789")]: {
                    [o("3ea96fbf361565382fbb71")]: o("fc1d6a9c61bf31"),
                    [o("baad13a3ca1ce92ba7")]: 12,
                    [o("33825c4adb")]: 16711680
                }
            }),
            this.Nh = this.Zb.position.x = 0,
            this.addChild(this.kd),
            this.addChild(this.Jd),
            this.addChild(this.Zb),
            this.addChild(this.zf)
        }
        jn(i, e, t, r) {
            this.alpha = 0,
            this.fg = !0,
            (r = zh[r]) ? (this.Zb.text = r[0],
            this.Zb[o("9fa3d56b4fb1")][o("9e49095dce")] = r[1]) : (this.Zb.text = o("28dc5f397a343eda054557b104"),
            this.Zb[o("d45662deb4cc")][o("fd8816dced")] = 16766720),
            this.kd.position.x = this.Zb.width,
            this.kd.text = i.substring(0, 20),
            this.Jd.text = o(t ? "6a104511029a542440b31ccd252e" : "2a50855142da94"),
            this.Jd.position.x = this.kd.position.x + this.kd.width + 5,
            this.zf.position.x = this.Jd.position.x + this.Jd.width + 5,
            this.zf.text = e.substring(0, 20),
            this[o("6687418f050f")].x = this.width
        }
        Wg() {
            this.fg = !1
        }
        Dl() {
            var i = performance.now();
            10 < i - this.Nh && (this.Nh = i,
            this.fg && this.alpha < 1 && (this.alpha += .1),
            !this.fg) && 0 < this.alpha && (this.alpha -= .1)
        }
    }
    , nr = new So({
        Xe: o("cb349e")
    }), Ni = new So({
        Xe: o("3bbe786df0a285")
    }), Gr = new sr, ve = Xi(o("72f45deb12684f")), t1 = Xi(o("7aec53e2196325")), _t = Xi(o("4d5aa063a42f366a21")), yw = Xi(o("702fd3b51da2d733173b")), Ht = Xi(o("cf73b436076d3823b87dad")), jh = ve[o("41d3a736b7d32613")], To = (_t[o("ee0ec5e4807ae7609ae2dbfd9579")](o("2ed784ac5e"))[o("67eb0caeaae899ac06c2049696")](o("96532a48f4d830ccea4a"), o("3d40d0")),
    Zg(),
    W(ve, o("f11016571c1c92"), Zg),
    null), Bs = [], dt = new Ke, s1 = new Intl.NumberFormat(o("86722634dfc8"));
    {
        let i = function(u, d, f) {
            return `
            <div class="lb-rank">${d}</div>
            <div class="lb-player">
                ${!f && d <= 10 ? `<span class="lb-rank-icon">${n[(d - 1) % n.length]}</span>` : ""}
                <div class="lb-name"></div>
            </div>
            <div class="lb-num">${u.xm}</div>
            <div class="lb-num">${s1.format(Math.floor(50 * u.Cm))}</div>
            <div class="lb-num">${u.jm}</div>
            <div class="lb-num">${u.level}</div>
        `
        };
        async function e() {
            try {
                var u, d = new FormData, f = (d.append(o("3709"), k["1ak"]),
                d.append(o("a170"), a),
                await (await ve[o("87deec8e68d4")](o("f0e4000595355fe2ca8f5d2e881252aa61b52721663a27a56cfc781d"), {
                    [o("97a5fc7e73a379")]: o("11d2dc17c1"),
                    [o("52017b012f")]: d
                })).json()), b = f[o("798692df89")];
                c = [];
                for (u of b)
                    c.push({
                        id: u[o("92ca30")],
                        username: u[o("240015925a970b1649")],
                        xm: u[o("f0aa5b2f9836")],
                        jm: u[o("ac958b1ed4f29a6cc076")],
                        Cm: u[o("95eb763046f9f823efeb")],
                        level: u[o("2ed395b7572f")]
                    });
                l = f[o("6d338a")];
                {
                    var m = c.findIndex(function(E) {
                        return E.id === l
                    })
                      , x = 0 <= m ? m + 1 : c.length + 1
                      , y = D(o("9361a7b57b2a4be5ec3f"))
                      , S = D(o("9b69afbd73326cf7f13bd2"));
                    y.innerHTML = "";
                    let A = document.createDocumentFragment();
                    c.forEach(function(E, O) {
                        var M = document.createElement("div");
                        M.className = "lb-row",
                        O < 10 && M.classList.add("top" + (O + 1)),
                        M.innerHTML = i(E, O + 1, !1),
                        he(O = D(o("74ebda255527dba619"), M), E.username),
                        A.appendChild(M)
                    }),
                    y.appendChild(A),
                    c[m] && (S.innerHTML = i(c[m], x, !0),
                    S.classList.add(o("a17e41f95779d0"), o("900db0cef9808408ef")));
                    return
                }
            } catch {}
        }
        let t = D(o("9a8530c8ff4b4d53d6dd"))
          , r = D(o("0b92619ca2a2f06178"))
          , s = D(o("1e8ad2824e51b34747c7"))
          , n = "\u{1F451} \u26A1 \u{1F525} \u{1F3AF} \u{1F680} \u{1F6E1}\uFE0F \u{1F48E} \u{1F3AE} \u{1F6E0}\uFE0F \u2B50".split(" ")
          , a = 0
          , c = []
          , l = 0;
        Array.prototype.slice.call(_t.querySelectorAll(".lb-thc")).forEach(function(u) {
            W(u, "click", function() {
                var d = u.getAttribute("data-sort");
                d && (a = parseInt(d),
                Array.prototype.slice.call(_t.querySelectorAll(".lb-thc")).forEach(function(f) {
                    f.classList.remove("active", "asc")
                }),
                u.classList.add("active"),
                e())
            })
        }),
        W(t, o("6fc31d8b90cf"), async () => {
            e(),
            ae(s, o("7d0f9c446804e6"))
        }
        ),
        W(r, o("5d2db3798239"), () => {
            ue(s, o("6fc112969ad290"))
        }
        )
    }
    {
        let i = function() {
            var C = 3 <= kt.value.length;
            return ft.disabled = !C,
            C
        }
          , e = function() {
            var C = 3 <= ze.value.length && U.jf != 0;
            return ot.disabled = !C,
            C
        }
          , t = function() {
            var C = 3 <= p.value.length;
            return _.disabled = !C,
            C
        }
          , r = D(o("9ffed27757a04c78c0ab84785fb2"))
          , s = D(o("4efa22d2210660113f897f9a0d197d1d"))
          , n = D(o("2a1ede0e5dda84b55b2d93361bb399ab49"))
          , a = D(o("1f7513a1d031d1e24e364ee9863fc1f15c05"))
          , c = D(o("9b69afbd7c3f51ebea30"))
          , l = D(o("5c88ac1c1354ced607c18b550f"))
          , u = D(o("13e12735e4adf56f78b8306deaa2d27d51"))
          , d = D(o("daceaedead0acc14818789818907"))
          , f = D(o("92866696e54c3147dcc230c8"))
          , b = D(o("81d731877293e6cacf9367d9"))
          , m = D(o("483cb8a82efac8763c44"))
          , x = D(o("483cb8a824eec8763c44"))
          , y = D(o("de4a92428a8095c5a01ec41c"))
          , S = D(o("53216775a36db82776643822af"))
          , A = D(o("94c0e454f508aaa8f381b11d"))
          , E = D(o("b583055b4dcfda01fec1531f33"))
          , O = D(o("ff153341ed5de61d44576515f9"))
          , M = D(o("3d0b8dc3b25a2c836857a591a5533f95284d"))
          , j = D(o("e97f592f00318d499d075e471c1494449c"))
          , L = D(o("6573d52b87330877402e9d4f97031d4d011f"))
          , N = D(o("46f23aea3e3e6d3063bc7f8537"))
          , Y = D(o("ab799fad471362c7df"))
          , ie = D(o("fb89cfdd17c3b0c250d169"))
          , $ = D(o("a93f19ef4171d8cdc34740"))
          , J = D(o("d96f693f2822ab62807f0f7b127b957d9a"))
          , re = D(o("475d7b89b113a2d302f53d"))
          , Q = D(o("7b094f5d855f6e1fce5deb"))
          , pe = D(o("c0b43020a27a69f39bf0707e"))
          , Be = D(o("4bd97f0da674b42f006d2f23"))
          , ne = D(o("ec181c8c9ea85128a72c4ca2"))
          , se = D(o("4cb8bc2c3852deca27d1"))
          , Pi = D(o("e3b1d7e50feb3bbf88d084ad1b"))
          , Se = D(o("79cfc99f8a890fc5"))
          , xt = (So = o("69f498f99fa80ad25c8f92d4"),
        (_w || _t)[o("2a4a99585cc6a3a45e26973159b5b9a556")](So))
          , tt = D(o("5fbe02b78de080a44afa06ae9ff380"))
          , zt = D(o("f0ef4026842957bed5ab4e25"))
          , Ve = D(o("61fc85e189ba4aeb0aa88ef983f30dd41f"))
          , Vt = D(o("b3418795401277cbd609fec65e1e26d7"))
          , Wt = D(o("9e0a5202ccda07dee55b074acf"))
          , it = D(o("633a063e86768e3f46720c338a0d93161d"))
          , ze = D(o("df35d3610d772b378a7d"))
          , ot = D(o("4fa563f1bde786b335e530be"))
          , je = D(o("ff153341ed57c00475577b"))
          , yt = D(o("7f9ee48a6ac02894f3d6"))
          , si = (D(o("a05f949ad4d88516da1d")),
        D(o("74ebd028173ddfb951bed73be57caebaeabe")))
          , vt = D(o("9044e0d0fb95b309d30ca3a7f38ab701"))
          , Tt = D(o("5fb553e180f88aa502d30ca3a7f38ab701"))
          , ut = D(o("5480a4142f53d1ce25e1f148095f"))
          , ft = D(o("81d731876782e9f3ec8347d36a97e1"))
          , Dt = D(o("0b993fcde4a5e84e7ca37c68d2baeb6569"))
          , kt = D(o("9b69afbd733f46fbcd1fc0ef6e3659efdf"))
          , ke = D(o("d5e365bb3bbfa2a1aba72f"))
          , wo = (D(o("e97f592f0f2b960d9f031e415805965a9d")),
        D(o("302440b056f00f2a4e600aa64ce10b7c")))
          , ks = D(o("c43034a4a7e96f75e16b67effdc67b45a0"))
          , Br = D(o("f8ec08788a244ee267b82427292529a77da9"))
          , h = D(o("912721f7766af8bbfc276da56d23f2bfc5734f"))
          , p = D(o("51e7e1b7b2af31fc74bab7eda4ab2dbd08b6"))
          , _ = D(o("6a5e1e4e1e8d5f6217f047a8116e5e7d57e948e3"))
          , g = D(o("4513f5cbae532d88604eae63ba2334617835b264bc292f"))
          , v = D(o("d88c2818bb4478dbcdd6475d814747dbc5dc5849834f"))
          , P = D(o("681c98880bd4c84b5d32c7a017a0c5345524c9ac"))
          , w = (new URLSearchParams(window.location.search).get("mobile_platform") === o("69bb85f89fb106c4") && (Ve.style.display = o("0d90e0aef4"),
        si.style.display = o("e8d7455589"),
        ti = !0),
        null)
          , R = (i(),
        t(),
        {
            [o("6b6c1f37b010c00914161d50c652c15f024f051d92036447e142b105624a3b")]: o("3f0628c29c459adb28163dd2"),
            [o("34f5046e67394be05bec4762316beaeb35a4f4657028fee329ebe6716110f0")]: o("c4636fe797e9666ebf423daf8fc5735aa7")
        });
        ve[o("6b4c0c3a8b4c94")][o("142c388e6c803b0775173b")]({
            [o("a0058d98c19b")]: o("4cf1e769357ea1c66497a4463c1fa8923f9baf4e585797835d8497045c5a93825c"),
            [o("de0ad6148c87e7948a1bca188990")]: function(C) {
                C[o("bc639fe2a5")] == o("7664506c19e053f80a21237eefe328f0f2722c") && (ae(P, o("3ea070b42c")),
                Ht(async () => {
                    var X = await (await ve[o("a81f8f8fcf95")](o("08fc781d6d2d27fa22a73e0c730c38c22aaf") + k["1ak"])).json();
                    X[o("a7bbc67e4e")] === 200 && await F.w.L.yc(X[o("3d4ade84a0")])
                }
                , 5e3))
            }
        }),
        (async () => {
            try {
                var C, X, H = await Fs();
                if (H)
                    for (C of await H[o("e294c181a212dc188397df")]([o("8e693951cd920bc8f9492c41"), o("fc3b57bf5fa12e26770a75e757bd2b227f"), o("baa51da0db10e330b0b7dbe0be")])) {
                        var ee = new Intl.NumberFormat(navigator.language,{
                            [o("0d8dfbb9fd67")]: o("a17156a65773c9bbd0"),
                            [o("c5d5320a3bdfa51fb4")]: C[o("f273c66c95e2")][o("c634fd2bb8bee2beb7")]
                        }).format(C[o("a8099892cf98")][o("0ee9b1cd6746")])
                          , de = D("#" + C[o("f42c42a295805e")]);
                        de && he(de, ee)
                    }
                else
                    for (X of (await ve[o("7adb5de91a6325")][o("8364f71f645d5908ee4ae41b78")]({
                        [o("1c042a8a4d82")]: [{
                            [o("3cfd0c662374cbf7")]: o("c788bb5314cc7c55a832b974627e6d73ae6ba139363f387bbd66d521066657"),
                            [o("2567d2b9c76e42a854")]: 1
                        }, {
                            [o("bf80b35b20910c52")]: o("c142319d1a06f693ae5b72913c44a778a07321766d77a370bc3c33626c7fbd"),
                            [o("75178249971e125804")]: 1
                        }]
                    }))[o("4cf9ef6b31")][o("82f721e1e77e246a")][o("455aae96ac733f99204d")]) {
                        var me = R[X[o("e7689b330879")][o("851f63")]]
                          , q = D(o("2a1ede0e") + me)
                          , V = D(me === o("42256d2519e657b425357835") ? o("d3a1e7f538f82d95ade5ad") : o("b10701d75a56c3b7cf434bb34d42ca83"))
                          , I = X[o("d92c347e302fab648436377b11378b6b")][o("f3d09a9216c4")];
                        q && he(q, I),
                        V && he(V, (me === o("9017bb93cbd4890af707ae83") ? o("6b392b6eca19b7474b61505ec60dcb5a2d652d4bcd005133c07fc431421d3b4aa619bf4e") : o("6f8537d2d69db3c34e9a5cd2be89cfde29f9d1d7318455bad2ebacc83b9128ccbf")) + I)
                    }
            } catch {}
        }
        )(),
        W(p, o("059fe9c8fc8e"), t),
        W(ks, o("41d1af1da6dd"), () => {
            ue(P, o("2c121e9a5e")),
            ae(Br, o("92cc24c0f8"))
        }
        ),
        W(h, o("4230683c25bc"), () => {
            ue(Br, o("4fef21a7bd"))
        }
        ),
        W(_, o("c95927952e55"), async () => {
            if (t()) {
                if (_.disabled = !0,
                !await Fs()) {
                    var C = new FormData
                      , X = p.value;
                    C.append(o("8355"), k["1ak"]),
                    C.append(o("1407"), X),
                    ue(v, o("803eb2b6ea"));
                    try {
                        var H = (await (await ve[o("bdc85a0422da")](o("baee4e8bdf3fe974f095e3bca023d72fa3aba9ef88"), {
                            [o("6e9255751aec50")]: o("2eefbf9266"),
                            [o("03d66a92fe")]: C
                        })).json())[o("d1213c6030")];
                        if (H === 200)
                            ve[o("62234511029b4d")][o("e634c01c8990c3889a")][o("e0de52568a")]({
                                [o("46be7cbc2728")]: [{
                                    [o("4546b591aa5f0298")]: g.value === o("0a6da56d51efbcd461") ? o("1a5bae44419fd1da4552dd5857cd80c15b0a9e4f168e84b957359c2b07f69a") : o("66875a90354b1d1609cd583743f90cb00f64407a17b859b81c797462e7e176"),
                                    [o("63651037896c802e12")]: 1
                                }],
                                [o("f42643b48ca6570f9d395f")]: {
                                    [o("f59304cd0bb592c8")]: U.Jc,
                                    [o("72f647e00458516d25ec55eb0a")]: X
                                },
                                [o("1f2344e6d73dcbf154")]: {
                                    [o("585df2ce31c8")]: o("4a3f6d2f25")
                                },
                                [o("6a18590e1a905d6400")]: {
                                    [o("370d54cbd200")]: U.Je
                                }
                            });
                        else if (H === 201)
                            ae(v, o("1569e7adf7")),
                            he(v, o("c5ff290e28d6a218e88c7ff43ea9b6eafb"));
                        else {
                            if (H !== 202)
                                throw 0;
                            ae(v, o("322c842058")),
                            he(v, o("ef709d030a410743c51897050f094f5e995f741ce71a"))
                        }
                    } catch {
                        ae(v, o("7826caae12")),
                        he(v, o("20bf0707531a149c0dcb5a1e5e0f018d"))
                    }
                }
                await 0,
                _.disabled = !1
            }
        }
        ),
        W(ke, o("2c1e0296536a"), async C => {
            C.preventDefault(),
            (C = await Fs()) ? await $g(C, o("97bef07a44fd4263f0bed57a")) : ve[o("fedfa1f5667fa1")][o("6fe3198790cf9a9303")][o("edb11fc51f")]({
                [o("49d3bf19a0cd")]: [{
                    [o("f112014d1603be4c")]: o("27285bf3f46c9cf548525994821e8d934e0b41d9d65fd89b5d0675c1a606f7"),
                    [o("66865d98040f450917")]: 1
                }],
                [o("7ae849fe0a602d55e3e725")]: {
                    [o("ea8edf989c20d9e5")]: U.Jc
                },
                [o("fa78d9798ae6aef671")]: {
                    [o("29eec339c0fb")]: o("08bd2b2967")
                },
                [o("b0e28770c06a9be2ca")]: {
                    [o("c5d32a1920d6")]: U.Je
                }
            })
        }
        ),
        W(wo, o("075b6513e857"), async C => {
            C.preventDefault(),
            (C = await Fs()) ? await $g(C, o("0d88e6b0ce727fb16659a4f8c66e7ab56e")) : ve[o("77f8188e9fc098")][o("bb2fd5cb5c1b2ec7b7")][o("306e02e65a")]({
                [o("11ebe721f8f5")]: [{
                    [o("cf70a32b30611c22")]: o("1415248e47d96b007b0c6782518b0a0b5544148510c81e03490b0691013010"),
                    [o("090bfe5de30a663468")]: 1
                }],
                [o("ea98d98e9a10ddc59377d5")]: {
                    [o("818770d177a9eedc")]: U.Jc
                },
                [o("df638426177d0b3194")]: {
                    [o("59beb3e9b0ab")]: o("ce3bf113b9")
                },
                [o("f3c7809503c7148f89")]: {
                    [o("0117ee55ec1a")]: U.Je
                }
            })
        }
        ),
        W(vt, o("0efcbcc87148"), () => {
            ae(ut, o("ce30e004bc"))
        }
        ),
        W(Tt, o("26d484d04950"), () => {
            ue(ut, o("fd810fd5ef"))
        }
        ),
        W(kt, o("4870e4eb39e9"), i),
        W(ft, o("471b25d3a817"), () => {
            (async () => {
                if (i()) {
                    var C = new FormData;
                    C.append(o("59a1bef5"), kt.value),
                    i(),
                    ue(Dt, o("fd8f1cc4e88466"));
                    try {
                        var X = await (await ve[o("0590e2ccea92")](o("d0842065b5557f82eaef714ea57272c087d84c16d673"), {
                            [o("77c51c9e93c399")]: o("3bbc727deb"),
                            [o("6b7e023a96")]: C
                        })).json()
                          , H = X[o("e0d24d5781")];
                        if (H === 200)
                            ue(ut, o("0c323eba7e")),
                            await F.w.L.yc(X[o("ef44901612")]);
                        else {
                            if (H !== 202)
                                throw 0;
                            ae(Dt, o("9fb1c2664aa240")),
                            he(Dt, o("651f896e88360278486cdf4b941b52"))
                        }
                    } catch {
                        ae(Dt, o("8afa2fe9e76935")),
                        he(Dt, o("43ba2042b097bb516ece7d5bbd72be30"))
                    }
                }
            }
            )()
        }
        ),
        W(yt, o("bf93ad5b209f"), () => {
            k["1ak"] = 0,
            ye(),
            ve.location.reload()
        }
        ),
        W(ze, o("e933056c182a"), e),
        W(ot, o("6fc31d8b90cf"), () => {
            (async () => {
                if (e()) {
                    var C = new FormData;
                    C.append(o("97bcf6617ea2"), k["1ak"]),
                    C.append(o("87cdfa9f79d26c93ea"), ze.value),
                    C.append(o("4d5da95fa537216a"), U.jf),
                    U.jf = 0,
                    e(),
                    ue(je, o("996b78b87478fa"));
                    try {
                        var X = (await (await ve[o("af86d456508c")](o("9044e0a5f595bf42aa2fb482ff86f30cc8108c94c1d0d431"), {
                            [o("568a7d9d320478")]: o("fdbe30e3d5"),
                            [o("cb1ea2da36")]: C
                        })).json())[o("ee1cdfe597")];
                        if (X === 200)
                            return !ve.location.reload();
                        if (X === 201)
                            ae(je, o("a2d207c1cf410d")),
                            he(je, o("dd9b2cf513bc82f980f355a800a9ceaeddaa0ecb148c"));
                        else if (X === 202)
                            ae(je, o("14043593719f3f")),
                            he(je, o("995374b9383cafb4ce7c04a0002497b0c86c4ef91f2ecec583125d85584392da89495a9e59"));
                        else {
                            if (X !== 203)
                                throw 0;
                            ae(je, o("a7b9ca6e42aa48")),
                            he(je, o("3f2532d7b11aa4db225d7b8aa813a3ca2ee93fb1f6b6e5a03be93eadbee8f8fc6ff30ebc97f18ba2"))
                        }
                    } catch {
                        ae(je, o("8fa1f2767ab270")),
                        he(je, o("0a55a96979f0a2ca3711e44064d5b7db"))
                    }
                    ve[o("cdca3af23fb1a7edb9a3")][o("84a7a324ed2d")](w)
                }
            }
            )()
        }
        ),
        W(Wt, o("f1011f4d160d"), () => {
            ue(Vt, o("06f8b8fc64"))
        }
        ),
        W(it, o("bf93ad5b209f"), () => {
            w ||= ve[o("3552c29ad7594f85514b")][o("3554d286dd4f49")](o("4513f5cbbd4f39923e4aa66cb46f3d6d362dfa6bb6242f6d3420ba62"), {
                [o("fefca9e56778a16c")]: o("d899621f9d6c5feea1f06175ac5d5fc1dfff5c418e4e498baa"),
                [o("4eac799b37")]: o("0ef9bcc46a4ab64973"),
                [o("4555a694a5582a9f26")]: function(C) {
                    U.jf = C,
                    e()
                }
            }),
            ae(Vt, o("b2ac04a0d8"))
        }
        ),
        W(Ve, o("8af820f4ed74"), () => {
            _t[o("cabdf9b1a22cf313b786faa0ba02f50cb49f")] ? _t[o("adfb570945e4c608d9d5541a5ccfd5")]() : _t[o("2c1f019b49")][o("a5e442295cffd828ebeb430c42c1c101d0c8")]()
        }
        ),
        W(zt, o("685ac6d20fd6"), () => {
            qe.Ac(1)
        }
        );
        for (Lh of xt) {
            Jg = Lh,
            e1 = o("4395");
            let C = Jg[o("23b04462c6abcc6e")][e1];
            W(Lh, o("d4467acebbc2"), () => {
                var X = o("e12106780035937d8d090e6e1b3b9d");
                tt[o("2095030745060383")][X] = C
            }
            )
        }
        let G = n.firstElementChild;
        W(n, o("65358b718a31"), C => {
            var X, H;
            (C = C.target).nodeName === o("d58402dc0d8595") && (X = D(o("7b020e0b9c44681ded67ab17644c600cee")),
            H = D(o("7aae0ebe0a6e223c") + C.getAttribute("data-tab")),
            ue(G, o("6fc112969ad290")),
            ue(X, o("1c0c3d9b498707")),
            ae(C, o("0efeb3d57b55b1")),
            ae(H, o("734516129e5e9c")),
            G = C)
        }
        ),
        W(r, o("6210481c059c"), () => {
            ae(s, o("8d1f6c3478f4f6"))
        }
        ),
        W(a, o("e77b85330877"), () => {
            ue(s, o("3547d49cd05c5e"))
        }
        ),
        W(c, o("0f237debf02f"), () => {
            yw[o("cb1fa1d73fe23ea3a1e0")][o("4b8b3f57bb6585272b70")](U.Jc)
        }
        );
        for (Fi of Object.keys(ar))
            r = Ui(o("0ef0a0d57b4cba")),
            ae(r, o("c8ec6336a36d7af6bfcf")),
            he(r, Fi),
            ht(r, Fi),
            Li(l, r);
        ht(l, k["1b"]),
        W(l, o("d8ca724ab24a7b"), () => {
            k["1b"] = l.value,
            ye()
        }
        );
        for (Nh of Object.keys(Xh))
            Fi = Ui(o("9806aa9ff582b0")),
            ae(Fi, o("14103fca77992e027303")),
            he(Fi, Nh),
            ht(Fi, Nh),
            Li(u, Fi);
        ht(u, k["1o"]),
        k["1o"].toString() != o("5a5b") && (_t[o("1bbd686beda9f2774fb14662c8aa")](o("e1300c701c"))[o("3a38883452aa")][o("1565e2baea6569")] = o("3391474a9fcf") + Xh[k["1o"]] + o("64928f125a7a8f895cdcdb4b1f")),
        W(u, o("075b611be55be8"), () => {
            var C = u.value;
            (k["1o"] = C) != o("66c7") ? _t[o("16d6adcc68528f4872ca83c54d41")](o("feedaff57b"))[o("e44652ce84dc")][o("dbefa8bc2cff13")] = o("2c081c931826") + Xh[C] + o("b3439c83052b1c988b0dc8da50") : _t[o("3ebe75b4302a57302ab26bad2529")](o("4073edf73d"))[o("9ad828d4f24a")][o("cddd3af222ada1")] = "",
            ye()
        }
        ),
        ht(d, k["1d"]),
        W(d, o("0efcb8c07c44b1"), () => {
            k["1d"] = parseInt(d.value),
            ye()
        }
        ),
        Bi(S, k["1af"]),
        W(S, o("6a18441c009855"), () => {
            k["1af"] = S.checked,
            ye()
        }
        ),
        ht(A, o("f8ec0878") + k["1g"].toString(16).padStart(6, "0")),
        W(A, o("42306c3428b06d"), function() {
            k["1g"] = parseInt(this.value.substring(1), 16),
            U.he(),
            ye()
        }),
        ht(E, o("5d6bed23") + k["1ae"].toString(16).padStart(6, "0")),
        W(E, o("8e7c3840fcc431"), function() {
            k["1ae"] = parseInt(this.value.substring(1), 16),
            ye()
        }),
        ht(O, o("46f23aea") + k["1v"].toString(16).padStart(6, "0")),
        W(O, o("ee1cd8e09c64d1"), function() {
            k["1v"] = parseInt(this.value.substring(1), 16),
            U.he(),
            ye()
        }),
        ht(M, k["1s"]),
        W(M, o("c79ba15b259b28"), () => {
            k["1s"] = parseInt(M.value),
            ye()
        }
        ),
        Bi(j, k["1z"]),
        dt.visible = k["1z"],
        W(j, o("ea98c49c8018d5"), () => {
            k["1z"] = j.checked,
            dt.visible = k["1z"],
            ye()
        }
        ),
        Bi(L, k["1k"]),
        W(L, o("63770d37897f8c"), () => {
            k["1k"] = L.checked,
            ye()
        }
        ),
        ht(N, k["1y"]),
        W(N, o("77c1179a8ed8"), () => {
            var C;
            N.value !== "" && (N.validity.valid ? (C = parseInt(N.value),
            isNaN(C) ? (N.value = 0,
            k["1y"] = 0,
            ye()) : C < 0 || 65535 < C ? N.value = k["1y"] : (k["1y"] = C,
            ye())) : N.value = k["1y"])
        }
        );
        for (Et of Object.keys(ri))
            A = Ui(o("dc426edb89de4c")),
            ae(A, o("997f72e1727eebb9ce7c")),
            he(A, Et),
            ht(A, Et),
            Li(Y, A),
            ri[Et] = new Audio(ri[Et]);
        k["1u"] && (ae(Et = Ui(o("46b878ad233462")), o("9490bf4af719ae82f383")),
        he(Et, o("1a68a95e6ac08d")),
        ht(Et, o("a83a9f88d89283")),
        Li(Y, Et),
        ri[o("4052f7e030faeb")] = new Audio(k["1u"])),
        ht(Y, k["1c"]),
        W(Y, o("e939037d03398a"), () => {
            var C = ri[k["1c"]];
            C && C.pause(),
            k["1c"] = Y.value,
            (C = ri[k["1c"]]) && C.play(),
            ye()
        }
        );
        for (Ai of Object.keys(hi))
            Et = Ui(o("4b933d4aa66fbf")),
            ae(Et, o("4ce8e7323f51e6ca3bcb")),
            he(Et, Ai),
            ht(Et, Ai),
            Li(ie, Et),
            hi[Ai] = new Audio(hi[Ai]);
        k["1aj"] && (ae(Ai = Ui(o("5d21af64883d0d")), o("03c16cdbe8c8fd9364d2")),
        he(Ai, o("7002c7b000aadb")),
        ht(Ai, o("a79bdc695fb340")),
        Li(ie, Ai),
        hi[o("69999eef99b102")] = new Audio(k["1aj"])),
        ht(ie, k["1ai"]),
        W(ie, o("c8fa627aa27a6b"), () => {
            var C = hi[k["1ai"]];
            C && C.pause(),
            k["1ai"] = ie.value,
            (C = hi[k["1ai"]]) && C.play(),
            ye()
        }
        ),
        Bi($, k["1n"]),
        W($, o("6cdec65e1e26d7"), () => {
            k["1n"] = $.checked,
            ye()
        }
        ),
        Bi(J, k["1ac"]),
        W(J, o("9486be06f60ebf"), () => {
            k["1ac"] = J.checked,
            ye()
        }
        ),
        he(re.nextElementSibling, k["1i"]),
        W(re, o("8e7c3840fcc431"), () => {
            he(re.nextElementSibling, re.value),
            k["1i"] = parseFloat(re.value),
            ye()
        }
        ),
        W(re, o("0d97e1b0e476"), () => {
            he(re.nextElementSibling, re.value)
        }
        ),
        he(Q.nextElementSibling, k["1x"]),
        W(Q, o("e614c018849cc9"), () => {
            he(Q.nextElementSibling, Q.value),
            k["1x"] = parseFloat(Q.value),
            ye()
        }
        ),
        W(Q, o("9800b49be999"), () => {
            he(Q.nextElementSibling, Q.value)
        }
        ),
        he(pe.nextElementSibling, k["1p"]),
        W(pe, o("7b4f150f915764"), () => {
            he(pe.nextElementSibling, pe.value),
            k["1p"] = parseFloat(pe.value),
            ye()
        }
        ),
        W(pe, o("3ce4107f3565"), () => {
            he(pe.nextElementSibling, pe.value)
        }
        ),
        he(Be.nextElementSibling, k["1q"]),
        W(Be, o("c8fa627aa27a6b"), () => {
            he(Be.nextElementSibling, Be.value),
            k["1q"] = parseFloat(Be.value),
            ye()
        }
        ),
        W(Be, o("734d1b16825c"), () => {
            he(Be.nextElementSibling, Be.value)
        }
        ),
        he(ne.nextElementSibling, k.Do),
        W(ne, o("8032aab2eab2a3"), () => {
            he(ne.nextElementSibling, ne.value),
            k["1w"] = parseFloat(ne.value),
            ye()
        }
        ),
        W(ne, o("e8d0444b9949"), () => {
            he(ne.nextElementSibling, ne.value)
        }
        ),
        Bi(se, k["1l"]),
        nr.visible = k["1l"],
        W(se, o("bf93a9532d9320"), function() {
            k["1l"] = this.checked,
            nr.visible = this.checked,
            ye()
        }),
        Bi(Pi, k["1m"]),
        Ni.visible = k["1m"],
        W(Pi, o("4b9f255fa167b4"), function() {
            k["1m"] = this.checked,
            Ni.visible = this.checked,
            ye()
        }),
        Bi(Se, k["1a"]),
        W(Se, o("f6e4d0e8946cd9"), () => {
            k["1a"] = Se.checked,
            ye(),
            ve.location.reload()
        }
        ),
        W(f, o("4fe339a3bde3b0"), () => {
            var C, X = f.files[0];
            X && ((C = new FileReader).onload = H => {
                k["1e"] = H.target.result,
                ye(),
                location.reload()
            }
            ,
            C.readAsText(X))
        }
        ),
        W(b, o("d8ca724ab24a7b"), () => {
            var C, X = b.files[0];
            X && ((C = new FileReader).onload = H => {
                k["1j"] = H.target.result,
                ye(),
                location.reload()
            }
            ,
            C.readAsText(X))
        }
        ),
        W(m, o("1ecc88d04c5481"), function() {
            var C, X = this.files[0];
            X && ((C = new FileReader).onload = H => {
                k["1t"] = H.target.result,
                ye(),
                location.reload()
            }
            ,
            C.readAsDataURL(X))
        }),
        W(x, o("16c4b0c8744cb9"), function() {
            var C, X = this.files[0];
            X && ((C = new FileReader).onload = H => {
                k["1u"] = H.target.result,
                ye(),
                location.reload()
            }
            ,
            C.readAsDataURL(X))
        }),
        W(y, o("584af2ca32cafb"), function() {
            var C, X = this.files[0];
            X && ((C = new FileReader).onload = H => {
                k["1aj"] = H.target.result,
                ye(),
                location.reload()
            }
            ,
            C.readAsDataURL(X))
        })
    }
    var ki = new Ds
      , rr = new Ge
      , lt = new Ge
      , oe = null
      , li = 0;
    T.mf = Xi(o("41c5aa1aa1d930")),
    T.d = T.mf[o("51a6bce7a0ab32e62d")],
    z.e = function() {
        var i = k["1n"] ? 1 : T.mf[o("6d3a8a56980116741c1e9244ab0b0f4512")];
        return (i = k["1ac"] ? .5 : i) || 1
    }
    ,
    T.mf.addEventListener(o("b784d64b5f"), async function() {
        let i = D(o("bc239fe1aefe777da7702bf4a7f77e7aa5736bed"))
          , e = D(o("039a6498e9d7fc9468d9208aeab8e5"));
        var t, r, s, n, a, c, l, u, d, f, b, m;
        function x(h, p, _, g, v, P, w, R, G, C) {
            this.$a = h,
            this.Hh = p,
            this[o("4cc9eb672454e0c6")] = null,
            this.Kh = !1,
            this.mb = _,
            this.nb = g,
            this.gg = v,
            this.hg = P,
            this.jj = w || (G || v) / 2,
            this.wl = R || (C || P) / 2,
            this.Vh = G || v,
            this.Zh = C || P,
            this.Ql = .5 - (this.jj - .5 * this.Vh) / this.gg,
            this.db = .5 - (this.wl - .5 * this.Zh) / this.hg,
            this.Xl = this.gg / this.Vh,
            this.bm = this.hg / this.Zh
        }
        function y(h, p, _, g, v, P, w, R, G, C, X, H, ee, de, me, q) {
            this.zg = h,
            this.Ag = p,
            this.Fm = _,
            this.Tm = g,
            this.Ji = v,
            this.en = P,
            this.Si = w,
            this.qn = R,
            this.vb = G,
            this.Bn = C,
            this.bj = X,
            this.Mn = H,
            this.fj = ee,
            this.pj = de,
            this.Xg = me,
            this.yj = q
        }
        function S() {}
        function A(h) {
            this.xf = h
        }
        function E() {
            this.bc = []
        }
        function O(h, p) {
            this.th = h,
            this.se = p,
            this.Uf = this.Sf = 0
        }
        function M() {
            this.Aa = new _e,
            this.Aa.sortableChildren = !0,
            this.I = new r,
            this.I.zIndex = 1.6,
            this.P = 0,
            this.i = Array(797),
            this.i[0] = this.Ph(0, new T.pb, new T.pb);
            for (var h = 1; h < 797; h++)
                this.i[h] = this.Ph(h, new T.pb, new T.pb);
            this.Wh = this.Uh = this.Tg = 0
        }
        function j(h, p) {
            this.J = h,
            this.J.za(!1),
            this.id = p,
            this.id.za(!1)
        }
        function L(h) {
            this.X = h,
            this.ra = !1,
            this.ze = 1
        }
        function N(h, p) {
            this.Xb = h,
            this.xl = p
        }
        function Y() {
            ++Y.Sl,
            this.oi = this.mi = this.ki = this.hi = null,
            this.Sb = this.ti = this.Qd = !1
        }
        function ie() {}
        function $() {}
        function J() {
            this.qc = T.Rb.ni,
            this.fb = 0,
            this.lh = 500,
            this.Ye = 4e3,
            this.Eg = 7e3
        }
        function re() {}
        function Q(h) {
            this.eh = h
        }
        function pe(h, p) {
            this.G = h,
            this.ph = 80 <= h.hb,
            this.Hc = this.Ec = this.Cf = this.Af = 0,
            this.gd = this.ph ? 1 : h.vc,
            this.Ig = 1,
            this.Lg = !1,
            this.Lf = this.pe = 0,
            this.Ma = 1,
            this.Uk = 6.283185307179586 * Math.random(),
            this.td = new T.al,
            this.td.Vc(F.w.h.C.qc, this.G.qi === T.Zc.Yd ? null : F.w.o.S().re(this.G.qi), F.w.o.S().fl(this.G.hb)),
            p.lj(h.H, this.td)
        }
        function Be() {
            this.Na = new u(new T.pb,new T.pb),
            this.Na.id.u.so = "add",
            this.Na.id.u.zIndex = 100,
            this.Na.J.u.zIndex = 500
        }
        function ne(h, p) {
            this.J = h,
            this.id = p
        }
        function se() {
            this.rb = this.jb = this.qb = this.ob = this.pa = 0,
            this.kg = []
        }
        function Pi(h, p) {
            for (var _ = 0; _ < h.length; _++)
                if (parseInt(h[_][o("5b6539")]) === p)
                    return _;
            return -1
        }
        function Se() {}
        function xt() {}
        function tt() {}
        function zt() {
            this.cd = [],
            this.Sd = []
        }
        function Ve() {}
        function Vt(h, p) {
            this.Kg = h,
            this.Id = p
        }
        function Wt() {
            var h = new oi({
                [o("edbf1bd4038b91d1818304")]: {
                    [o("11e3c521e7f2723049e5e825e9e7703e")]: [-.5, -.5, .5, -.5, .5, .5, -.5, -.5, .5, .5, -.5, .5],
                    [o("d44442c2a0ea7544ae49")]: [-.5, -.5, .5, -.5, .5, .5, -.5, -.5, .5, .5, -.5, .5]
                }
            })
              , p = new Z;
            this.Rc = At.from({
                [o("0d99e3")]: {
                    [o("e124066611339f")]: o("29ead939cef75c095ecc965685ce5e0f51da9e5e8dc8531f20c6e6478793773928cebf0ea4dc3af434e7e1b4a3a334ba7cf8ebed8bab2de404aab3fb96bf13f106b4ceafaffb5fe1109687d69c8402dc1ccfc99c8b8b1c82a4c033d55193fffbe69579d828cdcde5a14366aa7c60f8baf42f29fc706febe3842013a17564c8b2cc795fb54270e281c5505a9c1015f5cd896b4e825448d082ac1771c42857b3cbec087b891a51bd6cb51621653b35b167ab27166d293cb668c461213155179276803c046e007bdd109c0307175054c75dad181a420e0890426c3fe240f71f7f1d3a38ae0ccc086e3268ebfd23b0b4273e7ce9a969afbe690444eae03bcae4437d1ad88e6cece8400955878154d8c75e0611839e5e8d8b083264828251f786624a799ff94ce88c7ff605a7abc7baa925ec7cf8eba9ee8a7aa251b3b7f19d9508f71bbeceafaffb5d9054d0c381c7d6529a49cfcbedd8dc4f95b3c2268635d3b588ff9f688f28ccbfb6f47067a16d56f8bbf07e72a3732bade0842167f11726d1bdca2903bd7b7bdd94d45a638b464fc381d6441ede7e0b8dc0f01c73dd600585ddf97b6ece7d1bfd30f47063216776ba69ad797e3e6d23a960c46053315612c22ad92f3b6e02348a43850b1c4a3807835a90125e1e4d44da023107d45bf71a636c7b1be54feb117d2d5ce3e736fcfe327a29a0be7eadfb4b2240fcd032cae44a1548eed935d5bb1c221492f2418796125a098f895c989c0f172ded931bb6df331126d4ee4efd9b7cc474f0e3f2b0a563a071a7adfcf8fc6fba44e0d3e280a413fd118a84ef84aa06cf1fcbdddc8cc345eb5cd8cb9cd3de5a82c2d7318434d8b791acc949993dbfaaf7d5"),
                    [o("306700e253e813694c")]: o("17386beff825eee7703e04a0933cccf14f280ca89b3ac1f14e141491f14185e7125878dcda1ec4c751176480f302a0d5755d7b8abd28a8c60cef3eb0b7a1e68472b818bfb5e5bba12dfd44e0d3e280b553bd5bea9edf82b200d23e9496d699870e8d4aa8de9cbc9b11d9e79d71d920c4b7cbe8977bd0688cbd84b43023b14163efbcec787ee92e4cbae0e0674dbd4379d5b58c281baa487d9dc5831246b0505ec39dcb4f688f5c42dad5f27066c40443a991af553991680cff76b42161216776a25cbc322f792f2b9076872106604065a53dd91b4e2c2c2880499547411418079e46d1435e1e4d4bc8722442c211b746220a395fb90ca84c3f3674e1a761a7b6632d61feee3ef8cd703c4ee0866695b3141c0ca89b28c8e65b1543c781209dd3630d41dece1ed88b0d336480f30291d33f3b26d5b918e88c7faa74f0e3f181a32ffc2cb8bedfbeaf33f544e0d3b1d79442aa59afbff995aa1ad214ad95c2868303815cd9b989cfde5a82b1d7318420c4b79db9bb2e8e3ddbbdf0b43023e12736e1adfa3e3efe2d6ffbbad46157b14155c8b4c6680eee1d3b9ca494100390505ec39dcb4f78835141cdd5f30269d17706f7d6fa1f78be680cff25e37276366563e538fc7a1a296f7efa22d17751244064d76e8c395f395f6e805694101f450c25984496185e1e4d4bcc742440b342e01533107c39e450e20c403674f0ff25eca8652f7bafa90fb8bc2f600fa28a7197a60d7d1baade1fc2f240127ed4d616d9c74e46588f882e989c0f557382e646f59375486c8a8a59ff8e6ab261e7e1b4f0f467ef35959dfebca91cff0dbd91b1d7e642ab2dffd9ac8cba05d5029696c0b6891bc70bcfc99cd8dc3d95b3c26cc26084ebd9f0b964d0628caaf3d32723853031d3")
                },
                [o("13a36573")]: {
                    [o("b0f79771c0608e")]: {
                        [o("7aee52f90c76107eebfd30")]: "vertmain",
                        [o("61a18ce197b502")]: o("96542c5befc82888ac1f275dcdd105d9f359015fc5c901ce8b0d4064858151f5f7624a799ff94ce88c7fa563f2a6d4a7a93ded3abeb2e3b3833ee413bb9bb1d6970af91de993afc8ed2cc642d0d697b0c345eb5cdaba89cfde5a82b1d7318420c4b7cdde9579d069aafda1ff7175ab676bdaa9ed7872b4383ddebdc06610ac1633949bcf2919f91e5b8ad2f20703a5101487cd8b1a1ede0d0b8dc0b4652c8629528497a55539bd214ea761f47112216776a16dba7e7e3f1e28ec22c46126315715c228a87f592c486cdf05c35256164513a54d8a0517590907905e2441c211b746715d6a48ae0fce183c7234b1d661a7c5327858afac08b8be5e7511d3d020d7e3442c0ca89b10c2fd4e0c64ccda02dad45a1b1c988b498aec1a400097f144e084775d7b8aee4efdcb1bf230aca0e2bab43ac538bea9e5a5eb6cd10cb397a79de542ab2abcd8aec8ed2a8543a1d694b4c345985cd8cb89cfde5a82b18740db6999f59dbabb7dd96ecaaaf3d26420f63035d2edab493efc5c2bade0842013f1172682ea996f79b35870cbc5826355d7070385ab9c1a7ac90a6a9ac0801773b5600686ddfd0a2c8e224bbf28e16b76366563e338bb2335683420b838d17b46265520866acc6928690337894f830f56173043c5189e06144e1c02aa5e6814ec46e805220a395fb87da84c3f077dedf125f9d379217fe5e921eeab2c1204a2e27191a6402a46efdb749cb70a5201878754d7cf590c50c4dc448d871a4271c4a206e085040d27d3ad13bfd36ab314e7e1b4b9a934e9359fb5e5bba12dfd12f7d1a4c0e526bd5beaa7f38ebf03f51f8b95cb878b048d4aa8de9cbccb4ff1f28671c16682a28ab9ac6ece799bf78fe47663b16123a5f8bc3d59e92d4fbae2913711e4002497fd9b2a0ee81d7cda89dd565a8a1d56d89bd05e528353079ac2f1422c872c42ae97a71f78bd680cff76b42167216605b13beb6f6849787c9c35d11346265573d528cc685b395f6eca14c10e1c4714129e4797424b05585ccf465517fb77ea19755c2c49ca19bf4e792572b0b677d6e0247a3cb9de69afcd3a6060b7941080a5657d19db8e6cecbb1f2114968312d0d4430d418f8b2ddbc01a4271c4a606b1db26112792ee4c8c9b7db074f0e3a1e7f672ba69efefbcb1a13cf115bb8cfacde64ebd5bea8aca88ac1bc509b29cd79c921ec717cfc99cd8dd3e95b3c275d166c4a28bca9c388e28cdcae5a34136f45423a5f8bc382be92f3ebae2913717e44979c4b9dd7344b2052f86c5831252b0505ef487d6585fc90f1e9ac3801771c43353a4caec09089a7e0cea339467614770769621fc786b21787d9a35d362357117228260a62f1f6c182aca12c14744665054c70dcb5a5e1e4d4bcd002440b311b537220a395fb90ca84c3f6523b2e525e7a3257874fceb69afbe3a6365b79164c2fa483a48f6fe32c4f840125cd19d11e5d458025cc9cf05d2c0721135c0aa0ce084775d79fbee4efd9b7db074f0e3a1e7f672ba69efe9bcf8fc6fb553e2c9b1d7e600f406b88af0b8b006c61e909ed7db9320c70b869ff88f8f11c3e79d71d94897f3cae0822e8e3ddbbf81b43023e12736b2faa92f29fc383caff5932206e6153395e8833f19ec4171cc81dd775d8d5349c585ca044eb84f4fd183a75d31990857b38aa0426ecf0f1bff41f47063216776f23ae96f693c787e9e35d36246265573d528cc685b6a0c2cca12c10d06500513830dca2b5e1e4d389a427517fb7bf002774d7d5fb87ea84e4e6521c3b676a5a325783cb8ab69afbe702555e2d6208be6482b40eec233c3bb1d501491f7418796410d5a9e9e5ffec80c426481865ca8c0375d7b8ae159ff8e39e532f1f6b796a064ba7cf99ea4bc983ae215b79bc48aa50eec00b585b9df9d4a9241d3dd94dcc345eb5cd8cb9dd3de5695b2b0268444d3b588acc83b993fceaaf2a16d66b06573e3e6ef5e7eb45e61f0a2c53711e40025e3fd9b2a4a884866ec8fde5057c1066492d8f80f0bad181c8fd5f30266c67513f5c8bb5f3f893f50ea32e12d26702533a32dea087e3e6d6bef51c46527315614c228a87f5b5d1e2a9d5592165616453399419f0509410e4bcd002445c111b537220a395fb90ca84c3f6523b2e607faea783a56fcfe3ef1ef667512d3866695e0423b1dbf981fcbad1d4502e79656f68307291c988b498f9e1a427197f144b0e222003dcfb9199edd2eec34e7e0c5f0f467fe3ca9e9a9ee8d39a353f7d0d1c0e424bd599bceaeddfb5d9054d0c381c7d602fc1c928fd98f8b30d6e78166c020c5c69dbbca7dd96eccaaf3d26420f63035d2edab493efc5c2ba894842262f1155782ec997d59b3586e87d2980701d41012878ad0445f85534997c0e81771c43357b5ddfb0a3ea82846bb75a32776366563e449fc786b783836ab6593373c260173d45b8f6959395e1bca13b34743655052c74f8b050e5c555cd6153342a600b5146e566d13e55ba54f266523b2e525e7a325786cd9fa21ede27a2204a0937196d7026a19e9ca31ddf24a121491f14185e7125c09cdc903c8de17426897f144e082771a20d4af15a3d967b278e7e1b4a3a725ad6a89aee2b4a830e20cf7d0d1c0e457ed07b38df39fb31c8543d2d697b4c345982c8492ca929c12c3a4c1419135b7a288c8df3f8c6b8ceea7fc677db03036d6aef72f29fc7b7cfeb7cc734aba0d3397998c281bf91f2e8ad2810701d410128784d6495a985441d1d8f11b66c67540939db17924933f5aea33906761342323b43afc79186a6e7cfa23a47751574066a631cc685b31486daa05c3525610450a984b981e12431346cf192440b342e015331d3a39ed0fbf5b3c0534b0a361a2c4327858afa97cb8bc2f7513a2866695fa422c0ca89b28c8e65b1543c7f00bd9c9454d0aeb9e5e8dd85a137597f037a385755d7affee4efd9b7cc474f0e3f0b0be23fd2baf88edb0be33f549a7b7f19da212ea0cffd9dfc8ec5fd522839ed49983058d4ba9de9ecd982bd5f9b16cdb7792a28ab9d02e8e3d8be1a9f76d61a96628e29cfc726fb96f6bccb3c07e46f1172682eaeb3f19ec5870c686de505e971b53e38dc15e4e9e5861d996b25737dd600585ddf97b6ece7d1bfd30f47063216776bb6dad6f693c3c2ab5659226067026398b779b7f585d486cdf56940147014625911bcb4f4869585ccf153236a606b50262407d0ff959ce11632f63a7a174bfa3257829a4a869aecc3a6060b7916480a4177d1baa8e6e9df24a141490830bc3c3450458d3f803d1c14d5572f3e646f5c0221b7d9ff83fab8d7da56287f6b6e5e364cc7cf8ebfab8ad6bb5529185a7d7f354dd41af85f58bb11dcd02cc86e79a8a18da369c9ede918f069ef395619137b5a28ab9ca258c24dbbdf0bb2721f46068feaef67876bf337bdcbfcd7d519b5373d5b4c86305bd082dedc5816316d6050385d89c180bc90f1ecd95b547319a6004f799ad503e8f395bab43be2e3c767074e72deb087e3e6d21a975933e026d26398b779b7f585e486eae05c626561737")
                    },
                    [o("e1341175023b82769d")]: {
                        [o("5682769d28124c02378154")]: "fragmain",
                        [o("52107b1024847d")]: o("96542c5befc82888ac1f275dcdd105d9f359015fc5c901ce8b0d4064858151f5f7624a799ff94ce88c7fa563f2a6d4a7a93ded3abeb2e3b3833ee413bb9bb1d6970af91de993afc8ed2cc642d0d697b0c345eb5cdaba89cfde5a82b1d7318420c4b7cdde9579d069aafda1ff7175ab676bdaa9ed7872b4383ddebdc06610ac1633949bcf2919f91e5b8ad2f20703a5101487cd8b1a1ede0d0b8dc0b4652c8629528497a55539bd214ea761f47112216776a16dba7e7e3f1e28ec22c46126315715c228a87f592c486cdf05c35256164513a54d8a0517590907905e2441c211b746715d6a48ae0fce183c7234b1d661a7c5327858afac08b8be5e7511d3d020d7e3442c0ca89b10c2fd4e0c64ccda02dad45a1b1c988b498aec1a400097f144e084775d7b8aee4efdcb1bf230aca0e2bab43ac538bea9e5a5eb6cd10cb397a79de542ab2abcd8aec8ed2a8543a1d694b4c345985cd8cb89cfde5a82b18740db6999f59dbabb7dd96ecaaaf3d26420f63035d2edab493efc5c2bade0842013f1172682ea996f79b35870cbc5826355d7070385ab9c1a7ac90a6a9ac0801773b5600686ddfd0a2c8e224bbf28e16b76366563e338bb2335683420b838d17b46265520866acc6928690337894f830f56173043c5189e06144e1c02aa5e6814ec46e805220a395fb87da84c3f077dedf125f9d379217fe5e921eeab2c1204a2e27191a6402a46efdb749cb70a5201878754d7cf590c50c4dc448d871a4271c4a206e085040d27d3ad13bfd36ab314e7e1b4b9a934e9359fb5e5bba12dfd12f7d1a4c0e526bd5beaa7f38ebf03f51f8b95cb878b048d4aa8de9cbccb4ff1f28671c16682a28ab9ac6ece799bf78fe47663b16123a5f8bc3d59e92d4fbae2913711e4002497fd9b2a0ee81d7cda89dd565a8a1d56d89bd05e528353079ac2f1422c872c42ae97a71f78bd680cff76b42167216605b13beb6f6849787c9c35d11346265573d528cc685b395f6eca14c10e1c4714129e4797424b05585ccf465517fb77ea19755c2c49ca19bf4e792572b0b677d6e0247a3cb9de69afcd3a6060b7941080a5657d19db8e6cecbb1f2114968312d0d4430d418f8b2ddbc01a4271c4a606b1db26112792ee4c8c9b7db074f0e3a1e7f672ba69efefbcb1a13cf115bb8cfacde64ebd5bea8aca88ac1bc509b29cd79c921ec717cfc99cd8dd3e95b3c275d166c4a28bca9c388e28cdcae5a34136f45423a5f8bc382be92f3ebae2913717e44979c4b9dd7344b2052f86c5831252b0505ef487d6585fc90f1e9ac3801771c43353a4caec09089a7e0cea339467614770769621fc786b21787d9a35d362357117228260a62f1f6c182aca12c14744665054c70dcb5a5e1e4d4bcd002440b311b537220a395fb90ca84c3f6523b2e525e7a3257874fceb69afbe3a6365b79164c2fa483a48f6fe32c4f840125cd19d11e5d458025cc9cf05d2c0721135c0aa0ce084775d79fbee4efd9b7db074f0e3a1e7f672ba69efe9bcf8fc6fb553e2c9b1d7e600f406b88af0b8b006c61e909ed7db9320c70b869ff88f8f11c3e79d71d94897f3cae0822e8e3ddbbf81b43023e12736b2faa92f29fc383caff5932206e6153395e8833f19ec4171cc81dd775d8d5349c585ca044eb84f4fd183a75d31990857b38aa0426ecf0f1bff41f47063216776f23ae96f693c787e9e35d36246265573d528cc685b6a0c2cca12c10d06500513830dca2b5e1e4d389a427517fb7bf002774d7d5fb87ea84e4e6521c3b676a5a325783cb8ab69afbe702555e2d6208be6482b40eec233c3bb1d501491f7418796410d5a9e9e5ffec80c426481865ca8c0375d7b8ae159ff8e39e532f1f6b796a064ba7cf99ea4bc983ae215b79bc48aa50eec00b585b9df9d4a9241d3dd94dcc345eb5cd8cb9dd3de5695b2b0268444d3b588acc83b993fceaaf2a16d66b06573e3e6ef5e7eb45e61f0a2c53711e40025e3fd9b2a4a884866ec8fde5057c1066492d8f80f0bad181c8fd5f30266c67513f5c8bb5f3f893f50ea32e12d26702533a32dea087e3e6d6bef51c46527315614c228a87f5b5d1e2a9d5592165616453399419f0509410e4bcd002445c111b537220a395fb90ca84c3f6523b2e607faea783a56fcfe3ef1ef667512d3866695e0423b1dbf981fcbad1d4502e79656f68307291c988b498f9e1a427197f144b0e222003dcfb9199edd2eec34e7e0c5f0f467fe3ca9e9a9ee8d39a353f7d0d1c0e424bd599bceaeddfb5d9054d0c381c7d602fc1c928fd98f8b30d6e78166c020c5c69dbbca7dd96eccaaf3d26420f63035d2edab493efc5c2ba894842262f1155782ec997d59b3586e87d2980701d41012878ad0445f85534997c0e81771c43357b5ddfb0a3ea82846bb75a32776366563e449fc786b783836ab6593373c260173d45b8f6959395e1bca13b34743655052c74f8b050e5c555cd6153342a600b5146e566d13e55ba54f266523b2e525e7a325786cd9fa21ede27a2204a0937196d7026a19e9ca31ddf24a121491f14185e7125c09cdc903c8de17426897f144e082771a20d4af15a3d967b278e7e1b4a3a725ad6a89aee2b4a830e20cf7d0d1c0e457ed07b38df39fb31c8543d2d697b4c345982c8492ca929c12c3a4c1419135b7a288c8df3f8c6b8ceea7fc677db03036d6aef72f29fc7b7cfeb7cc734aba0d3397998c281bf91f2e8ad2810701d410128784d6495a985441d1d8f11b66c67540939db17924933f5aea33906761342323b43afc79186a6e7cfa23a47751574066a631cc685b31486daa05c3525610450a984b981e12431346cf192440b342e015331d3a39ed0fbf5b3c0534b0a361a2c4327858afa97cb8bc2f7513a2866695fa422c0ca89b28c8e65b1543c7f00bd9c9454d0aeb9e5e8dd85a137597f037a385755d7affee4efd9b7cc474f0e3f0b0be23fd2baf88edb0be33f549a7b7f19da212ea0cffd9dfc8ec5fd522839ed49983058d4ba9de9ecd982bd5f9b16cdb7792a28ab9d02e8e3d8be1a9f76d61a96628e29cfc726fb96f6bccb3c07e46f1172682eaeb3f19ec5870c686de505e971b53e38dc15e4e9e5861d996b25737dd600585ddf97b6ece7d1bfd30f47063216776bb6dad6f693c3c2ab5659226067026398b779b7f585d486cdf56940147014625911bcb4f4869585ccf153236a606b50262407d0ff959ce11632f63a7a174bfa3257829a4a869aecc3a6060b7916480a4177d1baa8e6e9df24a141490830bc3c3450458d3f803d1c14d5572f3e646f5c0221b7d9ff83fab8d7da56287f6b6e5e364cc7cf8ebfab8ad6bb5529185a7d7f354dd41af85f58bb11dcd02cc86e79a8a18da369c9ede918f069ef395619137b5a28ab9ca258c24dbbdf0bb2721f46068feaef67876bf337bdcbfcd7d519b5373d5b4c86305bd082dedc5816316d6050385d89c180bc90f1ecd95b547319a6004f799ad503e8f395bab43be2e3c767074e72deb087e3e6d21a975933e026d26398b779b7f585e486eae05c626561737")
                    }
                },
                [o("981bbf98f398ac0cc502")]: {
                    [o("b8fcae6ec4798bfda5")]: p.source,
                    [o("8b49de1f62307de7e1")]: p.source.style,
                    [o("5fe50fbb85fb97bb14")]: {
                        [o("59bf98e3b1a12ddf17b791f884af")]: {
                            value: [1, .5, .25, .5],
                            type: "vec4<f32>"
                        },
                        [o("39dfef09c5da4a0224e1a015a9d3")]: {
                            value: [0, 0],
                            type: "vec2<f32>"
                        },
                        [o("ef55a5070b50001492679f0c084909")]: {
                            value: [0, 0],
                            type: "vec2<f32>"
                        }
                    }
                }
            }),
            this.Sc = new tr({
                [o("a7bfcc7546b9596cd6")]: h,
                [o("9496be06fc0ca8")]: this.Rc
            })
        }
        function it() {
            this.u = new Ge,
            this.Xi = this.Ui = 0
        }
        function ze(h) {
            this.C = h,
            this.G = new T.Ee.De,
            this.eb = !1,
            this.oc = !0,
            this.ke = !1,
            this.Jg = this.kb = 0,
            this.Ma = 1,
            this.Kb = this.yf = 0,
            this.fa = {},
            this.Ta = 0,
            this.zb = new Float32Array(400),
            this.Ra = new Float32Array(400),
            this.Y = new Float32Array(400),
            this.U = this.ba = this.qa = this.dj = null,
            this.Zg()
        }
        function ot(h, p, _, g, v) {
            this.pa = h,
            this.ob = p,
            this.qb = _,
            this.jb = g,
            this.rb = v
        }
        function je(h) {
            this.A = new T.$f,
            this.A.Aa[o("66964c9d291345110a")](this.A.I),
            this.cc = null,
            this.dc = h,
            this.P = 0,
            this.bg = this.Xf = this.Vf = this.Tf = this.Qf = this.Nf = this.vc = 1,
            this.xk(o("31878157d3c0510e5fcc"))
        }
        function yt(h) {
            this.X = h
        }
        z.Ga = function(h) {
            var p = h.parent;
            p?.removeChild(h)
        }
        ,
        F.w = null,
        z.Zn = function(h) {
            return encodeURIComponent(h)
        }
        ,
        z.bo = function(h) {
            clearTimeout(h)
        }
        ,
        z.co = function(h) {
            var p = (Math.floor(h) % 60).toString()
              , _ = (Math.floor(h / 60) % 60).toString()
              , g = (Math.floor(h / 3600) % 24).toString()
              , v = (h = Math.floor(h / 86400).toString(),
            o("cf64b03b20"))
              , P = o("520b7b102494")
              , w = o("c15f2a9a")
              , R = o("0f3374e1");
            return 0 < h ? h + o("3a6ece7d") + v + o("3d0b8dc0") + g + o("7d4bcd00") + P + o("d2c6a6d5") + _ + o("8d5b3d70") + w + o("8e3a6211") + p + o("de4a9241") + R : 0 < g ? g + o("778d4bda") + P + o("eade9ecd") + _ + o("00f47063") + w + o("85533508") + p + o("afc58312") + R : 0 < _ ? _ + o("8074f0e3") + w + o("ff153342") + p + o("43d17706") + R : p + o("2bf91f2e") + R
        }
        ,
        z.fo = function(h) {
            return h.includes(o("043d34b26e")) ? h.replaceAll(o("59a2a9e9bb"), 'target="_black" href') : h
        }
        ,
        z.ho = function(h, p=null, _=null) {
            var g = T.d[o("39c9c909dcda5a352dd7ae11abc2")](o("2a488f4f47cf84"));
            o("e44048d38ddf43558959") !== typeof p && p !== null && (o("c94f25982858a66eb426") !== typeof p[o("5b6539")] && (g[o("a2da00")] = p[o("354fd3")]),
            o("0583e9dcec9c62d2689a") !== typeof p[o("6b7d1e278143")] && p[o("fc2c4db66eb2")] && (g[o("fbcd8e9711d3")] = o("23b5566fc9bb")),
            o("5692768d3f0d75033b8b") !== typeof p[o("23b04070c2aa")] && p[o("e8dd4f5d894f")] && (g[o("d12636623034")] = o("9acf39cbfb5d")),
            o("c78da75e2e9a2450aa64") !== typeof p[o("9327e7e9643b76f8f22bf4e0")]) && (g[o("3cee0c603362ede12df2ef79")] = p[o("be2cf23eb1a0eba7af30e137")]),
            g[o("edaa16d014")] = o("0a6fa9657abae2e77842a24465c4aac06a5f"),
            g[o("29e9d93f")] = h,
            _ && (g[o("cdd121ec3ea3b7")] = g[o("1a44b25f7bce84c85147854143d480d8445c89")] = function() {
                try {
                    _()
                } catch {}
                g[o("8af422f1e17e34")] = g[o("4b93234caa61b53b20703432b26bb12b356b38")] = null
            }
            ),
            (T.d[o("03dc6097e3")] || T.d[o("8afc29e9cb73354cf7cd20d6d45e0c48fde53dc0fb")](o("7b44180f9b"))[0])[o("0d9fffb0f46c77877d6ffbac")](g)
        }
        ,
        z.Z = function(h, p) {
            return p.prototype = Object.create(h.prototype),
            (p.prototype.constructor = p).parent = h,
            p
        }
        ,
        z.Il = function(h) {
            return (h %= 6.283185307179586) < 0 ? h + 6.283185307179586 : h
        }
        ,
        z.jo = function(h, p, _) {
            return z.Ic(_, h, p)
        }
        ,
        z.Ic = function(h, p, _) {
            return _ < h ? _ : h < p ? p : Number.isFinite(h) ? h : .5 * (p + _)
        }
        ,
        z.Q = function(h, p, _, g) {
            return h < p ? Math.min(p, h + _ * g) : Math.max(p, h - _ * g)
        }
        ,
        z.Gh = function(h, p, _) {
            return p + (h - p) * Math.pow(.5, _ / 33.333)
        }
        ,
        z.ye = function(h, p, _) {
            return h - (h - p) * _
        }
        ,
        z.dg = function(h, p) {
            return Math.sqrt(h * h + p * p)
        }
        ,
        z.Pl = function(h, p) {
            var g = 0 + p;
            if (h == null)
                throw new TypeError;
            var v = h.length >>> 0
              , _ = (p = Math.min(1, v),
            Math.min(0, v))
              , g = g === void 0 ? v : g >> 0
              , v = Math.min((g < 0 ? Math.max(v + g, 0) : Math.min(g, v)) - _, v - p);
            for (g = 1,
            _ < p && p < _ + v && (g = -1,
            _ += v - 1,
            p += v - 1); 0 < v; )
                _ in h ? h[p] = h[_] : delete h[p],
                _ += g,
                p += g,
                v--
        }
        ,
        z.uo = function(h, p, _, g) {
            var v = 6.283185307179586 * Math.random();
            return [h + (_ = Math.sqrt(_ * _ + Math.random() * (g - _) * (g + _))) * Math.cos(v), p + _ * Math.sin(v)]
        }
        ,
        z.Wl = function() {
            return 2147483647 * Math.random()
        }
        ,
        z.am = function() {
            var h = [32, 33, 34, 35];
            return h[parseInt(Math.random() * h.length)]
        }
        ,
        z.wo = (t = [o("7abb"), o("e888"), o("00e3"), o("74f6"), o("f71c"), o("c2e6"), o("f0f7"), o("c90d"), o("5019"), o("8b05"), o("9aca"), o("9ac9"), o("51a1"), o("5ff4"), o("0d9b"), o("d443"), o("a5f1"), o("140d"), o("b943"), o("6a11"), o("b8e2"), o("9489"), o("306c"), o("b46b"), o("1886"), o("d5b6"), o("3719"), o("c140"), o("8d0d"), o("9c99"), o("a480"), o("fbda"), o("6fd7"), o("0f38"), o("ddb7"), o("0a61")].map(function(h) {
            return h.charCodeAt(0)
        }),
        function(h) {
            o("44e0e8732d7fe3f529f9") == typeof h && (h = 16);
            for (var p = "", _ = 0; _ < h; _++)
                p += String.fromCharCode(t[Math.floor(Math.random() * t.length)]);
            return p
        }
        ),
        z.xo = function(h, p, _, g) {
            p = _ * (1 - .5 * p);
            var v = Math.min(p, 1 - p);
            return z.qg(h, v ? (_ - p) / v : 0, p, g)
        }
        ,
        z.qg = function(h, p, _, g) {
            var v = (p *= 1 - Math.abs(2 * _ - 1)) * (1 - Math.abs(h / 60 % 2 - 1));
            return _ -= p / 2,
            0 <= h && h < 60 ? [_ + p, _ + v, _, g] : 60 <= h && h < 120 ? [_ + v, _ + p, _, g] : 120 <= h && h < 180 ? [_, _ + p, _ + v, g] : 180 <= h && h < 240 ? [_, _ + v, _ + p, g] : 240 <= h && h < 300 ? [_ + v, _, _ + p, g] : [_ + p, _, _ + v, g]
        }
        ,
        z.Ve = function() {
            return Date.now()
        }
        ,
        z.Vd = function(h, p) {
            for (var _ in h)
                h.hasOwnProperty(_) && p(_, h[_])
        }
        ,
        z.Bo = function(h) {
            for (var p = h.length - 1; 0 < p; p--) {
                var _ = Math.floor(Math.random() * (p + 1))
                  , g = h[p];
                h[p] = h[_],
                h[_] = g
            }
            return h
        }
        ,
        T.oh = Xi(o("03f57784e6c1cb8f6dda688c")),
        T.vf = Xi(o("f126125014309e4d8e")),
        T.Xm = ( () => {
            function h(G) {
                this.Qa = G,
                this.B = 0
            }
            let p = o("b0e69777fd6b82bf")
              , _ = (h.prototype.n = function() {
                var G = this.Qa[p](this.B);
                return this.B += 1,
                G
            }
            ,
            o("44f2e3631d70e4ef74"))
              , g = (h.prototype.Gb = function() {
                var G = this.Qa[_](this.B);
                return this.B += 1,
                G
            }
            ,
            o("1c0a3b9b75980c071543"))
              , v = (h.prototype.E = function() {
                var G = this.Qa[g](this.B);
                return this.B += 2,
                G
            }
            ,
            o("cb1ba8ca06ee25f3e5"))
              , P = (h.prototype.s = function() {
                var G = this.Qa[v](this.B);
                return this.B += 2,
                G
            }
            ,
            o("da8cf9999701d442d0"))
              , w = (h.prototype.Hg = function() {
                var G = this.Qa[P](this.B);
                return this.B += 4,
                G
            }
            ,
            o("6531826cbc3305685e6c"))
              , R = (h.prototype.pn = function() {
                var G = this.Qa[w](this.B);
                return this.B += 4,
                G
            }
            ,
            o("d284f191900bf708aed8ae"));
            return h.prototype.f = function() {
                var G = this.Qa[R](this.B);
                return this.B += 4,
                G
            }
            ,
            h
        }
        )(),
        T.ah = ( () => {
            function h(w) {
                this.Qa = w,
                this.B = 0
            }
            var p = o("19f9fe38d4e06b68");
            h.prototype.Yf = function(w) {
                this.Qa[p](this.B, w),
                this.B += 1
            }
            ;
            let _ = o("b8fa9f7fe96490fbf8");
            h.prototype.Sm = function() {
                this.Qa[_](this.B, 99),
                this.B += 1
            }
            ;
            var g = o("ce2cf5159b8de0d4e0")
              , v = (h.prototype.Eb = function(w) {
                this.Qa[g](this.B, w),
                this.B += 2
            }
            ,
            o("7af859f92b662e65b3a5"))
              , P = (h.prototype.vn = function(w) {
                this.Qa[v](this.B, w),
                this.B += 2
            }
            ,
            o("2d6dca94e44b5d900614"));
            return h.prototype.An = function(w) {
                this.Qa[P](this.B, w),
                this.B += 4
            }
            ,
            h
        }
        )(),
        T.Wn = function() {}
        ,
        T.Db = (x.mg = function() {
            return new x("",null,0,0,0,0,0,0,0,0)
        }
        ,
        x.im = function(h, p, _) {
            return new x(h,p,_[o("6b2d")],_[o("177a")],_[o("f6b4")],_[o("993e")],_[o("e084")],_[o("6d68")],_[o("177f")],_[o("b912")])
        }
        ,
        x.prototype.rg = function() {
            return this.Kh || (this.Hh != null && (this.Texture = new Z({
                source: this.Hh,
                frame: new Re(this.mb,this.nb,this.gg,this.hg)
            })),
            this.Kh = !0),
            this.Texture
        }
        ,
        x.prototype.Od = function() {
            this.Texture != null && this.Texture[o("4cf9eb6c2453fdda")]()
        }
        ,
        x),
        T.wg = (y.prototype.Od = function() {
            for (var h = 0; h < this.zg.length; h++)
                this.zg[h][o("fd8a1ac3f5806ccd")]();
            for (this.zg = [],
            h = 0; h < this.Ag.length; h++)
                this.Ag[h].Od();
            this.Ag = []
        }
        ,
        y.mg = function() {
            var h = new y.me(T.La.Sa,T.La.Sa)
              , p = new y.ld(o("a93f19ef4b78c986d744"),[T.La.Sa],[T.La.Sa],[1]);
            return new y([],[],{},{},{},p,{},new y.oe("",p,h),{},new y.oa([T.La.Sa]),{},new y.oa([T.La.Sa]),{},new y.oa([T.La.Sa]),{},new y.oa([T.La.Sa]))
        }
        ,
        y.pk = function(h, p, _) {
            var g = new y.me(T.La.Sa,T.La.Sa);
            return h = new y.ld(o("b10701d75340d18edf4c"),[h],[16777215],[1]),
            new y([],[],{},{},{},h,{},new y.oe("",h,g),{},new y.oa([p]),{},new y.oa([_]),{},new y.oa([T.La.Sa]),{},new y.oa([T.La.Sa]))
        }
        ,
        y.tk = function(h, p, _, g) {
            var v = {};
            z.Vd(h[o("0a29")], function(Me, Le) {
                v[Me] = o("89df398f") + Le
            });
            for (var P, w, R = {}, G = 0; G < h[o("de1ccb188cb2d687870eec10898f")].length; G++) {
                var C = h[o("fd9d14d9efb371c6648fc3d1ea8e")][G];
                R[C[o("95ef73")]] = new y.ld(v[C[o("3f0033dbae11")]],C[o("0594e6cbec")].map(function(Me) {
                    return p[Me]
                }),C[o("5a0c700229")],C[o("af81dd525b85")])
            }
            G = new y.ld(16777215,[p[o("05c6")]],[16777215],[1]),
            C = {};
            for ([P,w] of Object.entries(h[o("62165d1015b3419a1e")]))
                C[parseInt(P)] = new y.oa([p[w[0]]]);
            var X, H, ee = new y.oa([p[o("b0b0")]]), de = {};
            for ([X,H] of Object.entries(h[o("750b985d8d020868140d8b")]))
                de[parseInt(X)] = new y.oa([p[H[0]]]);
            var me, q, V = new y.oa([p[o("cae9")]]), I = {};
            for ([me,q] of Object.entries(h[o("653e866c9a1e027f19")]))
                I[parseInt(me)] = new y.oa(me === "0" ? [] : [p[q[0]]]);
            var K, te, Fe = new y.oa([]), pt = {};
            for ([K,te] of Object.entries(h[o("8afc20fcfd6c3552d6ca37d1")]))
                pt[parseInt(K)] = new y.oa(K === "0" ? [] : [p[te[0]]]);
            var fe = new y.oa([])
              , Ee = {}
              , Ce = (z.Vd(h[o("1576f8baed6374a25967fca4")], function(Me, Le) {
                Me = parseInt(Me),
                Ee[Me] = new y.me(p[Le[o("6695498a0f")]],p[Le[o("a2d408dad1")]])
            }),
            {})
              , we = (z.Vd(h[o("64d4c45e0450dec228d4cd4b")], function(Me, Le) {
                Me = parseInt(Me),
                Ce[Me] = new y.Vj(p[Le[o("4fe230b1b6")]])
            }),
            {});
            return z.Vd(h[o("a0058792c9b18f14dc")], function(Me, Le) {
                Me = parseInt(Me),
                we[Me] = new y.oe(Le[o("b8fd937fd068")],new y.ld(v[Le[o("c624e330a4")][o("37184bc3d609")]],null,Le[o("ac8e8516de")][o("cdd923ef26")].map(function(Ri) {
                    return p[Ri]
                }),[1]),new y.me(null,p[Le[o("5b7c323cab798e3c")][o("fa6cd06289")]]))
            }),
            h = new y.oe({},G),
            new y(_,g,Ee,Ce,R,G,we,h,C,ee,de,V,I,Fe,pt,fe)
        }
        ,
        y.prototype.qe = function(h) {
            return this.Ji.hasOwnProperty(h) ? this.Ji[h] : this.en
        }
        ,
        y.prototype.re = function(h) {
            return this.Si.hasOwnProperty(h) ? this.Si[h] : this.qn
        }
        ,
        y.prototype.zh = function(h) {
            return this.vb.hasOwnProperty(h) ? this.vb[h] : this.Bn
        }
        ,
        y.prototype.Bh = function(h) {
            return this.bj.hasOwnProperty(h) ? this.bj[h] : this.Mn
        }
        ,
        y.prototype.Dh = function(h) {
            return this.Xg.hasOwnProperty(h) ? this.Xg[h] : this.yj
        }
        ,
        y.prototype.Zf = function(h) {
            return this.fj.hasOwnProperty(h) ? this.fj[h] : this.pj
        }
        ,
        y.prototype.fl = function(h) {
            return this.Fm[h]
        }
        ,
        y.prototype.Lh = function(h) {
            return this.Tm[h]
        }
        ,
        y.oe = function(h, p) {
            this.Ce = p
        }
        ,
        y.ld = function(h, p, _, g) {
            this.ig = h,
            this.Ja = p,
            this.Dd = _,
            this.Hf = g ||= [1]
        }
        ,
        y.oa = function(h) {
            this.Ja = h
        }
        ,
        y.me = function(h, p) {
            this.Ja = h,
            this.Dd = p
        }
        ,
        y.Vj = function(h) {
            this.Ja = h
        }
        ,
        y),
        T.La = (S.prototype.init = async function() {
            var h = (await Te.load(o("6b395f18864d900516575054b1499b03174509079a435e40ad43e01477"))).source
              , p = (await Te.load(o("0c787c99798c3304711673d55e8e36046b432e8147"))).source
              , _ = (this.Jl = new T.Db(o("4a2d693121bc79952b3c75073f8b719d23"),h,0,0,128,128,350,100,220,220),
            this.Ln = new T.Db(o("2ed99ca44a1c95275fab91bd43"),h,128,0,128,128,350,220,220,220),
            this.El = new T.Db(o("172578edf529e9d17e3248feca20dc"),h,256,0,128,128,148,63.5,128,128),
            this.hh = new T.Db(o("0592e2ded68960d563a1e8acfe75"),p,0,0,32,32,0,0,0,0),
            (await Te.load(o("8553357e6017ea5be80d2a7257e6f622b8ea782772a4eb22fa"))).source)
              , h = new T.Db(o("af84d4446c814c43c4"),_,0,0,42,80,75,64,128,128)
              , p = new T.Db(o("8035a7b5dbb8a922fc31"),_,46,0,20,48,109,63,128,128)
              , _ = new T.Db(o("0c392bb94f92390a7a3a34866b8c"),_,46,52,64,64,0,0,0,0);
            h = T.wg.pk(_, h, p),
            this.bb = new T.gi({},h),
            this.gc = this.ji = -1e4,
            (h = T.mf.document.createElement(o("0919ea52fb1f7c"))).width = 80,
            h.height = 80,
            this.og = {
                ic: h,
                ri: h.getContext(o("276a4d"), {
                    willReadFrequently: !0
                }),
                Rd: new Z({
                    source: He.from(h)
                })
            },
            this.ad = null,
            this.Bg = []
        }
        ,
        S.Sa = T.Db.mg(),
        S.prototype.m = function() {}
        ,
        S.prototype.Ai = function(h, p, _) {
            var g, v = this, P = this.bb.Ci();
            this.ji === 1 ? h?.() : ((g = new T.an(P)).gn(function(w, R) {
                g === v.ad && _ != null && _(w, R)
            }),
            g.kn(function(w) {
                g === v.ad && p != null && p(w)
            }),
            g.rn(function() {
                g === v.ad && p != null && p(Error())
            }),
            g.Cn(function(w) {
                if (g === v.ad) {
                    v.gc = z.Ve(),
                    v.ad = null,
                    v.bb.S().Od(),
                    v.bb = w,
                    F.w.L.af(),
                    h?.();
                    for (let G of k["1ag"])
                        F.w.l.ua(G, T.j.T) || (k["1ag"] = k["1ag"].filter(C => C !== G));
                    for (var R in k["1ah"])
                        if (k["1ah"][R])
                            for (let G of k["1ah"][R])
                                F.w.l.ua(G, R) || (k["1ah"][R] = k["1ah"][R].filter(C => C !== G));
                    v.Rn()
                } else
                    try {
                        w.S().Od()
                    } catch {}
            }),
            g.qj(),
            this.ji = 1,
            this.ad = g)
        }
        ,
        S.prototype.je = function() {
            return 0 < this.bb.Ci()
        }
        ,
        S.prototype.uf = function(h) {
            this.Bg.push(h)
        }
        ,
        S.prototype.Rn = function() {
            for (var h = 0; h < this.Bg.length; h++)
                this.Bg[h]()
        }
        ,
        S.prototype.S = function() {
            return this.bb.S()
        }
        ,
        S),
        T.Qj = (A.prototype.Dc = function(h) {
            return this.xf[h]
        }
        ,
        A.ik = (E.prototype.od = function(h, p) {
            for (var _ = 0; _ < this.bc.length; _++)
                if (this.bc[_].th === h)
                    throw Error();
            return this.bc.push(new A.Ck(h,p)),
            this
        }
        ,
        E.prototype.Jk = function() {
            for (var h = 0, p = 0; p < this.bc.length; p++)
                h += this.bc[p].se;
            for (var p = {}, _ = 0, g = 0; g < this.bc.length; g++) {
                var v = this.bc[g];
                v.se /= h,
                v.Sf = _,
                v.Uf = _ + v.se,
                _ = v.Uf,
                p[v.th] = v
            }
            return new A(p)
        }
        ,
        E),
        A.Ck = (O.prototype.Eh = function(h) {
            return this.Sf + (this.Uf - this.Sf) * h
        }
        ,
        O),
        A),
        T.$f = (M.Kl = 797,
        M.prototype.Ph = function(h, p, _) {
            var g = new s(p,_);
            return p.u.zIndex = .001 * (2 * (797 - h) + 1 + 3),
            _.u.zIndex = .001 * (2 * (797 - h) - 2 + 3),
            g
        }
        ,
        M.prototype.Vc = function(h, p, _, g, v, P, w) {
            var R = _.Ja
              , G = (h === T.Rb.Xc ? p.Ce : _).Dd;
            if (h = (h === T.Rb.Xc ? p.Ce : _).Hf,
            0 < R.length && 0 < G.length)
                for (p = 0; p < this.i.length; p++)
                    this.i[p].J.sb(R[p % R.length]),
                    this.i[p].id.sb(F.w.o.hh),
                    this.i[p].id.Pd(G[p % G.length]),
                    this.i[p].id.u.alpha = h[p % h.length];
            this.I.Vc(g, v, P, w)
        }
        ,
        M.prototype.wm = function(h) {
            F.w.h.W.G.hb = h,
            h = (_ = F.w.o.S().qe(h)).Ja;
            var p = _.Dd
              , _ = _.Hf;
            if (h.length && p.length)
                for (let g = 0; g < this.i.length; ++g)
                    this.i[g].J.sb(h[g % h.length]),
                    this.i[g].id.sb(F.w.o.hh),
                    this.i[g].id.Pd(p[g % p.length]),
                    this.i[g].id.u.alpha = _[g % _.length]
        }
        ,
        M.prototype.um = function(h) {
            F.w.h.W.G.Uc = h,
            h = F.w.o.S().Zf(h),
            this.I.de(.004, this.I.Tb, h.Ja)
        }
        ,
        r = ( () => {
            class h extends _e {
                constructor() {
                    super(),
                    this.sortableChildren = !0,
                    this.rc = [],
                    this.sc = [],
                    this.tc = [],
                    this.Tb = [],
                    this.Xd = new _e,
                    this.Zd = [];
                    for (var _ = 0; _ < 4; _++) {
                        var g = new T.pb;
                        g.sb(F.w.o.El),
                        this.Xd.addChild(g.u),
                        this.Zd.push(g)
                    }
                    this.Xd.zIndex = .0011,
                    this.addChild(this.Xd),
                    this.Ki(),
                    this.Wb = new T.pb,
                    this.Wb.sb(F.w.o.Jl),
                    this.Wb.u.zIndex = .001,
                    this.z = new T.pb,
                    this.z.sb(F.w.o.Ln),
                    this.z.u.zIndex = .001,
                    this.addChild(this.Wb.u),
                    this.addChild(this.z.u),
                    this.Ti()
                }
            }
            return h.prototype.Vc = function(p, _, g, v) {
                this.de(.002, this.rc, p.Ja),
                this.de(.003, this.sc, _.Ja),
                this.de(.004, this.Tb, v.Ja),
                this.de(.005, this.tc, g.Ja)
            }
            ,
            h.prototype.de = function(p, _, g) {
                for (; g.length > _.length; ) {
                    var v = new T.pb;
                    _.push(v),
                    this.addChild(v.u)
                }
                for (; g.length < _.length; )
                    _.pop().xc();
                for (v = 0; v < g.length; v++) {
                    p += 1e-4;
                    var P = _[v];
                    P.sb(g[v]),
                    P.u.zIndex = p
                }
            }
            ,
            h.prototype.aa = function(p, _, g, v) {
                for (this.visible = !0,
                this.position.set(p, _),
                this.rotation = v,
                p = 0; p < this.rc.length; p++)
                    this.rc[p].ib(g);
                for (p = 0; p < this.sc.length; p++)
                    this.sc[p].ib(g);
                for (p = 0; p < this.tc.length; p++)
                    this.tc[p].ib(g);
                for (p = 0; p < this.Tb.length; p++)
                    this.Tb[p].ib(g)
            }
            ,
            h.prototype.ia = function() {
                this.visible = !1
            }
            ,
            h.prototype.rj = function(p, _) {
                this.Xd.visible = !0,
                _ /= 1e3;
                for (var g = 1 / this.Zd.length, v = 0; v < this.Zd.length; v++) {
                    var P = 1 - (_ + g * v) % 1;
                    this.Zd[v].u.alpha = 1 - P,
                    this.Zd[v].ib(p * (.5 + 4.5 * P))
                }
            }
            ,
            h.prototype.Ki = function() {
                this.Xd.visible = !1
            }
            ,
            h.prototype.Fn = function(p) {
                k["1s"] === 1 && (this.z.u.visible = !0,
                this.z.ib(p))
            }
            ,
            h.prototype.Ok = function() {
                this.z.u.visible = !1
            }
            ,
            h.prototype.wj = function(p, _, g) {
                this.Wb.u.visible = !0,
                this.Wb.u.alpha = z.Q(this.Wb.u.alpha, p.ke ? .9 : .2, g, .0025),
                this.Wb.ib(_)
            }
            ,
            h.prototype.Ti = function() {
                this.Wb.u.visible = !1
            }
            ,
            h
        }
        )(),
        M.prototype.Ka = function(h) {
            return this.Uh + this.Wh * Math.sin(.3141592653589793 * h - this.Tg)
        }
        ,
        M.prototype.Ej = function(h, p, _, g) {
            var v = 2 * h.kb
              , P = h.Y
              , w = h.Ta
              , R = 4 * w - 3
              , G = (this.Tg = p / 400 * 3.141592653589793,
            this.Uh = 1.5 * v,
            this.Wh = .15 * v * h.yf,
            P[0])
              , C = P[1];
            g(G, C) ? (ee = P[2],
            de = P[3],
            me = P[4],
            q = P[5],
            X = Math.atan2(q + 2 * C - 3 * de, me + 2 * G - 3 * ee),
            this.I.aa(G, C, v, X),
            this.i[0].aa(G, C, v, this.Ka(0), X),
            this.i[1].aa(.64453125 * G + .45703125 * ee + -.1015625 * me, .64453125 * C + .45703125 * de + -.1015625 * q, v, this.Ka(1), s.Ua(this.i[0], this.i[2])),
            this.i[2].aa(.375 * G + .75 * ee + -.125 * me, .375 * C + .75 * de + -.125 * q, v, this.Ka(2), s.Ua(this.i[1], this.i[3])),
            this.i[3].aa(.15234375 * G + .94921875 * ee + -.1015625 * me, .15234375 * C + .94921875 * de + -.1015625 * q, v, this.Ka(3), s.Ua(this.i[2], this.i[4]))) : (this.I.ia(),
            this.i[0].ia(),
            this.i[1].ia(),
            this.i[2].ia(),
            this.i[3].ia());
            for (var X, H, ee, de, me, q, V = 4, I = 2, K = 2 * w - 4; I < K; I += 2)
                g(G = P[I], C = P[I + 1]) ? (X = P[I - 2],
                H = P[I - 1],
                ee = P[I + 2],
                de = P[I + 3],
                me = P[I + 4],
                q = P[I + 5],
                this.i[V].aa(G, C, v, this.Ka(V), s.Ua(this.i[V - 1], this.i[V + 1])),
                V++,
                this.i[V].aa(-.06640625 * X + .84375 * G + .2578125 * ee + -.03515625 * me, -.06640625 * H + .84375 * C + .2578125 * de + -.03515625 * q, v, this.Ka(V), s.Ua(this.i[V - 1], this.i[V + 1])),
                V++,
                this.i[V].aa(-.0625 * X + .5625 * G + .5625 * ee + -.0625 * me, -.0625 * H + .5625 * C + .5625 * de + -.0625 * q, v, this.Ka(V), s.Ua(this.i[V - 1], this.i[V + 1])),
                V++,
                this.i[V].aa(-.03515625 * X + .2578125 * G + .84375 * ee + -.06640625 * me, -.03515625 * H + .2578125 * C + .84375 * de + -.06640625 * q, v, this.Ka(V), s.Ua(this.i[V - 1], this.i[V + 1]))) : (this.i[V].ia(),
                V++,
                this.i[V].ia(),
                V++,
                this.i[V].ia(),
                V++,
                this.i[V].ia()),
                V++;
            for (g(G = P[2 * w - 4], C = P[2 * w - 3]) ? (X = P[2 * w - 6],
            H = P[2 * w - 5],
            ee = P[2 * w - 2],
            de = P[2 * w - 1],
            this.i[R - 5].aa(G, C, v, this.Ka(R - 5), s.Ua(this.i[R - 6], this.i[R - 4])),
            this.i[R - 4].aa(-.1015625 * X + .94921875 * G + .15234375 * ee, -.1015625 * H + .94921875 * C + .15234375 * de, v, this.Ka(R - 4), s.Ua(this.i[R - 5], this.i[R - 3])),
            this.i[R - 3].aa(-.125 * X + .75 * G + .375 * ee, -.125 * H + .75 * C + .375 * de, v, this.Ka(R - 3), s.Ua(this.i[R - 4], this.i[R - 2])),
            this.i[R - 2].aa(-.1015625 * X + .45703125 * G + .64453125 * ee, -.1015625 * H + .45703125 * C + .64453125 * de, v, this.Ka(R - 2), s.Ua(this.i[R - 3], this.i[R - 1])),
            this.i[R - 1].aa(ee, de, v, this.Ka(R - 1), s.Ua(this.i[R - 2], this.i[R - 1]))) : (this.i[R - 5].ia(),
            this.i[R - 4].ia(),
            this.i[R - 3].ia(),
            this.i[R - 2].ia(),
            this.i[R - 1].ia()),
            this.P === 0 && 0 < R && this.Aa.addChild(this.I),
            0 < this.P && R == 0 && z.Ga(this.I); this.P < R; )
                this.Aa.addChild(this.i[this.P].J.u),
                this.Aa.addChild(this.i[this.P].id.u),
                this.P += 1;
            for (; this.P > R; )
                --this.P,
                this.i[this.P].id.xc(),
                this.i[this.P].J.xc();
            g = h.fa[T.Fc.uk],
            this.i[0].qd() && g != null && g.ra ? this.I.rj(v, p) : this.I.Ki(),
            p = h.fa[T.Fc.Xk],
            this.i[0].qd() && p != null && p.ra ? this.I.wj(h, v, _) : this.I.Ti(),
            h = h.fa[T.Fc.Qn],
            this.i[0].qd() && h != null && h.ra ? this.I.Fn(v) : this.I.Ok()
        }
        ,
        j.prototype.aa = function(h, p, _, g, v) {
            this.J.za(!0),
            this.J.ue(h, p),
            this.J.ib(_),
            this.J.Fh(v),
            this.id.za(!0),
            this.id.ue(h, p),
            this.id.ib(g),
            this.id.Fh(v)
        }
        ,
        j.prototype.ia = function() {
            this.J.za(!1),
            this.id.za(!1)
        }
        ,
        j.prototype.qd = function() {
            return this.J.qd()
        }
        ,
        j.Ua = function(h, p) {
            return Math.atan2(h.J.u.position.y - p.J.u.position.y, h.J.u.position.x - p.J.u.position.x)
        }
        ,
        s = j,
        M),
        T.Fc = (L.Xk = 0,
        L.Qn = 1,
        L.uk = 2,
        L.ml = 6,
        L),
        T.gi = (T.wg.mg(),
        N.prototype.Ci = function() {
            return this.Xb[o("f6b7")]
        }
        ,
        N.prototype.S = function() {
            return this.xl
        }
        ,
        N),
        T.an = (Y.uc = {
            Gm: o("7abb44bd"),
            Lm: o("7b1c055f"),
            Um: o("edee1792"),
            Ii: o("3d1ec7c3"),
            Li: o("56d760dd")
        },
        Y.Sl = 1e5,
        Y.Oi = new T.Qj.ik().od(Y.uc.Gm, 1).od(Y.uc.Lm, 10).od(Y.uc.Um, 50).od(Y.uc.Ii, 15).od(Y.uc.Li, 5).Jk(),
        Y.prototype.Cn = function(h) {
            this.hi = h
        }
        ,
        Y.prototype.kn = function(h) {
            this.ki = h
        }
        ,
        Y.prototype.rn = function(h) {
            this.mi = h
        }
        ,
        Y.prototype.gn = function(h) {
            this.oi = h
        }
        ,
        Y.prototype.pc = function() {
            return this.Sb
        }
        ,
        Y.prototype.qj = function() {
            this.ti || (this.ti = !0,
            this.Qd ? this.hf() : this.Nn())
        }
        ,
        Y.prototype.Nn = async function() {
            if (this.Qd)
                this.hf();
            else
                try {
                    var h = await ve[o("6cdbcb4b1329")](o("76220a4f17ee58e41f2a7257f0f623fcf5633a60a4ec23efe365394dfec2"))
                      , p = JSON.parse(o(await h.text()));
                    this.Sn(p)
                } catch {
                    this.Dn()
                }
        }
        ,
        Y.prototype.Sn = function(h) {
            if (k["1e"])
                try {
                    if ((v = JSON.parse(k["1e"])) && v[o("8cbba733f5")]) {
                        h[o("7b1d")][o("288e1e09731e1b8c446e1fdc46ea")] = v[o("0ef9b9cd77")];
                        for (var p = [], _ = Math.min(v[o("209d071d")], 9), g = v[o("e294c89a91")].map(X => Math.min(Math.max(X, 0), 16777215)), v = 0; v < _; v++)
                            p.push(o("3d59cb829e5136873159aaa7ba51229212") + (_ - 1 - v)),
                            h[o("1456")][o("dc5a6addbfd25740905a4be89bd24355b3") + v] = {
                                [o("2203")]: o("d77fad38046f283dab7f8c0d117b"),
                                [o("9375")]: 128 * v,
                                [o("0ead")]: 0,
                                [o("0c6e")]: 128,
                                [o("5b38")]: 128
                            };
                        h[o("1bbf7667f191d36042ad617fc4ac")].push({
                            [o("fee6a4")]: 19999,
                            [o("c5c6351124df")]: "0",
                            [o("44f7e7642d")]: p,
                            [o("10863e0c63")]: g,
                            [o("2522")]: 3,
                            [o("c420")]: 0
                        }),
                        h[o("e72c")].unshift({
                            [o("a33ac4fb42")]: o("4bb0225dae6cf47063573e2fb97b"),
                            [o("867b216afe")]: [19999]
                        })
                    }
                } catch {}
            if (k["1j"])
                try {
                    var P, w = JSON.parse(k["1j"]);
                    w && w[o("e8df435789")] && (h[o("be7e")][o("d77fad38046f283dab7f8c0d14710424")] = w[o("9483bf0bfd")],
                    h[o("b111")][o("9016a691cb86a314ec06b7b4eb88bf1dff41")] = {
                        [o("ce6f")]: o("babc08bfe12cf522b6bce98ab132e92b"),
                        [o("3cbc")]: w[o("67e0")],
                        [o("0c6f")]: w[o("b0f8")],
                        [o("5b3f")]: w[o("2bab")],
                        [o("adaa")]: w[o("b0e9")],
                        [o("1bf9")]: w[o("8aeb34")],
                        [o("4265")]: w[o("31d2ca")],
                        [o("8e28")]: 130,
                        [o("a049")]: 130
                    },
                    P = w[o("a7acd06a4e")].toLowerCase(),
                    h[P + o("30451be040")][o("7e367928")] = {
                        [o("8d4e")]: o("26c09ccb7558994e5ad09d9e4526953769f7"),
                        [o("1d3a")]: 0
                    })
                } catch {}
            var R = this;
            if (this.Qd)
                this.hf();
            else {
                var G, C = [], p = [], _ = [];
                for (G in h[o("b113")])
                    h[o("5010")].hasOwnProperty(G) && (g = h[o("97f9")][G],
                    w = new Y.sj(G,g,1,1),
                    C.push(w),
                    p.push(w),
                    _.push(g),
                    Te.add({
                        [o("44f4ea7e296a")]: g,
                        [o("cf73a321")]: g
                    }));
                Te.load(_, function(ee) {
                    var de = Y.uc.Ii;
                    R.Zi(de, Y.Oi.Dc(de).Eh(+ee))
                }).then(ee => {
                    C.forEach(function(de) {
                        de.texture = ee[de.Jj]
                    }),
                    R.Fj(h, C)
                }
                )
            }
        }
        ,
        Y.prototype.Fj = function(h, p) {
            var _, g, v, P = this;
            this.Qd ? this.hf() : (g = {},
            v = 0,
            (function w() {
                v < p.length ? (_ = p[v++],
                g[_.H] = new T.Wj(_.texture,_.texture.source),
                w()) : Ht(function() {
                    return P.ck(h, g)
                }, 0)
            }
            )())
        }
        ,
        Y.prototype.ck = function(h, p) {
            var _ = this
              , g = {}
              , v = 0
              , P = Object.values(h[o("cc2e")]).length
              , w = (z.Vd(h[o("febc")], function(C, X) {
                X = T.Db.im(X[o("05c6")] + o("5eca13b0") + C, p[X[o("34b5")]].Rd, X),
                g[C] = X,
                ++v % 10 == 0 && (C = Y.uc.Li,
                _.Zi(C, Y.Oi.Dc(C).Eh(v / P)))
            }),
            Object.values(p).map(function(C) {
                return C.Rd
            }))
              , R = Object.values(g)
              , G = new T.gi(h,T.wg.tk(h, g, w, R));
            Ht(function() {
                return _.jk(G)
            }, 0)
        }
        ,
        Y.sj = function(h, p) {
            this.H = h,
            this.Jj = p
        }
        ,
        Y.prototype.jk = function(h) {
            var p;
            this.Sb ? h.S().Od() : (this.Sb = !0,
            p = this,
            Ht(function() {
                return p.hi(h)
            }, 0))
        }
        ,
        Y.prototype.Dn = function() {
            var h, p = Error();
            this.Sb || (this.Sb = !0,
            h = this,
            Ht(function() {
                return h.ki(p)
            }, 0))
        }
        ,
        Y.prototype.hf = function() {
            var h;
            this.Sb || (this.Sb = !0,
            h = this,
            Ht(function() {
                return h.mi()
            }, 0))
        }
        ,
        Y.prototype.Zi = function(h, p) {
            var _;
            this.Sb || this.Qd || (_ = this,
            Ht(function() {
                return _.oi(h, p)
            }, 0))
        }
        ,
        Y),
        T.io = {},
        T.yk = (ie.prototype.m = function() {}
        ,
        ie),
        T.na = ($.dk = o("49cda623aed121f334aca7dba6b236fc3c"),
        $.kk = o("d0d67f7ca74d79d087d9764aa5486cf08ed04f5697"),
        o("74b2db18153cc9a21f92db21e133aeb6e0"),
        o("0264a94a75f1b0c66f75ad7f62fab4"),
        $.Dk = o("f6f0d5d69d6ad168a1e2aff567"),
        $.Kk = o("7b5b103191596219ed55e813"),
        $.xh = o("272f44c5d837c4f0"),
        o("d76d801b3f7a0727b567b20a56430b06d673a4351d291c0bba568225434f3b0cc71c955e211d3422ca72363ec85be201305b600ad257ef124c0142d1ca73f3b151"),
        $.Ch = o("c94d26a33e56ae72b426"),
        $.wd = function(h, p) {
            try {
                window.localStorage.setItem(h, p)
            } catch {}
        }
        ,
        $.ag = function(h) {
            try {
                return window.localStorage.getItem(h)
            } catch {
                return ""
            }
        }
        ,
        $),
        F.ko = (n = [[-28.06744, 64.95936], [-10.59082, 72.91964], [14.11773, 81.39558], [36.51855, 81.51827], [32.82715, 71.01696], [31.64063, 69.41897], [29.41419, 68.43628], [30.64379, 67.47302], [29.88281, 66.76592], [30.73975, 65.50385], [30.73975, 64.47279], [31.48682, 63.49957], [32.18994, 62.83509], [28.47726, 60.25122], [28.76221, 59.26588], [28.03711, 58.60833], [28.38867, 57.53942], [28.83955, 56.2377], [31.24512, 55.87531], [31.61865, 55.34164], [31.92627, 54.3037], [33.50497, 53.26758], [32.73926, 52.85586], [32.23389, 52.4694], [34.05762, 52.44262], [34.98047, 51.79503], [35.99121, 50.88917], [36.67236, 50.38751], [37.74902, 50.51343], [40.78125, 49.62495], [40.47363, 47.70976], [38.62799, 46.92028], [37.53193, 46.55915], [36.72182, 44.46428], [39.68218, 43.19733], [40.1521, 43.74422], [43.52783, 43.03678], [45.30762, 42.73087], [46.99951, 41.98399], [47.26318, 40.73061], [44.20009, 40.86309], [45.35156, 39.57182], [45.43945, 36.73888], [35.64789, 35.26481], [33.13477, 33.65121], [21.47977, 33.92486], [12.16268, 34.32477], [11.82301, 37.34239], [6.09112, 38.28597], [-1.96037, 35.62069], [-4.82156, 35.60443], [-7.6498, 35.26589], [-16.45237, 37.44851], [-28.06744, 64.95936]],
        {
            mo: function(h, p) {
                for (var _ = !1, g = n.length, v = 0, P = g - 1; v < g; P = v++)
                    n[v][1] > h != n[P][1] > h && p < (n[P][0] - n[v][0]) * (h - n[v][1]) / (n[P][1] - n[v][1]) + n[v][0] && (_ = !_);
                return _
            }
        }),
        T.nl = ( () => {
            function h(v, P) {
                var w = P ? (P = 1.3,
                15554111) : (P = 1.1,
                16044288);
                return new g(v,w,!0,.5,P,.5,.7)
            }
            function p(v, P, w) {
                return ((255 * v & 255) << 16) + ((255 * P & 255) << 8) + (255 * w & 255)
            }
            class _ extends _e {
                constructor() {
                    super(),
                    this.K = [],
                    this.Tc = 0
                }
            }
            _.prototype.tl = function(v) {
                var P, w;
                this.Tc += v,
                1 <= this.Tc && (w = Math.floor(this.Tc),
                this.Tc -= w,
                v = 0 < w ? "+" + Math.floor(w) : w < 0 ? "-" + Math.floor(w) : "0",
                P = Math.min(1.5, .5 + w / 600),
                w = w < 1 ? "0xFFFFFF" : w < 30 ? p(1 - (w = (w - 1) / 29) + .96 * w, 1 - w + .82 * w, 1 - w + 0 * w) : w < 300 ? p(.96 * (1 - (w = (w - 30) / 270)) + .93 * w, .82 * (1 - w) + .34 * w, 0 * (1 - w) + .25 * w) : w < 700 ? p(.93 * (1 - (w = (w - 300) / 400)) + .98 * w, .34 * (1 - w) + 0 * w, .25 * (1 - w) + .98 * w) : 16318713,
                v = new g(v,w,!0,.5,P,Math.random(),1 + .5 * Math.random()),
                this.addChild(v),
                this.K.push(v))
            }
            ,
            _.prototype.kj = function(v) {
                v ? (U.Rh(U.Me + 1),
                v = h(o("7009f7823096fe082c"), !0),
                this.addChild(v),
                this.K.push(v),
                (U.Me % 10 ? (ri[k["1c"]].pause(),
                ri[k["1c"]]) : (hi[k["1ai"]].pause(),
                hi[k["1ai"]])).play()) : (U.Ah(U.Pg + 1),
                v = h(o("2b8b4872c3c58312578b5b4396"), !1),
                this.addChild(v),
                this.K.push(v))
            }
            ,
            _.prototype.va = function(v, P) {
                v = (w = F.w.g.v.D).da.width;
                for (var w = w.da.height, R = 0; R < this.K.length; ) {
                    var G = this.K[R];
                    G.lg += P / 2e3 * G.ch,
                    G.Wc += P / 2e3 * G.Yl,
                    G.alpha = .5 * Math.sin(3.141592653589793 * G.Wc),
                    G.scale.set(G.lg),
                    G.position.x = v * (.25 + .5 * G.dm),
                    G.position.y = G.fm ? w * (1 - .5 * (1 + G.Wc)) : w * (1 - .5 * (0 + G.Wc)),
                    1 < G.Wc && (z.Ga(G),
                    this.K.splice(R, 1),
                    R--),
                    R++
                }
            }
            ;
            var g = class extends Ue {
                constructor(v, P, w, R, G, C, X) {
                    super({
                        text: v,
                        style: {
                            fill: P,
                            fontFamily: "PTSans",
                            fontSize: 36
                        }
                    }),
                    this.anchor.set(.5),
                    this.fm = w,
                    this.lg = R,
                    this.ch = G,
                    this.dm = C,
                    this.Wc = 0,
                    this.Yl = X
                }
            }
            ;
            return _
        }
        )(),
        T.Wj = function(h, p) {
            this.Rd = p
        }
        ,
        T.Rb = {
            ni: 0,
            Xc: 16
        },
        T.Zc = (J.Yd = 0,
        J.prototype.Gi = function() {
            return 1.02 * this.lh
        }
        ,
        J),
        T.Ym = (re.prototype.init = async function(h) {
            var p = this;
            this.ic = h,
            this.da = (h = {
                [o("4555a696bf5b38")]: p.ic,
                [o("d281f586bd00ea06af85f8aeb103cf03")]: 0,
                [o("0759670ee25de1176e33")]: !0,
                [o("ac8d9c1ad6e48066da6693")]: k["1a"] ? o("19fdfe2efafe6a") : o("53733024b064")
            },
            await go(h)),
            this.Va = new _e,
            this.Va[o("c307aac433192bd6ae3fa5d723e423a7bd")] = !0,
            this.Ub = Math.floor(Math.random()),
            this.wc = this.Pi = 0,
            this.lf = 15,
            this.vh = .5,
            this.pf = 0,
            this.hd = new T.On,
            this.Qg = new Ke,
            this.ie = new _e,
            this.jd = new _e,
            this.jd[o("f1111c56010795449c291345110a8d556f")] = !0,
            this.le = new _e,
            this.ca = new _e,
            this.ca[o("f3d79a9403c91b869eef958713d4f3976d")] = !0,
            this.Ya = new _e,
            this.t = new a,
            this.t.position.x = ti ? 60 : 70 + this.t.F - 40,
            this.t.position.y = ti ? 60 : 70 + this.t.F - 40,
            this.Bc = new c,
            this.la = new l,
            this.md = new T.nl,
            this.Cb = new Ge,
            this.ya = {
                x: 0,
                y: 0
            },
            this.Jh = this.Oh = 0,
            this.m()
        }
        ,
        re.prototype.m = function() {
            this.da.background.color = 0,
            this.hd.Sc[o("3f0a08dca711bd")] = 10,
            this.Va[o("6cdcca5b3329dbaf10")](this.hd.Sc),
            this.Qg[o("6d24a64e95070b")] = 20,
            this.Va[o("0272a07145ffa1f56e")](this.Qg),
            this.ie[o("de15e91f8696dc")] = 5e3,
            this.Va[o("1c0c3a8b63990b1f40")](this.ie),
            this.jd[o("fa71f5639aeab8")] = 5100,
            this.Va[o("9aca38c9dd47095dc6")](this.jd),
            this.le[o("69a0a2f289bb17")] = 1e4,
            this.Va[o("49dbaf188ed626ec35")](this.le),
            this.Cb[o("b8fd9f73c8788cea")] = F.w.Fd.sh,
            this.Cb[o("fc2c50ac68be30")][o("c9492e88")](.5),
            this.Cb[o("72f97deb126240")] = 1,
            this.ca[o("e616cc1da993c5918a")](this.Cb),
            this.Ya[o("5040fed33cc4")] = .6,
            this.Ya[o("cc6747f1b4c46a")] = 2,
            this.ca[o("1f3145f6e03cccfa43")](this.Ya),
            this.md[o("d5bc1ee63dafa3")] = 3,
            this.ca[o("2bbd497aec88d84e57")](this.md),
            this.t[o("85176b48611b")] = .8,
            this.t[o("34ff3f695c6c02")] = 4,
            this.ca[o("f3c5918234c010869f")](this.t),
            this.Bc[o("933edce8732d61")] = 5,
            this.ca[o("2bbd497aec88d84e57")](this.Bc),
            this.la[o("8d04462e75e7eb")] = 6,
            Di[o("1d74d6bec5775b")] = 6,
            this.ca[o("27394dfee834c4f24b")](this.la),
            this.ca[o("2a5a88596dd799ad56")](Di),
            U.Bd = new Ue({
                [o("3d5ada88b5")]: o("03857d"),
                [o("b151479d5943")]: {
                    [o("1baa7260eb96c07f4ab85c")]: o("b334e1f556064a"),
                    [o("a4938919dc2a8381c9")]: 12,
                    [o("7d08965c6d")]: 16777215
                }
            }),
            U.Bd.position.x = this.t.F / 40 * 100,
            U.Bd.position.y = this.t.F / 40 * 90,
            nr.position.x = 15,
            nr.position.y = this.t.height + 25,
            Ni.position.x = 15,
            ti ? (nr.scale.set(.8, .8),
            Ni.scale.set(.8, .8),
            Ni.position.y = this.t.height + 150) : Ni.position.y = this.t.height + 175,
            this.ce = new Ue({
                [o("e5a513e105bf")]: {
                    [o("4eb97f8f262575083f8b61")]: o("9afb08feff4113"),
                    [o("bc6b91e1b4c26b69a1")]: 12,
                    [o("de09c91d8e")]: 16777215
                }
            }),
            this.ce.anchor = 1,
            this.ca.addChild(this.ce),
            this.ca.addChild(U.Bd),
            this.Nd = new Ke,
            this.ca.addChild(this.Nd),
            this.ca.addChild(nr),
            this.ca.addChild(Ni),
            (async () => {
                function h() {
                    oe.nf = !1,
                    oe.cg = !1,
                    oe.pt = !1,
                    oe.Xa = -1,
                    oe.visible = !1,
                    lt.visible = !1,
                    (oe.N.alpha = 1) === k["1f"] ? (oe.R.texture = g[2].R,
                    oe.N.texture = g[2].N,
                    oe.R.alpha = g[2].Hb) : k["1f"] === 2 ? (oe.R.texture = g[4].R,
                    oe.N.texture = g[2].N,
                    oe.R.alpha = g[2].Hb,
                    oe.cg = !0,
                    oe.pt = !0,
                    oe.position.x = 100,
                    oe.position.y = _.offsetHeight - 100,
                    oe.visible = !0,
                    oe.N.alpha = 0,
                    lt.visible = !0,
                    lt.position.x = _.offsetWidth - 100,
                    lt.position.y = _.offsetHeight - 100) : k["1f"] === 3 ? (oe.R.texture = g[4].R,
                    oe.N.texture = g[2].N,
                    oe.R.alpha = g[2].Hb,
                    oe.cg = !0,
                    oe.pt = !0,
                    oe.position.x = _.offsetWidth - 100,
                    oe.position.y = _.offsetHeight - 100,
                    oe.visible = !0,
                    oe.N.alpha = 0,
                    lt.visible = !0,
                    lt.position.x = 100,
                    lt.position.y = _.offsetHeight - 100) : k["1f"] === 4 ? (oe.R.texture = g[0].R,
                    oe.N.texture = g[0].N,
                    oe.R.alpha = g[0].Hb) : k["1f"] === 5 ? (oe.R.texture = g[1].R,
                    oe.N.texture = g[1].N,
                    oe.R.alpha = g[1].Hb) : (oe.nf = !0,
                    oe.visible = !1,
                    oe.Xa = -1),
                    oe.gf()
                }
                if (ti) {
                    this.ca.addChild(Gr);
                    var p, _ = document.querySelector(o("74adc22a14")), g = [{
                        R: await Te.load(o("8553357e6415e955e11b2a7257effc26fcea721728bab53cf3e9")),
                        N: await Te.load(o("b6624a0fd7a41ea4d22aa56384beebb7af3bed06fbeaa2ada038")),
                        Hb: 1
                    }, {
                        R: await Te.load(o("84f0f411e536a8b2e0b8eb6dd60cbd81fd89b338a95bf49bf28a")),
                        N: await Te.load(o("79cfc9ea90811dd9ed972686439be8dae0966ee33ccda1b0ff65")),
                        Hb: 1
                    }, {
                        R: this.da[o("487eeff529efef6b3575f7db20d0e442")](new Ke().circle(0, 0, 40).fill(16711680)),
                        N: this.da[o("3a2c99235bbd61a52707612d32a27abc")](new Ke().circle(0, 0, 20).fill(16711680)),
                        Hb: .5
                    }, {
                        R: this.da[o("86702d77efe92de9eb4b3559e6d626c0")](new Ke().circle(0, 0, 40).fill(16711680)),
                        N: this.da[o("dc4a7bc185c34347816143cf9ccc585e")](new Ke().circle(0, 0, 20).fill(16711680)),
                        Hb: .5,
                        position: [500, 500]
                    }, {
                        R: await Te.load(o("89df39fa6091eda9fd6736f6536bf8aaf0667e932520efbec6")),
                        N: this.da[o("87dfec946ece6c8aea94f47a67b16763")](new Ke().circle(0, 0, 20).fill(16711680)),
                        vo: !0,
                        Hb: 1
                    }], v = (lt.visible = !1,
                    lt.texture = await Te.load(o("a054d0b5c99a841ec41ccfc9ea90811dd9ed975c8d2b86e9df")),
                    lt.anchor.set(.5),
                    lt[o("487cfcfe22e9c3703444")] = "static",
                    lt.alpha = .5,
                    lt.on(o("c0e16d7aaa6163e5acf67d75"), () => {
                        lt.alpha = 1,
                        U.Rf.tb = !0
                    }
                    ),
                    lt.on(o("6041cdda0ac1c3451d49"), () => {
                        lt.alpha = .5,
                        U.Rf.tb = !1
                    }
                    ),
                    this.ca.addChild(lt),
                    (oe = new xw({
                        R: new Ge,
                        N: new Ge,
                        Om: G => {
                            U.Rf.Jb = G.angle,
                            dt.position.x = .5 * _.offsetWidth + G.di * Math[o("1baf727d")](G.angle),
                            dt.position.y = .5 * _.offsetHeight + G.di * Math[o("ee0cd9ef")](G.angle)
                        }
                    }))[o("3f1537d7ad0088d9231d")] = o("d9392f6d2927bc"),
                    oe.on(o("a7a8c67345a8486ccb8fc64c"), G => {
                        oe.pt && (oe.Xa = G.pointerId,
                        oe.Fi())
                    }
                    ),
                    oe.position.x = 150,
                    oe.position.y = 150,
                    oe.Xa = -1,
                    this.ca.addChild(oe),
                    {
                        wh: new Ge(await Te.load(o("81d731f26899e5d1e59f2e8e4b8deab4e56b7da37c65f8a6b77a75ab"))),
                        Sk: new Ge(await Te.load(o("18cc682d71023c864c94474162180995419519145f531e9157"))),
                        Bk: new Ge(await Te.load(o("b2e64683db281a20d6ae59fff822ef33abbfe1b9a72ded2be4abe2ba"))),
                        Im: new Ge(await Te.load(o("23f11750cab7cb7347b9082ce98fc54d408f106583cdfb1b55c24d40d8"))),
                        fn: new Ge(await Te.load(o("f0e40005992a54ae94ac1f79ba235da36fa2277d743b21"))),
                        hn: new Ge(await Te.load(o("e3b1d7900af70bb387f9c8ec29d3128addd49b81"))),
                        cn: new Ge(await Te.load(o("3eea32972f3c663c2ab22deb0c36633f27b3758034083a153880"))),
                        Ac: new Ge(await Te.load(o("778d4bac96c39f8713d5a4c045d96a94eed4ec886ed0629febeee16c74"))),
                        Bm: new Ge(await Te.load(o("d96f694a3021bd798d374626233b887a80360e7f053f8147940012471e0185478c041f020d0098"))),
                        Wm: new Ge(await Te.load(o("d96f694a3021bd798d37462623238962863506321d3088"))),
                        ym: new Ge(await Te.load(o("a4d0d431c5168892c098cb4df6fb9d6cd92b86e9df")))
                    }), P = (v.hn.on("pointerdown", G => {
                        G.preventDefault(),
                        qe.Wf()
                    }
                    ),
                    v.Sk.on(o("5e9f4f980c07410702985f97"), () => {
                        qe.Mi()
                    }
                    ),
                    v.cn.on(o("a6470750c4cf09cfca50072f"), () => {
                        qe.rh()
                    }
                    ),
                    v.Ac.on(o("d617f700b49ff99fba00d71f"), () => {
                        qe.Ac()
                    }
                    ),
                    v.Bm.on(o("8e6f3f48fcd731d7f2482f47"), () => {
                        qe.qh()
                    }
                    ),
                    v.Wm.on(o("8b4ce217613474f0f72be2e8"), () => {
                        Ei(U.Ib - k["1i"])
                    }
                    ),
                    v.ym.on(o("5e9f4f980c07410702985f97"), () => {
                        Ei(U.Ib + k["1i"])
                    }
                    ),
                    v.wh.on(o("d0d17d4aba5173d5bcc66d45"), () => {
                        U.ef = !U.ef,
                        v.wh.alpha = U.ef ? 1 : .3
                    }
                    ),
                    v.fn.on(o("ff406e1bed40e00463577e14"), () => {
                        F.w.g.v.D.la.Ob = !F.w.g.v.D.la.Ob,
                        F.w.g.v.D.Ya.visible = F.w.g.v.D.la.Ob,
                        F.w.g.v.D.la.va(F.w.g.v.D.la.Ab)
                    }
                    ),
                    v.Im.on(o("ee0fdfe89c77d17792e8cfe7"), () => {
                        U.nd = !U.nd
                    }
                    ),
                    v.Bk.on(o("f43559ae96bd5f39982249a1"), () => {
                        U.ee = !U.ee
                    }
                    ),
                    0);
                    for (p in v) {
                        var w = v[p];
                        w[o("9b3cf2fd762448fdcd")].x = P,
                        w[o("64d0d052064de7d408d8")] = "static",
                        w[o("bb0fc8dc4c1f33")] = o("caabe3b4a02bf513"),
                        w[o("1bad717ef7b1")] = .3,
                        ki.addChild(w),
                        P += w.width + 10
                    }
                    ki.position.y = 10,
                    this.ca.addChild(ki),
                    dt.circle(0, 0, 5).stroke({
                        width: 2,
                        color: 16777215,
                        alpha: 1
                    }),
                    dt.x = 500,
                    dt.y = 100,
                    this.ca.addChild(dt);
                    var R = [await Te.load(o("c11771b22859a591a55f6ece0b53a062b82e365b6468a766be")), await Te.load(o("c8bc385da1726cf6bcc43711924879c5b1c57f74ee036ec187")), await Te.load(o("144064a17586380270087bdd669c0d114d1903a81ad71a154b")), await Te.load(o("c7ddfb7c26932f57a365f47015693a24be64bc1569222d20b8")), await Te.load(o("61f7d1d288b905f105bfceaeabb300c2188e96fbc6c807c61e")), await Te.load(o("11a7a102f8e9752175efbe7edbe3703248fec60b91b857364e"))];
                    rr[o("ef54941a07510703")] = R[k["1f"]],
                    rr[o("64d0d052064de7d408d8")] = "static",
                    rr[o("1ecc95c3515c96")] = o("3cfd11662e65e7e1"),
                    rr.on(o("0d8ee0a9ff7676b66076"), () => {
                        k["1f"] = (k["1f"] + 1) % R.length,
                        rr[o("3a3f99354aba72b4")] = R[k["1f"]],
                        ye(),
                        h()
                    }
                    ),
                    this.ca.addChild(rr),
                    h()
                }
            }
            )(),
            this.ea()
        }
        ,
        re.prototype.ea = function() {
            var h = z.e()
              , p = (_ = qg(this.ic))[0]
              , _ = _[1];
            --this.da.view[o("7035d7bb00b0c422")][o("cf73be37216730")][o("26c781c14f57bb544acb98")],
            this.da.resize(p, _, h),
            this.vh = Math.min(Math.min(p, _), .625 * Math.max(p, _)),
            this.Cb[o("52137b163f93718634")][o("4ea7")] = p / 2,
            this.Cb[o("2f105ed1da10dcc959")][o("cdc7")] = _ / 2,
            this.Cb[o("e3e38cb213f0")] = p,
            this.Cb[o("750e92419e020f")] = _,
            this.Bc[o("92d33bd6ff533146f4")][o("1099")] = ti ? 130 : 200,
            this.Bc[o("f273db769ff3d1e694")][o("b0f8")] = ti ? 50 : 10,
            Gr.Of || (Gr[o("4ff03eb1baf0bca939")][o("949d")] = p - 120,
            Gr[o("f59618db109e92c393")][o("19f3")] = _ - 210),
            this.la.Of || (this.la[o("bb1cd2dd560428ddad")][o("b31c")] = p - 225,
            this.la[o("e76886290268043181")][o("8028")] = 1),
            Di[o("cf70be313a703c29b9")][o("16df")] = p - 10,
            Di[o("46a767aa232f653220")][o("d45c")] = 300,
            ki.Of || (ki.position.x = p - 230 - ki.width,
            rr.x = ki.position.x - 100)
        }
        ,
        re.prototype.va = function(h, p) {
            this.lf = 15,
            this.ie[o("f6f5dde4957dd94e96e6acf57076aa")](),
            this.jd[o("e8cb4f56834b4bfc98a85e27862058")](),
            this.le[o("de1dc51c8d85c1b68e1ec41d989ec2")](),
            this.Ya[o("b9585e815258dab3a95b2f903753a9")](),
            U.Ng = () => {
                var g = vo[k["1b"]];
                this.hd.zk(g || F.w.Fd.If)
            }
            ,
            U.Ng();
            var _ = this.Qg;
            _.clear(),
            _.circle(0, 0, h.lh),
            _.stroke({
                width: .2,
                color: U.r ? k["1g"] : 16777215,
                alpha: 1
            }),
            this.la.Ob = p,
            this.Ya[o("3f0628c1aa16a9d3")] = p
        }
        ,
        re.prototype.Ha = function(h, p) {
            if (!(this.da.width <= 5)) {
                var _ = F.w.h.W
                  , g = this.da.width
                  , v = this.da.height
                  , P = (this.lf = z.Q(this.lf, F.w.h.Kc, p, .002),
                this.vh / (this.lf * U.Ib))
                  , w = F.w.h.W.fa[T.Fc.ml]
                  , R = (this.pf = z.Ic(this.pf + p / 1e3 * (.1 * (w != null && w.ra ? 1 : 0) - this.pf), 0, 1),
                this.Cb.alpha = this.pf,
                this.Ub += .01 * p,
                360 < this.Ub && (this.Ub %= 360),
                this.Pi = Math.sin(h / 1200 * 6.283185307179586),
                _ = _.xd(),
                this.ya.x = z.Gh(this.ya.x, _.mb, p),
                this.ya.y = z.Gh(this.ya.y, _.nb, p),
                v / P / 2);
                for (F.w.h.gl(this.ya.x - 1.3 * (w = g / P / 2), this.ya.x + 1.3 * w, this.ya.y - 1.3 * R, this.ya.y + 1.3 * R),
                this.hd.va(this.ya.x, this.ya.y, 2 * w, 2 * R),
                w = F.w.h.C.lh,
                this.Va.scale.x = P,
                this.Va.scale.y = P,
                this.Va.position.x = g / 2 - this.ya.x * P,
                this.Va.position.y = v / 2 - this.ya.y * P,
                w - 10 < (R = z.dg(_.mb, _.nb)) ? (this.wc = z.Ic(1 + (R - w) / 10, 0, 1),
                R = z.qg(Math.floor((Math.atan2(Math.sin(6.283185307179586 * this.Ub / 360) * (1 - this.wc), Math.cos(6.283185307179586 * this.Ub / 360) * (1 - this.wc) + +this.wc) + 6.283185307179586) % 6.283185307179586 * 360 / 6.283185307179586), 1, .75 - .25 * this.wc),
                this.hd.Pd(R[0], R[1], R[2], .1 + this.wc * (.5 + .5 * this.Pi) * .2)) : (this.wc = 0,
                R = z.qg(Math.floor(this.Ub), 1, .75),
                this.hd.Pd(R[0], R[1], R[2], .1)),
                R = 0; R < this.Ya.children.length; R++) {
                    var G = this.Ya.children[R];
                    G.yd && (G.position.x = g / 2 - (this.ya.x - G.yd.x) * P,
                    G.position.y = v / 2 - (this.ya.y - G.yd.y) * P)
                }
                if (this.t.Fb.position.x = _.mb / w * this.t.F,
                this.t.Fb.position.y = _.nb / w * this.t.F,
                P = U.We[0],
                _ = U.We[1],
                P !== 0 ? (this.t.cb.visible = !0,
                this.t.cb.position.x = P / w * this.t.F,
                this.t.cb.position.y = _ / w * this.t.F) : this.t.cb.visible = !1,
                this.Bc.Cd(h),
                this.md.va(h, p),
                this.Nd.clear(),
                U.ee && (h = this.Va[o("ab28c2d9430f53c3df")]({
                    x: 0,
                    y: 0
                }),
                this.Nd.moveTo(.5 * g, .5 * v),
                this.Nd.lineTo(h.x, h.y),
                this.Nd.stroke({
                    width: 2,
                    color: 16737894,
                    alpha: .75
                })),
                3e3 < (g = performance.now()) - U.jg && ((v = U.vg.shift()) ? Di.jn(v[0], v[1], v[2], v[3]) : Di.Wg(),
                U.jg = g),
                U.k && (v = U.k.b,
                h = U.k.c,
                p = U.k.d,
                this.t.wa.position.x = U.k.a / h * this.t.F,
                this.t.wa.position.y = v / h * this.t.F,
                p != 0) && 6e4 < g - p && (this.t.wa[o("0a6da56e67fdbcc4")] = 0,
                U.k = 0),
                100 < g - U.nh) {
                    U.nh = g,
                    U.fc = !U.fc;
                    for (var C of Object.values(U.wb))
                        C.fc ? (C.clear(),
                        C.circle(0, 0, .06 * this.t.F),
                        C.stroke({
                            width: 2,
                            color: 0
                        }),
                        C.fill(U.fc ? 16711680 : 255)) : (C.clear(),
                        C.circle(0, 0, .06 * this.t.F),
                        C.stroke({
                            width: 2,
                            color: 0
                        }),
                        C.fill(C.Mm))
                }
                for (U.pd && 55 <= g - this.Oh && (v = (C = F.w.g.v.Jb) + Math.PI / 360 * 9,
                F.w.g.v.Jb = Math.PI < v ? -C : v,
                this.Oh = g),
                U.nd && 2e3 <= g - this.Jh && (this.Jh = g,
                qe.Wf()); 0 < Bs.length && Bs[0] <= g - 1e3; )
                    Bs.shift();
                Bs.push(g),
                Di.Dl(),
                Qg = Bs.length,
                this.ce.text = Qg.toString(),
                this.ce.position.x = this.da.width - 2,
                this.ce.position.y = this.da.height - 2,
                this.da.render({
                    container: this.Va,
                    clear: !0
                }),
                this.da.render({
                    container: this.ca,
                    clear: !1
                })
            }
        }
        ,
        re.prototype.lj = function(h, p) {
            p.Na.J.u.zIndex = (h + 2147483648) / 4294967296 * 5e3,
            this.ie.addChild(p.Na.id.u),
            this.jd.addChild(p.Na.J.u)
        }
        ,
        re.prototype.Fl = function(h, p, _, g) {
            p.Aa.zIndex = F.w.h.C.fb ? 0 : 10 + (h + 32768) / 65536 * 5e3,
            this.le.addChild(p.Aa),
            h !== F.w.h.C.fb && (this.Ya.addChild(_),
            this.Ya.addChild(g))
        }
        ,
        a = class extends Ds {
            constructor() {
                super(),
                this.F = ti ? 40 : 60,
                this.Gd = new Ge,
                this.Gd[o("cb1da3dd27ef23")][o("981abf9f")](.5),
                this.Gd[o("aada00cdc65e")] = .5,
                this.Gd[o("4eac73803e06")] = this.F / 40,
                this.Fb = new Ke,
                this.Fb[o("c5cc0e162ddfb3")] = 2,
                this.Fb[o("c315a9c62f19")] = .9,
                this.cb = new Ke,
                this.cb[o("933edce8732d61")] = 2,
                this.cb[o("2bbd416ec781")] = .9,
                this.wa = new Ke,
                this.wa[o("5e9949820b114810")] = 0,
                this.wa[o("69a0a2f289bb17")] = 2,
                this.wa[o("81936fc46d97")] = .9;
                var h = new Ke
                  , p = (U.he = () => {
                    h.clear(),
                    h.circle(0, 0, this.F),
                    h.moveTo(0, -this.F),
                    h.lineTo(0, +this.F),
                    h.moveTo(-this.F, 0),
                    h.lineTo(+this.F, 0),
                    h.fill({
                        color: 0,
                        alpha: .4
                    }),
                    h.stroke({
                        width: 2,
                        color: U.r ? k["1g"] : 16777215
                    }),
                    this.Fb.clear(),
                    this.Fb.circle(0, 0, .08 * this.F),
                    this.Fb.stroke({
                        width: 2,
                        color: 0
                    }),
                    this.Fb.fill(U.r ? k["1g"] : 16777215),
                    this.cb.clear(),
                    this.cb.circle(0, 0, .08 * this.F),
                    this.cb.stroke({
                        width: 2,
                        color: 0
                    }),
                    this.cb.fill(16776960),
                    this.wa.clear(),
                    this.wa.moveTo(0, 0),
                    this.wa.lineTo(.15 * this.F, .15 * this.F),
                    this.wa.moveTo(0, .15 * this.F),
                    this.wa.lineTo(.15 * this.F, 0),
                    this.wa.stroke({
                        color: 16711680
                    })
                }
                ,
                U.he(),
                new Ue({
                    text: o("66bf7b"),
                    style: {
                        fontFamily: o("8e4f0472f3cd27"),
                        fontSize: 16,
                        fill: 16777215
                    }
                }))
                  , _ = (p.position.x = -35,
                p.position.y = this.F + 15,
                new Ue({
                    text: o("12689d695a"),
                    style: {
                        fontFamily: o("f415629499a749"),
                        fontSize: 16,
                        fill: 16777215
                    }
                }));
                _.position.x = 10,
                _.position.y = this.F + 15;
                let g = new Ue({
                    style: {
                        fontFamily: o("afb0e571528a46"),
                        fontSize: 16,
                        fill: 16777215
                    }
                })
                  , v = (g.position.x = p.position.x + p.width / 2,
                g.position.y = this.F + 33,
                g.anchor.x = .5,
                new Ue({
                    style: {
                        fontFamily: o("46875c8a2b357f"),
                        fontSize: 16,
                        fill: 16777215
                    }
                }));
                v.position.x = _.position.x + _.width / 2,
                v.position.y = this.F + 33,
                v.anchor.x = .5,
                U.Ah = P => {
                    U.Pg = P,
                    v.text = U.Pg
                }
                ,
                U.Rh = P => {
                    U.Me = P,
                    g.text = U.Me
                }
                ,
                (async () => {
                    var P = await Te.load(o("398f892ad0c15d192dd7e64683d52b172ad1e50ca3d9"));
                    (P = new Ge(P))[o("b5d15e0c4dc2")] = 2.5 * this.F,
                    P[o("750e92419e020f")] = 2.5 * this.F,
                    P[o("6696469a02145e")][o("8b4fe80a")](.5),
                    this[o("8cbcaa3bd309bb8ff0")](P)
                }
                )(),
                this[o("2252805165df81d54e")](h),
                this[o("d8c87e4f9f4577c384")](this.Gd),
                this[o("b305d1c2740050c6df")](this.cb),
                this[o("6537837caa32027009")](this.wa),
                this[o("306016e777ed1f6b5c")](this.Fb),
                this[o("4878eeff0ff5e77334")](_),
                this[o("ebfd89ba2cc8188e97")](p),
                this[o("3f1125d6801cacda23")](v),
                this[o("b5c7530c7ac2d200d9")](g)
            }
        }
        ,
        c = ( () => {
            class h extends _e {
                constructor() {
                    super(),
                    this.lc = {}
                }
            }
            h.prototype.Cd = function(_) {
                for (var g in _ = .5 + .5 * Math.cos(_ / 1e3 / 1.6 * 6.283185307179586),
                this.lc) {
                    var g = this.lc[g]
                      , v = g.ci;
                    g.alpha = 1 - v + v * _
                }
            }
            ;
            let p = [40, 40, 40, 120, 50, 25, 40];
            return h.prototype.va = function(_) {
                for (var g in this.lc)
                    _[g] != null && _[g].ra || (z.Ga(this.lc[g]),
                    delete this.lc[g]);
                for (var v in g = 0,
                _) {
                    var P, w, R = _[v];
                    if (R.ra) {
                        let G = this.lc[v];
                        G || (P = F.w.o.S().Lh(R.X).Ja,
                        G = new _e,
                        P = new Ge(P.rg()),
                        w = new Ue({
                            text: "40",
                            style: {
                                fontFamily: "PTSans",
                                fontSize: 20,
                                fill: 16777215
                            }
                        }),
                        G.ci = 0,
                        P.width = 40,
                        P.height = 40,
                        w.position.y = 40,
                        w.position.x = 20,
                        w.anchor.x = .5,
                        G.addChild(P),
                        G.addChild(w),
                        this.lc[v] = G,
                        this.addChild(G)),
                        G.getChildAt(1).text = Math.round((1 - R.ze) * p[R.X]),
                        G.ci = R.ze,
                        G.position.x = g,
                        g += 40
                    }
                }
            }
            ,
            h
        }
        )(),
        l = ( () => {
            function h(g) {
                return new Intl.NumberFormat("en",{
                    notation: "compact",
                    compactDisplay: "short"
                }).format(g)
            }
            class p extends Ds {
                constructor() {
                    super(),
                    this.Ob = !0,
                    this.Ne = 12,
                    this.Kd = 9,
                    this.K = [];
                    for (var v = 0; v < 14; v++)
                        this.Md()
                }
            }
            p.prototype.va = function(g) {
                this.Ab = g;
                var v = F.w.h.C.qc === T.Rb.Xc
                  , P = 0
                  , w = 0;
                w >= this.K.length && this.Md(),
                this.K[w].Pe(1, "white"),
                this.K[w].Re("", U.$, `(${F.w.h.si} online)`),
                this.K[w].position.y = P,
                P += this.Ne,
                w += 1,
                0 < g.Sd.length && (P += this.Kd);
                for (var R = 0; R < g.Sd.length; R++) {
                    var G = g.Sd[R]
                      , C = F.w.o.S().re(G.zm);
                    w >= this.K.length && this.Md(),
                    this.K[w].Pe(.8, C.Ce.ig),
                    this.K[w].Re("".concat(R + 1), "", "".concat(Math.floor(G.Kb))),
                    this.K[w].position.y = P,
                    P += this.Ne,
                    w += 1
                }
                for (0 < g.cd.length && (P += this.Kd),
                R = 0; R < Math.min(k["1d"], g.cd.length); R++) {
                    var X, G = g.cd[R], H = (C = F.w.h.C.fb === G.Di) ? (X = "white",
                    F.w.h.W.G.$a) : (H = F.w.h.xb[G.Di]) != null ? (X = (v ? F.w.o.S().re(H.G.qi).Ce : F.w.o.S().qe(H.G.hb)).ig,
                    (H = this.Ob ? H.G.$a : "---") || "No nickname") : (X = "gray",
                    "No nickname");
                    C && (P += this.Kd),
                    w >= this.K.length && this.Md(),
                    this.K[w].Pe(C ? 1 : .8, X),
                    this.K[w].Re("".concat(R + 1), H, "".concat(h(Math.floor(G.Kb)))),
                    this.K[w].position.y = P,
                    P += this.Ne,
                    w += 1,
                    C && (P += this.Kd)
                }
                for (F.w.h.ff > g.cd.length && (P += this.Kd,
                w >= this.K.length && this.Md(),
                this.K[w].Pe(1, "white"),
                this.K[w].Re("".concat(F.w.h.ff), F.w.h.W.G.$a, "".concat(h(Math.floor(F.w.h.W.Kb)))),
                this.K[w].position.y = P,
                w += 1); this.K.length > w; )
                    z.Ga(this.K.pop())
            }
            ,
            p.prototype.Md = function() {
                var g = new _;
                (g[o("f3d49a951edc108595")][o("9b35")] = 0) < this.K.length && (g[o("bdde500328c6aa1bab")][o("03cd")] = this.K[this.K.length - 1][o("8b4ce20d663478edfd")][o("569e")] + this.Ne),
                this.K.push(g),
                this[o("66964c9d291345110a")](g)
            }
            ;
            var _ = ( () => {
                class g extends _e {
                    constructor() {
                        super(),
                        this.dd = new Ue({
                            text: "",
                            style: {
                                fontFamily: "PTSans",
                                fontSize: 12,
                                fill: 16777215
                            }
                        }),
                        this.dd.anchor.x = 1,
                        this.dd.position.x = 30,
                        this.addChild(this.dd),
                        this.zc = new Ue({
                            text: "",
                            style: {
                                fontFamily: "PTSans",
                                fontSize: 12,
                                fill: 16777215
                            }
                        }),
                        this.zc.anchor.x = 0,
                        this.zc.position.x = 35;
                        var P = new _e
                          , w = new Ke().rect(0, 0, 180, 20).fill();
                        P.mask = w,
                        P.addChild(w),
                        P.addChild(this.zc),
                        this.addChild(P),
                        this.fd = new Ue({
                            text: "",
                            style: {
                                fontFamily: "PTSans",
                                fontSize: 12,
                                fill: 16777215
                            }
                        }),
                        this.fd.anchor.x = 1,
                        this.fd.position.x = 220,
                        this.addChild(this.fd)
                    }
                }
                return g.prototype.Re = function(v, P, w) {
                    this.dd.text = v,
                    this.fd.text = w,
                    this.zc.text = P
                }
                ,
                g.prototype.Pe = function(v, P) {
                    this.dd.alpha = v,
                    this.dd.style.fill = P,
                    this.zc.alpha = v,
                    this.zc.style.fill = P,
                    this.fd.alpha = v,
                    this.fd.style.fill = P
                }
                ,
                g
            }
            )();
            return p
        }
        )(),
        re),
        T.Gn = ( () => {
            function h(g) {
                this.h = g,
                this.qf = [],
                this.gj = 0
            }
            h.prototype.tj = function(g) {
                this.qf.push(new T.Xm(new T.vf(g)))
            }
            ,
            h.prototype.Yg = function() {
                this.qf = [],
                this.gj = 0
            }
            ,
            h.prototype.zj = function() {
                for (var g = 0; g < 10 && this.qf.length !== 0; g++) {
                    var v = this.qf.shift();
                    this.Aj(v)
                }
            }
            ,
            h.prototype.Aj = function(g) {
                switch (255 & g.n(0)) {
                case 0:
                    this.Gj(g);
                    break;
                case 1:
                    this.Kj(g);
                    break;
                case 2:
                    this.Rj(g);
                    break;
                case 3:
                    this.Xj(g);
                    break;
                case 4:
                    this.ek(g);
                    break;
                case 5:
                    this.lk()
                }
            }
            ,
            h.prototype.Gj = function(g) {
                ue(i, o("7aea5ff9177925")),
                U.vg = [],
                U.jg = 0,
                this.h.C.qc = g.n();
                var v = g.s()
                  , P = (this.h.C.fb = v,
                this.h.W.G.H = v,
                this.h.C.lh = g.f(),
                this.h.C.Ye = g.f(),
                this.h.C.Eg = g.f(),
                v = [],
                g.n());
                for (let w = 0; w < P; ++w) {
                    let R = g.Gb()
                      , G = g.E()
                      , C = g.Gb()
                      , X = "";
                    for (let H = 0; H < C; ++H)
                        X += String.fromCharCode(g.E());
                    v.push([X, G, R])
                }
                Ni.gf(v),
                F.w.g.v.D.va(this.h.C, !0)
            }
            ;
            let p = [];
            h.prototype.Kj = function(g) {
                for (var v = this.gj++, P = g.s(), w = this.lb(g), R = 0; R < w; R++)
                    this.Ek(g);
                for (w = this.lb(g),
                R = 0; R < w; R++)
                    this.Lk(g);
                for (w = this.lb(g),
                R = 0; R < w; R++)
                    this.Pk(g);
                for (w = this.lb(g),
                R = 0; R < w; R++)
                    this.Tk(g);
                for (w = this.lb(g),
                R = 0; R < w; R++)
                    this.Yk(g);
                for (w = this.lb(g),
                R = 0; R < w; R++)
                    this.$k(g);
                for (w = g.Gb(),
                R = 0; R < w; R++)
                    this.cl(g);
                for (w = this.lb(g),
                R = 0; R < w; R++)
                    this.hl(g);
                for (var G, w = this.lb(g), R = {}, C = 0; C < w; ++C) {
                    var X = g.E()
                      , H = g.Gb()
                      , ee = g.pn()
                      , de = g.f()
                      , me = g.f();
                    R[X] = [X, H, ee, de, me]
                }
                var q = R;
                for (Fe of Object.keys(U.wb).filter(fe => !(fe in q)))
                    F.w.g.v.D.t.removeChild(U.wb[Fe]),
                    delete U.wb[Fe];
                for (G of Object.values(q)) {
                    var V, I = G[0], K = G[1], te = G[2], Fe = G[3], pt = G[4];
                    U.wb[I] || ((V = new Ke)[o("e0cb6b5d80505e")] = 1,
                    V[o("b2a218b5de26")] = .9,
                    V.clear(),
                    V.circle(0, 0, .06 * F.w.g.v.D.t.F),
                    V.stroke({
                        width: 2,
                        color: 0
                    }),
                    V.fill(te),
                    V.Mm = te,
                    V.fc = !1,
                    F.w.g.v.D.t.addChild(V),
                    U.wb[I] = V),
                    I = U.wb[I],
                    k["1af"] && K && !I.fc && (yo.pause(),
                    yo.play()),
                    I.fc = K,
                    I.position.x = Fe / 500 * F.w.g.v.D.t.F,
                    I.position.y = pt / 500 * F.w.g.v.D.t.F
                }
                for (R = g.Gb(),
                w = [],
                C = 0; C < R; ++C)
                    X = g.E(),
                    H = g.E(),
                    ee = g.Gb(),
                    (de = this.mc(X)) && w.push([de.G.$a, H, ee, X]);
                e: if (w.length !== p.length)
                    R = !1;
                else {
                    for (R = w.length; R--; )
                        if (C = w[R],
                        X = p[R],
                        C[1] !== X[1] || C[4] !== X[4]) {
                            R = !1;
                            break e
                        }
                    R = !0
                }
                R || (p = w,
                nr.gf(w)),
                0 < v && this.kl(g),
                this.h.ol(v, P)
            }
            ,
            h.prototype.Tk = function(g) {
                var v = new T.Ee.De
                  , P = (v.H = g.s(),
                v.qi = this.h.C.qc === T.Rb.Xc ? g.n() : T.Zc.Yd,
                v.hb = g.s(),
                v.Ge = g.s(),
                v.fe = g.s(),
                v.Ie = g.s(),
                v.Uc = g.s(),
                v.rf = g.Gb(),
                g.n())
                  , w = "";
                for (let C = 0; C < P; C++) {
                    var R = g.s();
                    w += String.fromCharCode(R)
                }
                if (k["1k"] && typeof U.jh == "object") {
                    g = w.match(/\b(\w+)\b/g);
                    let C = [];
                    if (g)
                        for (var G of g)
                            C.push(G.toLowerCase());
                    U.jh.some(X => C.includes(X)) && (w = "Censored")
                }
                v.$a = w = w === "" ? "No nickname" : w,
                (this.h.C.fb === v.H ? this.h.W : (v.hb === 19999 && (v.hb = 35),
                v.Ge === 999 && (v.Ge = 0),
                v.fe === 999 && (v.fe = 0),
                v.Ie === 999 && (v.Ie = 0),
                v.Uc === 999 && (v.Uc = 0),
                (w = this.h.xb[v.H]) != null && w.Hd(),
                (w = new T.Ee(this.h.C)).ei(F.w.g.v.D),
                this.h.xb[v.H] = w)).$h(v)
            }
            ,
            h.prototype.Yk = function(g) {
                var v = g.s()
                  , P = (G = g.n()) >> 0 & 1
                  , w = G >> 1 & 1
                  , R = G >> 2 & 1
                  , G = 0;
                (G = P ? g.s() : G) && R && (g = this.mc(v),
                R = this.mc(G),
                g) && R && U.vg.push([R.G.$a, g.G.$a, w, R.G.rf]),
                (g = this.mc(v)) !== void 0 && (g.oc = !1,
                g.eb) && (R = this.mc(v),
                P && R !== void 0 && R.eb ? G === this.h.C.fb ? (v = this.h.W.xd(),
                v = g.pg(v.mb, v.nb),
                Math.max(0, 1 - v.Se / (.5 * this.h.Kc)),
                v.Se < .5 * this.h.Kc && F.w.g.v.D.md.kj(w)) : v === this.h.C.fb ? (U.k = {
                    a: R.Y[0],
                    b: R.Y[1],
                    c: R.C.lh,
                    d: 0
                },
                F.w.g.v.D.t.wa[o("32359d365fa594ac")] = 1) : (w = this.h.W.xd(),
                Math.max(0, 1 - g.pg(w.mb, w.nb).Se / (.5 * this.h.Kc))) : v === this.h.C.fb ? (U.k = {
                    a: R.Y[0],
                    b: R.Y[1],
                    c: R.C.lh,
                    d: 0
                },
                F.w.g.v.D.t.wa[o("10973b107d073a82")] = 1) : (w = this.h.W.xd(),
                Math.max(0, 1 - g.pg(w.mb, w.nb).Se / (.5 * this.h.Kc))))
            }
            ,
            h.prototype.hl = function(g) {
                var v = (v = g.s()) === this.h.C.fb ? null : this.h.xb[v]
                  , P = !!(1 & (C = g.n()))
                  , w = (2 & C && (C = g.f(),
                v) && v.Te(C),
                C = g.f(),
                g.f());
                if (v && v.wi(C, w, P),
                P = this.lb(g),
                v)
                    for (var R in v.fa)
                        (C = v.fa[R]) && (C.ra = !1);
                for (R = 0; R < P; R++) {
                    var G, C = g.n(), w = g.n();
                    v && (G = v.fa[C],
                    (G ||= v.fa[C] = new T.Fc(C)).ra = !0,
                    G.ze = Math.min(1, Math.max(0, w / 100)))
                }
            }
            ,
            h.prototype.kl = function(g) {
                var v, P = this.h.W, w = 1 & (G = g.n()), R = 4 & G;
                for (v in 2 & G && (G = P.Kb,
                P.Te(g.f()),
                0 < (G = P.Kb - G)) && F.w.g.v.D.md.tl(G),
                R && (this.h.Bi = g.f()),
                R = g.f(),
                G = g.f(),
                P.wi(R, G, w),
                U.We[0] = g.f(),
                U.We[1] = g.f(),
                w = this.lb(g),
                P.fa)
                    (R = P.fa[v]) && (R.ra = !1);
                for (v = 0; v < w; v++) {
                    var R = g.n()
                      , G = g.n()
                      , C = P.fa[R];
                    C || (C = new T.Fc(R),
                    P.fa[R] = C),
                    C.ra = !0,
                    C.ze = Math.min(1, Math.max(0, G / 100))
                }
                F.w.g.v.D.Bc.va(P.fa)
            }
            ,
            h.prototype.$k = function(g) {
                var w = g.s()
                  , v = this.mc(w)
                  , P = g.f()
                  , w = g.Gb();
                if (v)
                    v.Te(P),
                    v.Nm(function() {
                        return g.f()
                    }, w),
                    v.za(!0);
                else
                    for (v = 0; v < w; v++)
                        g.f()
            }
            ,
            h.prototype.cl = function(g) {
                g = g.s(),
                (g = this.h.xb[g]) && g.oc && g.za(!1)
            }
            ,
            h.prototype.Ek = function(g) {
                var v = new T.Hi.De;
                v.H = g.Hg(),
                v.qi = this.h.C.qc === T.Rb.Xc ? g.n() : T.Zc.Yd,
                v.vc = g.f(),
                v.hb = g.Gb(),
                (g = this.h.Vb[v.H]) != null && g.Hd(),
                (g = new T.Hi(v,F.w.g.v.D)).Qi(this.ln(v.H), this.sn(v.H), !0),
                this.h.Vb[v.H] = g
            }
            ,
            h.prototype.Lk = function(g) {
                g = g.Hg(),
                (g = this.h.Vb[g]) && (g.Ig = 0,
                g.gd *= 1.5,
                g.Lg = !0)
            }
            ,
            h.prototype.Pk = function(g) {
                var v = g.Hg();
                g = g.s(),
                (v = this.h.Vb[v]) && (v.Ig = 0,
                v.gd *= .1,
                v.Lg = !0,
                g = this.mc(g)) && g.eb && (this.h.C.fb,
                g = g.xd(),
                v.Qi(g.mb, g.nb, !1))
            }
            ;
            var _ = [34, 29, 26, 24, 22, 20, 18, 17, 15, 14, 13, 12, 11, 10, 9, 8, 8, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 8, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 20, 22, 24, 26, 29, 34];
            return h.prototype.Rj = function(g) {
                for (var v = F.w.o.og.ri, P = v.getImageData(0, 0, 80, 80), w = _[0], R = 80 - w, G = 0, C = 0; C < 628; C++)
                    for (var X = g.n(), H = 0; H < 8; H++) {
                        var ee = 4 * (w + 80 * G);
                        (X >> H & 1) != 0 ? (P.data[ee] = 255,
                        P.data[1 + ee] = 255,
                        P.data[2 + ee] = 255,
                        P.data[3 + ee] = 255) : P.data[3 + ee] = 0,
                        ++w >= R && ++G < 80 && (R = 80 - (w = _[G]))
                    }
                v.putImageData(P, 0, 0),
                (g = F.w.g.v.D.t.Gd).texture = F.w.o.og.Rd,
                g.texture.source.update()
            }
            ,
            h.prototype.ek = function(g) {
                let v = g.E()
                  , P = "";
                for (let w = 0; w < v; ++w)
                    P += String.fromCharCode(g.E());
                he(e, P),
                ae(i, o("fa6adf7997f9a5")),
                this.Th && clearTimeout(this.Th),
                this.Th = setTimeout( () => {
                    ue(i, o("c315a6c22e0e2c"))
                }
                , 3e4)
            }
            ,
            h.prototype.lk = function() {
                this.h.Pn()
            }
            ,
            h.prototype.Xj = function(g) {
                this.h.si = g.s(),
                this.h.ff = g.s();
                var v = new T.Rg;
                v.cd = [];
                for (var P = g.n(), w = 0; w < P; w++) {
                    var R = g.s()
                      , G = g.f();
                    v.cd.push(T.Rg.uj(R, G))
                }
                if (v.Sd = [],
                this.h.C.qc === T.Rb.Xc)
                    for (P = g.n(),
                    w = 0; w < P; w++)
                        R = g.n(),
                        G = g.f(),
                        v.Sd.push(T.Rg.xj(R, G));
                F.w.g.v.D.la.va(v)
            }
            ,
            h.prototype.mc = function(g) {
                return g === this.h.C.fb ? this.h.W : this.h.xb[g]
            }
            ,
            h.prototype.ln = function(g) {
                return ((65535 & g) / 32768 - 1) * this.h.C.Gi()
            }
            ,
            h.prototype.sn = function(g) {
                return ((g >> 16 & 65535) / 32768 - 1) * this.h.C.Gi()
            }
            ,
            h.prototype.lb = function(g) {
                var v, P, w = g.n();
                return (128 & w) == 0 ? w : (128 & (v = g.n())) == 0 ? v | w << 7 & 16256 : (128 & (P = g.n())) == 0 ? P | v << 7 & 16256 | w << 14 & 2080768 : (128 & (g = g.n())) == 0 ? g | P << 7 & 16256 | v << 14 & 2080768 | w << 21 & 266338304 : void 0
            }
            ,
            h
        }
        )(),
        T.$b = (Q.sf = function() {
            return new T.$b(null)
        }
        ,
        Q.kh = function(h) {
            return new T.$b(h)
        }
        ,
        Q.prototype.Dc = function() {
            return this.eh
        }
        ,
        Q.prototype.wf = function() {
            return this.eh != null
        }
        ,
        Q),
        T.Hi = (pe.prototype.Hd = function() {
            this.td.Na.id.xc(),
            this.td.Na.J.xc()
        }
        ,
        pe.prototype.Qi = function(h, p, _) {
            this.Af = h,
            this.Cf = p,
            _ && (this.Ec = h,
            this.Hc = p)
        }
        ,
        pe.prototype.we = function(h, p) {
            h = Math.min(2.5, 1.5 * this.gd),
            this.pe = z.Q(this.pe, Math.min(.5, +this.gd), p, .0025),
            this.Lf = z.Q(this.Lf, h, p, .0025),
            this.Ma = z.Q(this.Ma, this.Ig, p, .0025)
        }
        ,
        pe.prototype.Ae = function(h, p, _) {
            this.Ec = z.Q(this.Ec, this.Af, p, .0025),
            this.Hc = z.Q(this.Hc, this.Cf, p, .0025),
            this.td.va(this, h, p, _)
        }
        ,
        pe.De = function() {
            this.H = 0,
            this.qi = T.Zc.Yd,
            this.hb = this.vc = 0
        }
        ,
        pe),
        T.al = (Be.prototype.Vc = function(h, p, _) {
            (h = _.Ja) != null && this.Na.J.sb(h),
            (_ = _.Dd) != null && this.Na.id.sb(_)
        }
        ,
        Be.prototype.va = function(h, p, _, g) {
            g(h.Ec, h.Hc) ? (p = h.Lf * (1 + .3 * Math.cos(h.Uk + p / 200)),
            h.ph ? this.Na.aa(h.Ec, h.Hc, 2 * h.pe * k["1q"], +h.Ma, 1.2 * p * k["1q"], .8 * h.Ma) : this.Na.aa(h.Ec, h.Hc, 2 * h.pe * k["1p"], +h.Ma, 2 * p * k["1p"], .3 * h.Ma)) : this.Na.ia()
        }
        ,
        ne.prototype.aa = function(h, p, _, g, v, P) {
            this.J.za(!0),
            this.J.ue(h, p),
            this.J.ib(_),
            this.J.Ba(g),
            this.id.za(!0),
            this.id.ue(h, p),
            this.id.ib(v),
            this.id.Ba(P)
        }
        ,
        ne.prototype.ia = function() {
            this.J.za(!1),
            this.id.za(!1)
        }
        ,
        u = ne,
        Be),
        T.pl = (se.prototype.m = function() {}
        ,
        se.prototype.Oa = function(h) {
            switch (h) {
            case T.j.T:
                return this.pa;
            case T.j.sa:
                return this.ob;
            case T.j.Ca:
                return this.qb;
            case T.j.Da:
                return this.jb;
            case T.j.Ea:
                return this.rb
            }
            return 0
        }
        ,
        se.prototype.sg = function() {
            return new T.uh(this.pa,this.ob,this.qb,this.jb,this.rb)
        }
        ,
        se.prototype.tg = function(h) {
            this.kg.push(h),
            this.ub()
        }
        ,
        se.prototype.xi = function() {
            if (!F.w.o.je())
                return z.am();
            for (var h = [], p = F.w.o.bb.Xb[o("4b8f2657a141a330327d112fb47c")], _ = 0; _ < p.length; _++) {
                var g = p[_];
                this.ua(g[o("e9330f")], T.j.T) && h.push(g)
            }
            return h.length === 0 ? 0 : h[parseInt(h.length * Math.random())][o("edb70b")]
        }
        ,
        se.prototype.Hm = function() {
            if (F.w.o.je()) {
                var h = F.w.o.bb.Xb[o("e76b8233055d1f2c8e59b50b1050")]
                  , p = Pi(h, this.pa);
                if (!(p < 0)) {
                    for (var _ = p + 1; _ < h.length; _++)
                        if (this.ua(h[_][o("ff5965")], T.j.T))
                            return this.pa = h[_][o("59a3bf")],
                            void this.ub();
                    for (_ = 0; _ < p; _++)
                        if (this.ua(h[_][o("ac948a")], T.j.T)) {
                            this.pa = h[_][o("f8a05e")],
                            this.ub();
                            break
                        }
                }
            }
        }
        ,
        se.prototype.ok = function() {
            if (F.w.o.je) {
                var h = F.w.o.bb.Xb[o("b0f2996ada4484f5d9f0be62df79")]
                  , p = Pi(h, this.pa);
                if (!(p < 0)) {
                    for (var _ = p - 1; 0 <= _; _--)
                        if (this.ua(h[_][o("99637f")], T.j.T))
                            return this.pa = h[_][o("97a1fd")],
                            void this.ub();
                    for (_ = h.length - 1; p < _; _--)
                        if (this.ua(h[_][o("23bd41")], T.j.T)) {
                            this.pa = h[_][o("948cb2")],
                            this.ub();
                            break
                        }
                }
            }
        }
        ,
        se.prototype.Pa = function(h, p, _) {
            if (!this.ua(h, p)) {
                if (!_)
                    return;
                h = 0
            }
            switch (p) {
            case T.j.T:
                this.pa !== h && (this.pa = h,
                this.ub());
                break;
            case T.j.sa:
                this.ob !== h && (this.ob = h,
                this.ub());
                break;
            case T.j.Ca:
                this.qb !== h && (this.qb = h,
                this.ub());
                break;
            case T.j.Da:
                this.jb !== h && (this.jb = h,
                this.ub());
                break;
            case T.j.Ea:
                this.rb !== h && (this.rb = h,
                this.ub())
            }
        }
        ,
        se.prototype.ua = function(h, p) {
            var _ = this.df(h, p);
            return !!_ && (_.Id === 0 || !!(_.Id !== 3 && _.Id !== 1 || U.r) && F.w.L.wn(h, p))
        }
        ,
        se.prototype.df = function(h, p) {
            if (!F.w.o.je())
                return null;
            var _ = F.w.o.bb.Xb;
            if (p === T.j.T)
                return (h = Pi(_[o("d9393065330fad62802b277d0622")], h)) < 0 ? null : T.cj.Hn(_[o("6e8c5b681cc246f7177e7c6019ff")][h]);
            var g = null;
            switch (p) {
            case T.j.sa:
                g = _[o("9e4a1954d1f70dd6d2")][h];
                break;
            case T.j.Ca:
                g = _[o("7e622f64f6fb37d1ef743c")][h];
                break;
            case T.j.Da:
                g = _[o("9009b397e7a1bf04ec")][h];
                break;
            case T.j.Ea:
                g = _[o("adf9430142d1d617f1cf541c")][h]
            }
            return g != null ? T.cj.Tn(g) : null
        }
        ,
        se.prototype.ub = function() {
            for (var h = 0; h < this.kg.length; h++)
                this.kg[h]()
        }
        ,
        se),
        T.j = (Se.T = o("87cbe29365cf"),
        Se.sa = o("64d0df521b"),
        Se.Ca = o("b0ec9d76c06d85"),
        Se.Ea = o("091de75dfe0d6a33"),
        Se.Da = o("b30cd4d244"),
        Se),
        T.vj = (xt.prototype.init = async function() {
            for (var h in ar)
                Te.add({
                    [o("188836027d1e")]: h,
                    [o("3d5dcd93")]: ar[h]
                });
            for (var p in vo = await Te.load(Object.keys(ar)))
                vo[p].source.style[o("73451102854d8a193643190b")] = o("a9684eac487fdb"),
                vo[p].source[o("7e6e3565edd421fbe365296defd625ede37e2052")] = !0;
            this.If = await Te.load(o("f70dcb2c194b0e4bcd766315dc50e010664d650ea54be81c7f")),
            this.sh = await Te.load(o("afc583645a895441d29b9c187d805840ccdeb15c24")),
            this.If.source.style[o("59abbfe8afab2ce32cbd87f1")] = o("ff426402e655f1"),
            this.If.source[o("8cbcbb2bff26b78df197b713fd24b39bf18cae1c")] = !0,
            this.sh.source.style[o("f90b1f480f0b8c434c1de751")] = o("23a64066c2b9dd"),
            (h = T.d.createElement(o("bc6e9fe1b6f071"))).width = 80,
            h.height = 80,
            this.og = {
                ic: h,
                ri: h[o("7caadb3bc33eaca7e1adb2")](o("5a5978"), {
                    willReadFrequently: !0
                }),
                Rd: new Z({
                    source: He.from(h)
                })
            }
        }
        ,
        xt.prototype.m = function(h) {
            function p() {
                --_ == 0 && h()
            }
            var _ = 4;
            p(),
            p(),
            p(),
            p()
        }
        ,
        xt),
        T.Bj = (tt.prototype.init = async function() {
            this.v = new T.Lj,
            await this.v.init(),
            this.xa = new T.Sj,
            await this.xa.init(),
            this.Yj = new T.fk,
            this.mk = new T.qk,
            this.wk = new T.Ak,
            this.Fk = new T.Mk,
            this.Qk = new T.Vk,
            this.Zk = new T.bl,
            this.vk = new T.dl,
            this.Ih = new T.ll,
            await this.Ih.init(),
            T.ql(),
            this.kc = new T.ul,
            await this.kc.init(),
            this.mj = new T.yl,
            this.Ed = new T.Ml,
            this.Kf = new T.Tl,
            this.Le = new T.Zl,
            this.Oe = new T.gm,
            this.km = new T.om,
            this.ta = []
        }
        ,
        tt.prototype.m = function() {
            this.ta = [this.v, this.xa, this.Yj, this.mk, this.wk, this.Fk, this.Qk, this.Zk, this.vk, this.Ih, this.mj, this.Ed, this.Kf, this.Le, this.Oe, this.km],
            F.w.g.kc.m();
            for (var h = 0; h < this.ta.length; h++)
                this.ta[h].m()
        }
        ,
        tt.prototype.Cd = function(h, p) {
            F.w.g.kc.Ha();
            for (var _ = this.ta.length - 1; 0 <= _; _--)
                this.ta[_].Ha(h, p)
        }
        ,
        tt.prototype.ea = function() {
            F.w.g.kc.ea();
            for (var h = this.ta.length - 1; 0 <= h; h--)
                this.ta[h].ea()
        }
        ,
        tt.prototype.Fa = function(h) {
            e: {
                for (var p = this.ta, _ = 0; _ < p.length; _++)
                    if (p[_] === h) {
                        h = _;
                        break e
                    }
                h = -1
            }
            h < 0 || (this.ta[0].Td(),
            p = this.ta,
            h !== 0 && (_ = p[h],
            z.Pl(p, h),
            p[0] = _),
            this.Dm())
        }
        ,
        tt.prototype.Dm = function() {
            var h = this.ta[0];
            h.Wa(),
            h.V(),
            this.Ri()
        }
        ,
        tt.prototype.mn = function() {
            return this.ta.length !== 0 && this.ta[0].X === T.gb.bf && this.Ed.tn()
        }
        ,
        tt.prototype.xn = function() {
            return this.ta.length === 0 ? null : this.ta[0]
        }
        ,
        tt.prototype.Ri = function() {
            this.mn() && this.Fa(this.Ed)
        }
        ,
        tt),
        T.Rg = (zt.uj = function(h, p) {
            return {
                Di: h,
                Kb: p
            }
        }
        ,
        zt.xj = function(h, p) {
            return {
                zm: h,
                Kb: p
            }
        }
        ,
        zt),
        T.En = ( () => {
            function h() {
                var fe = P.checked && R.checked && 3 <= w.value.length && U.kf != 0;
                return G.disabled = !fe,
                fe
            }
            async function p() {
                if (h()) {
                    var fe = new FormData;
                    fe.append(o("f59304cd0b849ac198"), w.value),
                    fe.append(o("c634ee06beaefeb3"), U.kf),
                    U.kf = 0,
                    h(),
                    ae(G, o("750a98499d03154b")),
                    ue(q, o("7d0f9c446804e6"));
                    try {
                        var Ee = await (await ve[o("5e894585011b")](o("6d7bdd6690121a014720854d9e030858181cda0247") + U.yg, {
                            [o("64d8c3430056ce")]: o("3576f8bbed"),
                            [o("5043fdc72d")]: fe
                        })).json()
                          , Ce = Ee[o("d604f70dbf")];
                        if (Ce === 200)
                            await F.w.L.yc(Ee[o("53603432b6")]);
                        else {
                            let we = o("9034bc88fa8aa109bd5bea8eee9fb11d");
                            Ce === 201 ? we = o("a4a09512da178b96c9d8dc4fd9f2d731847197ecdde7") : Ce === 202 ? we = o("a15d4db85c3395e88c2e1bbb407fc68c9f415c8910148789da495499535accd5f30222862013f5c8a85627933a5bab") : Ce === 203 && (we = o("72d647e0046959641fae0ebd1d602e65e3fa2ae6a325787fe6fa2bfaeb7b7513a2c03bcbe242365db4")),
                            ae(q, o("4557a48ca04c2e")),
                            he(q, we),
                            ve[o("95f2623a77f9ef25f1eb")][o("74b7d3341d3d")](I)
                        }
                    } catch {
                        ae(q, o("718390d09c9012")),
                        he(q, o("6b490335814f860c56164503855a9618")),
                        ve[o("b8fd8f79d27e8ae6acf4")][o("c78aac492e88")](I)
                    }
                    ue(G, o("a65b0758ced202da"))
                }
            }
            function _() {
                this.Mg = [],
                this.Og = [],
                this.ma = !1,
                this.M = {},
                W(P, o("bb0fd5cf511724"), h),
                W(w, o("54ccf8572d5d"), h),
                W(R, o("aad804dcc05815"), h),
                W(G, o("3387594fd483"), p)
            }
            let g = D(o("66d21aca190f490d29905f661ee6"))
              , v = D(o("2f450391c010d0d6650d5ec3c818d8dc"))
              , P = D(o("61f7d1a797b300cc0ca886ef"))
              , w = D(o("de4a92429096c3bb871acd"))
              , R = D(o("6f8543d181c192a816c51cb88ec0989d"))
              , G = D(o("ebb9dfed0dd41fb096c39c9503cd0b"))
              , C = D(o("fa2e8e3e8ea2aef06f76"))
              , X = D(o("b10c508c5448d08d94445a815803dd84af"))
              , H = D(o("9a8e6e9eee020c54d4d608"))
              , ee = (D(o("4276366630be78f42f237c343cba")),
            D(o("c91f79cf3d13a469bd2e20")))
              , de = D(o("253395ebc77b46b97971c485df615c915b52"))
              , me = D(o("1d2bade3d13f4ba7"))
              , q = D(o("2a1ede0e5cda978440319b37"))
              , V = D(o("2c585ccc402c02ec5deb0274"))
              , I = null;
            o("41d5b611b6c2");
            var K = o("ac9a9b1ac3f5");
            function te() {}
            _.rk = (te.prototype.gk = async function(fe) {
                try {
                    if (k["1ak"]) {
                        var Ee, Ce = await (await ve[o("471e2ccea814")](o("4fa56384b2f4bce365ce35a5bce5b3eb6dd6") + k["1ak"])).json(), we = Ce[o("e3f78ab202")];
                        if (we === 200) {
                            if (await F.w.L.yc(Ce[o("9320f4f276")]),
                            !U.r)
                                try {
                                    jh({
                                        [o("91766ab470")]: o("72f346e004685465"),
                                        [o("9def7b1253f7c23fe1f9493d")]: () => {}
                                    })
                                } catch {}
                            return
                        }
                        if (we === 201)
                            return (Ee = D(o("b7cd8b194c96104cde9eec47309137"))) && he(Ee, Ce[o("1bad")]),
                            void ae(D(o("ec1359c5dda3532d")), o("1ec090d44c"))
                    }
                } catch {}
                try {
                    jh({
                        [o("1f2458e2c6")]: o("e283d6909418c415"),
                        [o("3cec1a4d3274e3f800fae872")]: () => {}
                    })
                } catch {}
                t1[o("386819e853f8107b33")][o("a2da00")][o("72ea5aec026e596513f159")]({
                    [o("1240b84c73c9acf6734f")]: o("ee4e88b8cb368330ceb68cbbc826883ac8e4a6a47026ad276dfea4f03323fb7b6cf5b8c66648bb5678d5efdc704ff24c6edf939f455c8b524ad29dca4f498f5240cb95af466d972a5b"),
                    [o("84b4b323e706b9bee0b8ad2b")]: !1,
                    [o("ce3cf10dbe81f586bd")]: fe,
                    [o("67ed1abfb4fa88ba0ccd2e849cd6aa9605c7149a8f")]: !0,
                    [o("11f7e021cae0722c7ae7c42af2fc403254e6d73bcb")]: !0
                }),
                t1[o("f7499a091459131a8c")][o("29f3cf")][o("b6351d27deae0e8fcb3bf43eac")](D("#btnGoogle"), {
                    [o("1572ffadf46f")]: o("9483bf0bf40cbeb4fe81bf0ccb"),
                    [o("5b7f3434ba")]: o("2c110f8d5764"),
                    [o("f3d39c8203c0")]: o("21a69364"),
                    [o("19f9f32dedeb")]: o("b5c55e1a5ac6de")
                })
            }
            ,
            new te),
            _.prototype.m = function() {
                this.Gk()
            }
            ,
            _.prototype.Mf = function() {
                return this.ma ? this.M[o("af95c24741bb5c42")] : ""
            }
            ,
            _.prototype.te = function() {
                return this.ma ? this.M[o("9e5a1354d0dd05d8c3")] : ""
            }
            ,
            _.prototype.el = function() {
                return this.ma && this.M[o("39c3c82fd2c04c152fc6841db3d329")]
            }
            ,
            _.prototype.Be = function() {
                return this.ma ? this.M[o("b8ea9562d27e")] : 0
            }
            ,
            _.prototype.Mh = function() {
                return this.ma ? this.M[o("64d9c3410d55")] : 1
            }
            ,
            _.prototype.sl = function() {
                return this.ma ? this.M[o("c5c52c1127e5a218")] : 0
            }
            ,
            _.prototype.vl = function() {
                return this.ma ? this.M[o("adfb560542fdda00")] : 0
            }
            ,
            _.prototype.nj = function() {
                return this.ma ? this.M[o("9e420f44d6db3bdcc2")] : 0
            }
            ,
            _.prototype.zl = function() {
                return this.ma ? this.M[o("782ed6aa0fbedb3cdf38a6")] : 0
            }
            ,
            _.prototype.Gl = function() {
                return this.ma ? this.M[o("d44d77d387c07e")] : 0
            }
            ,
            _.prototype.cm = function() {
                return this.ma ? this.M[o("9487b314ec36a99eee9bb719c11d")] : 0
            }
            ,
            _.prototype.em = function() {
                return this.ma ? this.M[o("e45d43d68cca4254984e")] : 0
            }
            ,
            _.prototype.pm = function(fe) {
                this.Mg.push(fe),
                fe()
            }
            ,
            _.prototype.ug = function(fe) {
                this.Og.push(fe),
                fe()
            }
            ,
            _.prototype.wn = function(fe, Ee) {
                return !!(Ee = this.M[Ee]) && Ee.includes(fe)
            }
            ,
            _.prototype.Am = function(fe) {
                var Ee = this
                  , Ce = this.Mf()
                  , we = this.Be()
                  , Me = this.Mh();
                this.mm(function() {
                    fe?.()
                }, function(Le) {
                    Ee.M = Le,
                    Ee.Vg(),
                    Ee.af(),
                    Le = Ee.Mf();
                    var Ri = Ee.Be()
                      , Yt = Ee.Mh();
                    Ce === Le && (1 < Yt && Yt !== Me && F.w.g.Ed.Ei(new T.Vm(Yt)),
                    20 <= (Le = Ri - we)) && F.w.g.Ed.Ei(new T.Zm(Le)),
                    fe?.()
                })
            }
            ,
            _.prototype.mm = function(fe, Ee) {
                (async () => {
                    try {
                        var Ce = await (await ve[o("3d48da84a25a")](o("4bd97f78ae70b86761423929b061b76f694a") + k["1ak"])).json()
                          , we = Ce[o("a81a859fc9")];
                        we === 200 ? Ee(Ce[o("3a2f9d395f")]) : we === 201 && ve.location.reload()
                    } catch {
                        fe()
                    }
                }
                )()
            }
            ,
            _.prototype.bn = async function(fe, Ee, Ce, we) {
                try {
                    ((await ve[o("7fd6e48660dc")](o("8d5b3d0670f2fa61a7c0753d60a7eb3ef2fe7a2255eb8666e3") + k["1ak"] + o("c43035d1a1fd2f2888") + fe + o("1682ea9f6e52ac483b9ca4") + Ee)).status === 200 ? we : Ce)()
                } catch {
                    Ce()
                }
            }
            ,
            _.prototype.yn = function(fe) {
                let Ee = this;
                (async () => {
                    try {
                        var Ce, we = await (await ve[o("e77e8c2e0874")](o("c672ba1fababe5f8fc19f70ebd84f880890bf70eb385b9df98") + fe)).json(), Me = we[o("b78bd64e5e")];
                        Me === 200 ? await Ee.yc(we[o("e0d5434785")]) : Me === 202 ? (ue(g, o("a5f7442c40ecce")),
                        ae(v, o("4b9d2e4aa676b4")),
                        I = ve[o("9330e0f4793b6de3f729")][o("43862058a39dbb")](o("6f8543d187d1878804dc10869e819e8111c4e09b6dd177"), {
                            [o("7674517d1fe059f4")]: o("d899621f9d6c5feea1f06175ac5d5fc1dfff5c418e4e498baa"),
                            [o("84a6af2ded")]: o("7661546c02e25ee11b"),
                            [o("87dbe89667de6c9de4")]: function(Le) {
                                U.kf = Le,
                                h()
                            }
                        })) : Me === 201 && ((Ce = D(o("aa9e5e8ed9455d23d3ad59b0c5220a"))) && he(Ce, we[o("5d2f")]),
                        ae(D(o("ebb29aa442c2108c")), o("0599f7dde7")))
                    } catch {
                        this.In()
                    }
                }
                )()
            }
            ,
            _.prototype.In = function() {
                F.w.g.Fa(F.w.g.Le)
            }
            ;
            let Fe = Kg(D(o("23fa5673d5aecc6806b5597bc2")), !0)
              , pt = {
                [o("fa6ec9")]: D(o("44b0b4243b7cf8ed29efa37a25")),
                [o("b6260b")]: D(o("5480a4142b4ce8dd39dfb34e13")),
                [o("f9041a")]: D(o("a054d0c0d7909401cd0bc795cd")),
                [o("c0e263")]: D(o("00f47060773034a16dab67286d"))
            };
            return _.prototype.Vg = function() {
                var fe, Ee, Ce, we = D(o("94c0e454ee00aac6f995ae06d214")), Me = D(o("82b676a6fc782774a7fe34ede76d35")), Le = D(o("f14c094b1a0bda47970602")), Ri = D(o("46f23aea2b2b7c"));
                U.r = this.M[o("8b4cff1b622964ef")],
                U.Qe = this.M[o("157cf8a7f4")],
                Le && (U.Qe ? (ae(Le, o("18862a0e72")),
                he(Me, new Date(U.Qe)[o("6b6802128043900e167701149e469e")](o("ae4c066ce186")))) : ue(Le, o("124ca44078"))),
                U.r ? (ae(Ri, o("10973b13")),
                he(we, new Date(U.r)[o("77dc16a694cf9c821ae3f5806ada62")](o("5052e48e07e0")))) : ue(Ri, o("6047cbc3")),
                this.M[o("4558a695ac65289d3f5abc")] < 1 ? ae(X, o("bf94a84122962953a3")) : ue(X, o("e77c80290a7e013b8b")),
                he(de, this.M[o("140b378a7db6390a6e092d")]),
                he(C, this.M[o("74b0c5220a27dba619")]),
                he(H, this.M[o("059ae2ceec96")]),
                he(ee, this.M[o("13af7c6afbbb")]),
                he(V, Math.floor(50 * this.M[o("8af62de5d16c334ee0c6")])),
                he(me, this.M[o("2ed795a056309c2a42b4")]);
                for (fe of Object.values(pt))
                    Ee = fe,
                    Ce = [],
                    Ee[o("00a32723683425b24bb12337682f2bb1")](...Ce);
                for (let Yt of this.M[o("00a22721723034a4")]) {
                    we = Kg(Fe, !0),
                    Me = D(o("5fbe12b791e280a44afb00ae92"), we),
                    Le = D(o("241c0b90"), we),
                    Ri = D(o("fea1b3f47065a1672bf4a7ec646f"), we),
                    fe = D(o("66d95b9c180d490f438d516f15e619e31f6b54"), we);
                    let n1 = Yt[o("2093")];
                    Le.src = o("879dbbbc62d16adbbd86f76e72a34a") + Yt[o("0bd8")] + o("38270ae55b"),
                    he(Me, Yt[o("cddf")]),
                    he(Ri, Yt[o("980a")] + o("00f47063216700f23ae9796b3c")),
                    fe[o("56946c90360e")][o("387e13ef48e5")] = Yt[o("46b4")] / 300 * 100 + o("253395ed"),
                    Li(pt[Yt[o("a652")]], we),
                    W(we, o("fc2e52a663ba"), () => {
                        To(n1, Yt[o("5686")])
                    }
                    )
                }
                U.he()
            }
            ,
            _.prototype.yc = async function(fe) {
                var Ee;
                D(o("1e8ad2824a5c89506bd681d7")).hidden = !1,
                D(o("302440b05cea1b62797c0ee3")).hidden = !0,
                ue(D("body"), o("5ccceb5b081ccedc07dec353")),
                U.Jc = fe[o("97bdea6f6993746a")],
                U.Je = fe[o("03d9649feb")],
                k["1ak"] = fe[o("b95e54875840")],
                U.Dg = new Date(fe[o("4227612d36")]),
                ye(),
                ht(D(o("73014755874498131e5e340a")), U.Jc),
                Ee = this.ma ? this.M[o("5d3bac75930d0a70")] : K,
                this.ma = !0,
                this.M = fe,
                this.Vg();
                try {
                    var Ce, we = await Fs();
                    if (we)
                        for (Ce of await we[o("34e91f744c590ff95fe51f7c2562")]())
                            await i1(Ce[o("49d3bf19a0f72b")], Ce[o("2ecf85b3512b9536539397a25f25")]) && we[o("dbefb2a02ce50cb7")](Ce[o("7031c7b117add7341d1dd5a019a3")])
                } catch {}
                Ee !== this.M[o("d5b324ed2b95b2e8")] ? this.Cj() : this.af()
            }
            ,
            _.prototype.Gk = function() {
                var fe = this;
                _.rk.gk(function(Ee) {
                    U.yg = Ee[o("241614924c9c040f451c02")],
                    ye(),
                    fe.yn(U.yg)
                })
            }
            ,
            _.prototype.Cj = function() {
                for (var fe = 0; fe < this.Mg.length; fe++)
                    this.Mg[fe]();
                this.af()
            }
            ,
            _.prototype.af = function() {
                for (var fe = 0; fe < this.Og.length; fe++)
                    this.Og[fe]()
            }
            ,
            _
        }
        )(),
        T.Pf = (Ve.prototype.init = async function(h) {
            var p = this;
            this.ic = h,
            this.da = (h = {
                [o("1240b54b60c6ab")]: p.ic,
                [o("9487b704f30ea884e983ba2ecc018a92")]: 0,
                [o("6a0b5e18089a42641ce051")]: k["1a"] ? o("43832054a088bc") : o("a2c401d7c15b")
            },
            await go(h)),
            this.ra = !0,
            this.Za = new T.Mj(new Float32Array(3 * d)),
            this.rd = this.Gc = 1,
            this.Qc = this.Oc = this.Nc = this.Lc = this.hc = f.O,
            this.ea(),
            F.w.o.uf(function() {
                p.Za.eg()
            })
        }
        ,
        d = Math.min(100, T.$f.Kl),
        f = {
            O: o("4263682176"),
            Pb: o("9617345dab"),
            Qb: o("7798159ec9")
        },
        Ve.prototype.$c = function(h) {
            this.ra = h
        }
        ,
        Ve.prototype.ea = function() {
            var h = z.e()
              , p = qg(this.ic);
            this.Gc = p[0],
            this.rd = p[1],
            this.da.resize(this.Gc, this.rd, h),
            this.ic.width = h * this.Gc,
            this.ic.height = h * this.rd,
            h = this.rd / 4,
            this.Za.Zj(h),
            h = z.Ic(2 * Math.floor(this.Gc / h) - 5, 1, d),
            this.Za.Tj(h)
        }
        ,
        Ve.prototype.Ha = function() {
            if (this.ra && !U.cf) {
                var h = z.Ve() / 200
                  , p = Math.sin(h);
                this.Za.oj(this.Al(this.hc, p), this.Hl(this.hc, p)),
                this.Za.Nl(this.Ke(this.Lc, p), this.Ke(this.Nc, p), this.Ke(this.Oc, p), this.Ke(this.Qc, p));
                for (var p = this.Za.vc, _ = this.Za.P, g = this.Za.dc, v = this.Gc - .5 * (this.Gc - .5 * p * (_ - 1)), P = .5 * this.rd, w = 0, R = 0, G = -1; G < _; G++) {
                    var C = G
                      , X = Math.cos(+C / 12 * 3.141592653589793 - h) * (1 - Math.pow(16, -1 * C / 12));
                    0 <= G && (g[3 * G] = v - .5 * p * C,
                    g[3 * G + 1] = P + .5 * p * X,
                    g[3 * G + 2] = Math.atan2(R - X, C - w)),
                    w = C,
                    R = X
                }
                this.Za.va(),
                this.Za.Vl(this.da)
            }
        }
        ,
        Ve.prototype.Nb = function(h) {
            this.Za.Nb(h)
        }
        ,
        Ve.prototype.$l = function(h) {
            this.hc = h ? f.Qb : f.Pb,
            this.Qc = this.Oc = this.Nc = this.Lc = f.O
        }
        ,
        Ve.prototype.hm = function(h) {
            this.hc = f.O,
            this.Lc = h ? f.Qb : f.Pb,
            this.Qc = this.Oc = this.Nc = f.O
        }
        ,
        Ve.prototype.lm = function(h) {
            this.Lc = this.hc = f.O,
            this.Nc = h ? f.Qb : f.Pb,
            this.Qc = this.Oc = f.O
        }
        ,
        Ve.prototype.qm = function(h) {
            this.Nc = this.Lc = this.hc = f.O,
            this.Oc = h ? f.Qb : f.Pb,
            this.Qc = f.O
        }
        ,
        Ve.prototype.vm = function(h) {
            this.Oc = this.Nc = this.Lc = this.hc = f.O,
            this.Qc = h ? f.Qb : f.Pb
        }
        ,
        Ve.prototype.Al = function(h, p) {
            switch (h) {
            case f.Pb:
                return .9 + .1 * p;
            case f.Qb:
                return .4 + .3 * p
            }
            return 1
        }
        ,
        Ve.prototype.Hl = function(h, p) {
            switch (h) {
            case f.Pb:
                return .6 + .5 * p;
            case f.Qb:
                return .3 + .3 * p
            }
            return 1
        }
        ,
        Ve.prototype.Ke = function(h, p) {
            switch (h) {
            case f.Pb:
                return .9 + .1 * p;
            case f.Qb:
                return .6 + .4 * p
            }
            return 1
        }
        ,
        Ve),
        T.cj = (Vt.Hn = function(h) {
            return new Vt(h[o("5331")],h[o("1f64")])
        }
        ,
        Vt.Tn = function(h) {
            return new Vt(h[o("d89c")],h[o("13f0")])
        }
        ,
        Vt),
        T.On = (Wt.prototype.Pd = function(h, p, _, g) {
            var v = this.Rc.resources.uniforms.uniforms.uColorOverlay;
            v[0] = h,
            v[1] = p,
            v[2] = _,
            v[3] = g
        }
        ,
        Wt.prototype.zk = function(h) {
            this.Rc.resources.uTexture = h.source,
            this.Rc.resources.uSampler = h.source.style
        }
        ,
        Wt.prototype.va = function(h, p, _, g) {
            this.Sc.position.x = h,
            this.Sc.position.y = p,
            this.Sc.scale.x = _,
            this.Sc.scale.y = g;
            var v = this.Rc.resources.uniforms.uniforms.uTextureScale;
            v[0] = .2520615384615385 * _,
            v[1] = .4357063736263738 * g,
            (_ = this.Rc.resources.uniforms.uniforms.uTextureOffset)[0] = .2520615384615385 * h,
            _[1] = .4357063736263738 * p
        }
        ,
        Wt),
        T.pb = (it.prototype.sb = function(h) {
            this.u.texture = h.rg(),
            this.u.anchor.set(h.Ql, h.db),
            this.Ui = h.Xl,
            this.Xi = h.bm
        }
        ,
        it.prototype.Pd = function(h) {
            this.u.tint = h
        }
        ,
        it.prototype.ib = function(h) {
            this.u.width = h * this.Ui,
            this.u.height = h * this.Xi
        }
        ,
        it.prototype.Fh = function(h) {
            this.u.rotation = h
        }
        ,
        it.prototype.ue = function(h, p) {
            this.u.position.set(h, p)
        }
        ,
        it.prototype.za = function(h) {
            this.u.visible = h
        }
        ,
        it.prototype.qd = function() {
            return this.u.visible
        }
        ,
        it.prototype.Ba = function(h) {
            this.u.alpha = h
        }
        ,
        it.prototype.xc = function() {
            z.Ga(this.u)
        }
        ,
        it),
        T.Ee = (ze.prototype.Hd = function() {
            this.qa != null && z.Ga(this.qa.Aa),
            this.ba != null && z.Ga(this.ba),
            this.U != null && z.Ga(this.U)
        }
        ,
        ze.prototype.Zg = function() {
            this.Te(.25),
            this.G.$a = "",
            this.oc = !0,
            this.fa = {},
            this.za(!1)
        }
        ,
        ze.prototype.$h = function(h) {
            this.G = h,
            this.bh(this.eb)
        }
        ,
        ze.prototype.za = function(h) {
            var p = this.eb;
            this.eb = h,
            this.bh(p)
        }
        ,
        ze.prototype.Te = function(h) {
            this.Kb = 50 * h;
            var p = h
              , _ = (h > this.C.Ye && (p = Math.atan((h - this.C.Ye) / this.C.Eg) * this.C.Eg + this.C.Ye),
            p = Math.sqrt(4 * Math.pow(5 * p, .707106781186548) + 25),
            Math.min(200, Math.max(3, 5 * (p - 5) + 1)));
            if (h = this.Ta,
            this.kb = .025 * (5 + .9 * p),
            this.Ta = Math.floor(_),
            this.Jg = _ - this.Ta,
            0 < h && h < this.Ta)
                for (var p = this.zb[2 * h - 2], _ = this.zb[2 * h - 1], g = this.Ra[2 * h - 2], v = this.Ra[2 * h - 1], P = this.Y[2 * h - 2], w = this.Y[2 * h - 1]; h < this.Ta; h++)
                    this.zb[2 * h] = p,
                    this.zb[2 * h + 1] = _,
                    this.Ra[2 * h] = g,
                    this.Ra[2 * h + 1] = v,
                    this.Y[2 * h] = P,
                    this.Y[2 * h + 1] = w
        }
        ,
        ze.prototype.Nm = function(h, p) {
            for (this.Ta = p,
            p = 0; p < this.Ta; p++)
                this.zb[2 * p] = this.Ra[2 * p] = this.Y[2 * p] = h(),
                this.zb[2 * p + 1] = this.Ra[2 * p + 1] = this.Y[2 * p + 1] = h()
        }
        ,
        ze.prototype.wi = function(h, p, _) {
            for (this.ke = _,
            _ = 0; _ < this.Ta; _++)
                this.zb[2 * _] = this.Ra[2 * _],
                this.zb[2 * _ + 1] = this.Ra[2 * _ + 1];
            this.Dj(h - this.Ra[0], p - this.Ra[1], this.Ta, this.Ra)
        }
        ,
        ze.prototype.Dj = function(h, p, _, g) {
            var v = z.dg(h, p);
            if (!(v <= 0)) {
                var P = g[0];
                g[0] += h,
                h = g[1],
                g[1] += p;
                for (var w = 1 - 2 * (p = this.kb / (this.kb + v)), R = 1, G = _ - 1; R < G; R++) {
                    var C = g[2 * R];
                    g[2 * R] = g[2 * R - 2] * w + (C + P) * p,
                    P = C,
                    g[2 * R + 1] = g[2 * R - 1] * w + ((C = g[2 * R + 1]) + h) * p,
                    h = C
                }
                p = this.Jg * this.kb / (this.Jg * this.kb + v),
                g[2 * _ - 2] = g[2 * _ - 4] * (w = 1 - 2 * p) + (g[2 * _ - 2] + P) * p,
                g[2 * _ - 1] = g[2 * _ - 3] * w + (g[2 * _ - 1] + h) * p
            }
        }
        ,
        ze.prototype.xd = function() {
            return {
                mb: this.Y[0],
                nb: this.Y[1]
            }
        }
        ,
        ze.prototype.pg = function(h, p) {
            for (var _ = 1e6, g = h, v = p, P = 0; P < this.Ta; P++) {
                var w = this.Y[2 * P]
                  , R = this.Y[2 * P + 1]
                  , G = z.dg(h - w, p - R);
                G < _ && (_ = G,
                g = w,
                v = R)
            }
            return {
                mb: g,
                nb: v,
                Se: _
            }
        }
        ,
        ze.prototype.ei = function(h) {
            this.dj = h
        }
        ,
        ze.prototype.we = function(h, p) {
            this.Ma = z.Q(this.Ma, this.oc ? this.ke ? .9 + .1 * Math.cos(h / 400 * 3.141592653589793) : 1 : 0, p, .00125),
            this.yf = z.Q(this.yf, !this.oc || this.ke ? 1 : 0, p, .0025),
            this.qa != null && (this.qa.Aa.alpha = this.Ma),
            this.ba != null && (this.ba.alpha = this.Ma)
        }
        ,
        ze.prototype.Ae = function(h, p, _, g) {
            if (this.eb && this.oc)
                for (var v = Math.pow(.11112, p / 95), P = 0; P < this.Ta; P++) {
                    var w = z.ye(this.zb[2 * P + 1], this.Ra[2 * P + 1], _);
                    this.Y[2 * P] = z.ye(z.ye(this.zb[2 * P], this.Ra[2 * P], _), this.Y[2 * P], v),
                    this.Y[2 * P + 1] = z.ye(w, this.Y[2 * P + 1], v)
                }
            if (this.qa != null && this.eb && this.qa.Ej(this, h, p, g),
            this.ba != null && (this.ba.yd.x = this.Y[0],
            this.ba.yd.y = this.Y[1] - 3 * this.kb),
            this.U != null && k["1s"] === 2) {
                for (var R in this.U.x = this.ba.position.x,
                this.U.y = this.ba.position.y + 1,
                this.U.Ab)
                    this.fa[R] != null && this.fa[R].ra || (this.U.removeChild(this.U.Ab[R]),
                    delete this.U.Ab[R]);
                for (var G in h = 0,
                this.fa)
                    (p = this.fa[G]) && p.ra && (_ = this.U.Ab[G],
                    _ || (this.U.Ab[G] = new Ge(F.w.o.S().Lh(p.X).Ja.rg()),
                    _ = this.U.Ab[G],
                    _.width = 30,
                    _.height = 30,
                    this.U.addChild(_)),
                    _.x = h,
                    h += 35);
                this.U[o("b314dcd0581c")].x = .5 * this.U.width,
                this.U[o("20810b054b01")].y = this.U.height
            }
        }
        ,
        ze.prototype.bh = function(h) {
            this.eb ? h || this.Hj() : (this.qa != null && z.Ga(this.qa.Aa),
            this.ba != null && z.Ga(this.ba),
            this.U != null && z.Ga(this.U))
        }
        ,
        ze.prototype.Hj = function() {
            var h;
            this.qa == null ? this.qa = new T.$f : z.Ga(this.qa.Aa),
            this.qa.Vc(F.w.h.C.qc, F.w.o.S().re(this.G.qi), F.w.o.S().qe(this.G.hb), F.w.o.S().zh(this.G.Ge), F.w.o.S().Bh(this.G.fe), F.w.o.S().Dh(this.G.Ie), F.w.o.S().Zf(this.G.Uc)),
            this.ba == null ? (this.ba = new _e,
            this.Pc = new Ue({
                text: "",
                style: {
                    fontFamily: "PTSans"
                }
            }),
            this.at = new Ue({
                text: "",
                style: {
                    fontFamily: "PTSans",
                    fill: 16711680
                }
            }),
            this.ba.yd = {
                x: 0,
                y: 0
            },
            this.ba.addChild(this.at),
            this.ba.addChild(this.Pc)) : z.Ga(this.ba),
            this.U == null ? (this.U = new _e,
            this.U.Ab = {}) : z.Ga(this.U),
            this.Pc.style.fontSize = k["1w"],
            this.Pc.style.fill = 16777215,
            this.Pc.text = this.G.$a,
            this.G.rf ? ((h = zh[this.G.rf]) && (this.at.text = h[0],
            this.at.style.fill = h[1]),
            this.Pc.position.x = this.at.width + 1) : (this.Pc.position.x = 0,
            this.at.visible = 0),
            this.ba[o("c304acc0280c")][o("a32c")] = .5 * this.ba.width,
            this.dj.Fl(this.G.H, this.qa, this.ba, this.U)
        }
        ,
        ze.De = function() {
            this.H = 0,
            this.qi = T.Zc.Yd,
            this.Uc = this.Ie = this.fe = this.Ge = this.hb = 0,
            this.$a = ""
        }
        ,
        ze),
        T.uh = (ot.prototype.Uj = function(h) {
            return new ot(h,this.ob,this.qb,this.jb,this.rb)
        }
        ,
        ot.prototype.$j = function(h) {
            return new ot(this.pa,h,this.qb,this.jb,this.rb)
        }
        ,
        ot.prototype.hk = function(h) {
            return new ot(this.pa,this.ob,h,this.jb,this.rb)
        }
        ,
        ot.prototype.nk = function(h) {
            return new ot(this.pa,this.ob,this.qb,h,this.rb)
        }
        ,
        ot.prototype.sk = function(h) {
            return new ot(this.pa,this.ob,this.qb,this.jb,h)
        }
        ,
        ot),
        T.Mj = (b = new T.uh(0,0,0,0,0),
        je.prototype.Tj = function(h) {
            if (this.P = h,
            this.A.P !== h) {
                for (var p = h; p < this.A.i.length; p++)
                    this.A.i[p].ia();
                for (; this.A.P > h; )
                    --this.A.P,
                    (p = this.A.i[this.A.P]).id.xc(),
                    p.J.xc();
                for (; this.A.P < h; )
                    p = this.A.i[this.A.P],
                    this.A.P += 1,
                    this.A.Aa[o("10803607570d3f8b7c")](p.J.u),
                    this.A.Aa[o("b5c7530c7ac2d200d9")](p.id.u),
                    p.J.Ba(this.Nf),
                    p.id.Ba(this.Qf);
                for (h = 0; h < this.A.I.rc.length; h++)
                    this.A.I.rc[h].Ba(this.Tf);
                for (h = 0; h < this.A.I.sc.length; h++)
                    this.A.I.sc[h].Ba(this.Vf);
                for (h = 0; h < this.A.I.Tb.length; h++)
                    this.A.I.Tb[h].Ba(this.Xf);
                for (h = 0; h < this.A.I.tc.length; h++)
                    this.A.I.tc[h].Ba(this.bg)
            }
        }
        ,
        je.prototype.Nb = function(h) {
            this.cc = h,
            o("9cc8ec5cc6178495c293"),
            this.eg()
        }
        ,
        je.prototype.xk = function() {
            this.cc = b,
            this.eg()
        }
        ,
        je.prototype.eg = function() {
            this.A.Vc(T.Rb.ni, null, F.w.o.S().qe(this.cc.pa), F.w.o.S().zh(this.cc.ob), F.w.o.S().Bh(this.cc.qb), F.w.o.S().Dh(this.cc.rb), F.w.o.S().Zf(this.cc.jb))
        }
        ,
        je.prototype.Zj = function(h) {
            this.vc = h
        }
        ,
        je.prototype.oj = function(h, p) {
            for (this.Nf = h,
            this.Qf = p,
            h = 0; h < this.P; h++)
                (p = this.A.i[h]).J.Ba(this.Nf),
                p.id.Ba(this.Qf)
        }
        ,
        je.prototype.Nl = function(h, p, _, g) {
            for (this.Tf = h,
            this.Vf = p,
            this.Xf = _,
            this.bg = g,
            h = 0; h < this.A.I.rc.length; h++)
                this.A.I.rc[h].Ba(this.Tf);
            for (h = 0; h < this.A.I.sc.length; h++)
                this.A.I.sc[h].Ba(this.Vf);
            for (h = 0; h < this.A.I.Tb.length; h++)
                this.A.I.Tb[h].Ba(this.Xf);
            for (h = 0; h < this.A.I.tc.length; h++)
                this.A.I.tc[h].Ba(this.bg)
        }
        ,
        je.prototype.va = function() {
            var h, p, _, g = 2 * this.vc, v = 2 * this.vc * 1.5;
            for (0 < this.P && (h = this.dc[0],
            p = this.dc[1],
            _ = this.dc[2],
            this.A.i[0].aa(h, p, g, v, _),
            this.A.I.aa(h, p, g, _)),
            h = 1; h < this.P; h++)
                this.A.i[h].aa(this.dc[3 * h], this.dc[3 * h + 1], g, v, this.dc[3 * h + 2])
        }
        ,
        je.prototype.Vl = function(h) {
            h.render({
                container: this.A.Aa
            })
        }
        ,
        je),
        T.ha = (yt.prototype.m = function() {}
        ,
        yt.prototype.Wa = function() {}
        ,
        yt.prototype.V = function() {}
        ,
        yt.prototype.Td = function() {}
        ,
        yt.prototype.ea = function() {}
        ,
        yt.prototype.Ha = function() {}
        ,
        yt),
        T.Lj = ( () => {
            let h = D(o("374d0b99cc16fac16c132ec0a6"))
              , p = D(o("b34ac7c3441d55de960ec8da4b1f2fc1"))
              , _ = D(o("fb828a8f0bd3e9df62d0"))
              , g = D(o("7f95b3c171d17683ebcca48d6ac86e96a2a1f5"))
              , v = D(o("f46004f48fb37d24a8224e"))
              , P = D(o("13e12735e5adea7f77b8307ef3b1d83f42b3447fc9"))
              , w = D(o("2216d60654d29bcc464fc15e41d184a85c3691"))
              , R = D(o("e5f355ab0ebb86f9a2a80ad2"))
              , G = D(o("039137c5e6c8f9"))
              , C = D(o("2216d60651cdc5da4f5598585c929cae53279137"))
              , X = null;
            var H = D(o("81d731876297eaddca9b65ca6c8d"))
              , ee = z.Z(T.ha, function() {
                T.ha.call(this, T.gb.nc);
                var q = this;
                W(P, o("1565fba1fa61"), () => {
                    qe.Ac(1)
                }
                ),
                W(g, o("685ac6d20fd6"), () => {
                    X && X()
                }
                ),
                W(w, o("adfd430952c9"), async () => {
                    F.w.g.Fa(F.w.g.xa),
                    ue(R, o("baa40ca8d0")),
                    ue(C, o("8838a9afe5abab")),
                    ue(G, o("3ce410222770eff6"));
                    try {
                        var I = await (await ve[o("b46393f3dbe1")](o("4276361327a761fc781d603229b67ec46025") + k["1ak"])).json()
                          , K = I[o("6a1843190b")];
                        K === 200 ? await F.w.L.yc(I[o("7aef5df91f")]) : K === 201 && ve.location.reload()
                    } catch {}
                }
                ),
                qe.rh = () => {
                    U.pd = !U.pd
                }
                ,
                qe.Wf = () => {
                    var I, K = F.w.h.W, te = k["1ag"];
                    te.length && K.qa && (I = te.indexOf(K.G.hb),
                    K.qa.wm(I === -1 ? te[0] : te[(I + 1) % te.length]))
                }
                ,
                qe.Em = () => {
                    var I, K = F.w.h.W, te = k["1ah"][o("4a336d293d")];
                    te && te.length && (I = te.indexOf(K.G.Uc),
                    K.qa.um(I === -1 ? te[0] : te[(I + 1) % te.length]))
                }
                ,
                qe.Ac = I => {
                    (I || U.r || li % 6 != 0) && To && To(U.ng, U.$)
                }
                ,
                qe.Bl = () => {
                    Ei(1)
                }
                ,
                qe.qh = () => {
                    var I, K;
                    U.r && (I = Object.keys(ar)).length && (K = I.indexOf(k["1b"]),
                    k["1b"] = K === -1 ? I[0] : I[(K + 1) % I.length],
                    U.Ng())
                }
                ,
                qe.Mi = () => {
                    U.r && (U.Ff = !0,
                    k["1af"]) && (yo.pause(),
                    yo.play())
                }
                ;
                let V = [ki, Gr];
                W(ve, o("9fbbc46b47bb5278"), I => {
                    I.target.type !== o("ebe888a61b") && I.code === o("7496c6261b2c") && (q.tb = !0)
                }
                ),
                W(ve, o("3228913c43b7"), I => {
                    I.target.type !== o("c46163efbc") && ((I = I.code) === o("3cc61b7611") ? qe.rh() : I === o("df5b842b25") ? qe.Wf() : I === o("5a20791416") ? qe.Mi() : I === o("1268b15c51") ? qe.Em() : I === o("9822bf92ce") ? qe.Ac() : I === o("b32fd0df6d") ? qe.Bl() : I === o("92e831dcd5") ? qe.qh() : I === o("d9013e7517") ? U.nd = !U.nd : I === o("ae741538fe") ? U.ee = !U.ee : I === o("eab0c984a0") ? (F.w.g.v.D.la.Ob = !F.w.g.v.D.la.Ob,
                    F.w.g.v.D.Ya.visible = F.w.g.v.D.la.Ob,
                    F.w.g.v.D.la.va(F.w.g.v.D.la.Ab)) : I === o("89b47ed17d9feb81f566") ? Ei(U.Ib + k["1i"]) : I === o("c5f8321539dbaf2fb8dc3bf230a1a7") ? Ei(U.Ib - k["1i"]) : I === o("8f93e16370a1") && (q.tb = !1))
                }
                ),
                H.addEventListener(o("c78fa15f2e90"), I => {
                    I.deltaY < 0 ? Ei(U.Ib + k["1i"]) : Ei(U.Ib - k["1i"])
                }
                , {
                    capture: !0,
                    passive: !0
                }),
                H.addEventListener(o("7035ddb617addb280e2c"), function(I) {
                    var K, te;
                    I && k["1f"] === 0 && !U.pd && (I = I.touches[0],
                    K = .5 * H.offsetWidth,
                    te = .5 * H.offsetHeight,
                    o("5533b96cbc2c3262382a") != typeof I.clientX ? q.Jb = Math.atan2(I.clientY - te, I.clientX - K) : q.Jb = Math.atan2(I.pageY - te, I.pageX - K),
                    I = Math.min(Math.sqrt((K - I.pageX) * (K - I.pageX) + (te - I.pageY) * (te - I.pageY)), 110),
                    dt.position.x = K + I * Math.cos(q.Jb),
                    dt.position.y = te + I * Math.sin(q.Jb))
                }, {
                    capture: !0,
                    passive: !0
                }),
                H.addEventListener(o("3a3f93385da773a5232170"), function(I) {
                    I.preventDefault(),
                    k["1f"] !== 2 && k["1f"] !== 3 && I && (q.tb = 2 <= I.touches.length)
                }, !0),
                H.addEventListener(o("4d4aa075b22a366a31"), function(I) {
                    k["1f"] !== 2 && k["1f"] !== 3 && I && (q.tb = 2 <= I.touches.length)
                }, {
                    capture: !0,
                    passive: !0
                }),
                H.addEventListener(o("49d7a409bedb22ef27a7"), function(I) {
                    !I || U.pd || I.shiftKey || (q.Jb = Math.atan2(I.clientY - .5 * H.offsetHeight, I.clientX - .5 * H.offsetWidth))
                }, !0),
                H.addEventListener(o("407cede637f0e2783f77"), function() {
                    q.tb = !0
                }, !0),
                H.addEventListener(o("9c80b11ad3149783"), function() {
                    q.tb = !1
                }, !0),
                H.addEventListener(o("1edf8fd84c4781474bd89edc"), function(I) {
                    var K, te;
                    Ir && I.pointerId === r1 ? (Ir.Of = !0,
                    Ir.parent[o("141139ab778a3b07")]({
                        x: I.clientX,
                        y: I.clientY
                    }, null, Ir.position)) : ti && (ii && I.pointerId === Hh && (K = ii.height / 2,
                    te = Math.max(K, Math.min(ii.parent[o("850268746619ea50")]({
                        x: I.clientX,
                        y: I.clientY
                    }).y, ii.parent.height - K)),
                    ii.parent.ij((ii.parent.height - ii.height - (te - K)) / (ii.parent.height - ii.height), 1)),
                    oe.nf || I.pointerId !== oe.Xa || oe.Qm(I))
                }, {
                    capture: !0,
                    passive: !0
                }),
                H.addEventListener(o("ef509e0b1d5010148258"), function(I) {
                    Ir = null,
                    ti && (ii = null,
                    Hh = -1,
                    dt.Xa === I.pointerId && (dt.Xa = -1,
                    dt.alpha = .25),
                    oe.nf || I.pointerId !== oe.Xa || (oe.visible = oe.cg,
                    oe.Pm(),
                    oe.Xa = -1))
                }, {
                    capture: !0,
                    passive: !0
                }),
                ti && (U.Rf = q,
                H.addEventListener(o("ec4d41d69eb55731902a41a9"), function(I) {
                    if (dt.Xa === -1 && (dt.Xa = I.pointerId,
                    dt.alpha = 1),
                    !oe.nf) {
                        for (var K of V)
                            if (I.clientX >= K.x && I.clientX <= K.x + K.width && I.clientY >= K.y && I.clientY <= K.y + K.height)
                                return;
                        oe.pt || oe.Xa !== -1 || (oe.Xa = I.pointerId,
                        oe.x = I.clientX,
                        oe.y = I.clientY,
                        oe.visible = !0,
                        oe.Fi())
                    }
                }, {
                    capture: !0,
                    passive: !0
                }))
            });
            ee.prototype.m = function() {}
            ,
            ee.prototype.Wa = function() {
                var q = D(o("5fb553e184f588b328ee0ca8"))
                  , V = D(o("4fa563f1b2f4a5"))
                  , I = D(o("56c22ada2d11310e3b815494105e481a07934d8b"));
                ue(V, o("9b25eea3733f40f6ca3ac2")),
                ue(I, o("0272a7616fe1ad")),
                ae(V, o("455fa9d5ae5b2699")),
                this.ka === me.Ud && ue(q, o("ab33ddfb41"))
            }
            ;
            let de = !(ee.prototype.Ud = function() {
                return this.ka = me.Ud,
                this
            }
            );
            ee.prototype.$e = function() {
                return Ht( () => {
                    if (this.ka === me.$e && (ae(R, o("e777993f05")),
                    !U.r) && !de) {
                        de = !0;
                        try {
                            (ve[o("f58713db1b939cc3928913d5")] || []).push({})
                        } catch {}
                    }
                }
                , 3e3),
                this.ka = me.$e,
                this
            }
            ,
            ee.prototype.V = function() {
                this.tb = !1,
                this.D.ea()
            }
            ,
            ee.prototype.rl = function() {
                ue(R, o("a7b7d97f45"))
            }
            ,
            ee.prototype.ea = function() {
                this.D.ea()
            }
            ,
            ee.prototype.Ha = function(q, V) {
                this.D.Ha(q, V)
            }
            ,
            ee.prototype.Jm = function(q, V) {
                if (he(h, s1.format(q)),
                0 <= V && V <= 10 ? ae(v, o("6539977d87")) : ue(v, o("af8fc1475d")),
                he(v, o("c0c54d43e12736") + V),
                !U.r && li % 6 == 0)
                    try {
                        jh({
                            [o("8025bba3e1")]: o("c2a1e1a2a725ec"),
                            [o("172678e7fe")]: o("67ea0cad8aee89f30ccf1f969aca8083"),
                            [o("9e4d0557cdc101e7c340094bce")]: I => {
                                X = () => {
                                    I()
                                }
                                ,
                                _[o("8022b6aae8b0")][o("a4918f04d8158b82")] = o("cdd823e529"),
                                p[o("d9392f75312b")][o("42376d2636bb69a0")] = o("637a0a3882")
                            }
                            ,
                            [o("980bbf8df39fbb2ec4")]: () => {
                                _[o("2082160a4810")][o("9c89b71cd01d838a")] = o("31c4df01cd"),
                                p[o("84a6b22ee43c")][o("a97e42af5d72ce99")] = o("932afae872")
                            }
                            ,
                            [o("08b82e1f652e23b663923707")]: () => {
                                li % 6 == 0 && (li += 1),
                                p[o("e121176d0933")][o("9e4b0942d2df05cc")] = o("b94c578945"),
                                _[o("719187dd9983")][o("26d381ca5a578d44")] = o("21fccc3ac0")
                            }
                            ,
                            [o("5b6d3918b675963707")]: () => {
                                li % 6 == 0 && (li += 1),
                                p[o("7cbeca36ec34")][o("c1562a87355aa681")] = o("dda833f519"),
                                _[o("d5b523f135af")][o("d0c57b50a44977de")] = o("3b825240da")
                            }
                            ,
                            [o("718395d0909436cc")]: () => {
                                li % 6 == 0 && (li += 1),
                                p[o("b47682fed4ec")][o("d4417fd4a8c57b52")] = o("289f061e54"),
                                _[o("8e6c2458fec6")][o("f6e3d1fa8a67dd74")] = o("51acbceab0")
                            }
                        })
                    } catch {}
            }
            ,
            ee.prototype.init = async function() {
                this.D = new T.Ym,
                await this.D.init(H),
                this.ka = me.Ud,
                this.Jb = 0,
                this.tb = !1
            }
            ;
            var me = {
                Ud: 0,
                $e: 1
            };
            return ee
        }
        )(),
        T.Tl = ( () => {
            let h = D(o("c0b43020b36f6ffb8ef06677"))
              , p = D(o("4276366631ad61b51a3878"))
              , _ = D(o("9a8e6e9eff5f10"))
              , g = D(o("0b993fcdf8babc6176aa6163e5e5f5657aa8787c"))
              , v = z.Z(T.ha, function() {
                T.ha.call(this, T.gb.nc),
                this.Gg = -1,
                this.$d = ""
            });
            return v.prototype.m = function() {}
            ,
            v.prototype.Wa = function() {
                ae(_, o("d5af24a535a5bae8b4a038")),
                ae(g, o("e45445c381cf4f"))
            }
            ,
            v.prototype.V = function() {}
            ,
            v.prototype.Td = function() {}
            ,
            v.prototype.to = function(P, w) {
                this.$d !== P && (this.$d = P),
                P = z.Ic(Math.floor(100 * w), 0, 100),
                this.Gg !== P && (h && (h[o("b0f2867ad860")][o("5531be6cad22")] = P + "%"),
                p) && (p[o("ee0bd5f98640db6b82e2d6fd")] = P + "%")
            }
            ,
            v
        }
        )(),
        T.Sj = ( () => {
            let h = D(o("047074e47fa323374a3422b3"))
              , p = D(o("62561646118d41953a1858"))
              , _ = D(o("57a62eb0b2e0f0ac3ee2"))
              , g = D(o("3a6ece7e5fbf70"))
              , v = D(o("2c585ccc477b5fe051eb02624a2416e45de91b7d"))
              , P = D(o("4bd97f0dbc6bb82c7e742723a125ba2b357a3c3d"))
              , w = D(o("4d10a76fbc277e773e2fb97bf4243e7429"))
              , R = D(o("d16c3b6b3823fa7bb223357f703ead7597"))
              , G = D(o("7867caa71db49328e13ca7fee6a1a8"))
              , C = D(o("887cf8e8fba7bd1cff08bc90"));
            D(o("1523a5fbfe6b76a95278faa2"));
            var X = z.Z(T.ha, function() {
                T.ha.call(this, T.gb.bf)
            });
            return X.prototype.init = async function() {
                this.Gg = -1,
                this.$d = "",
                this.ed = new T.Pf,
                await this.ed.init(P),
                W(R, o("d8ca7642bf46"), () => {
                    F.w.l.ok()
                }
                ),
                W(w, o("44f6ea7e2b72"), () => {
                    F.w.l.Hm()
                }
                ),
                W(G, o("4397295fa493"), () => {
                    F.w.Jn()
                }
                ),
                this.Un()
            }
            ,
            X.prototype.m = function() {
                var H = this;
                F.w.L.ug(function() {
                    F.w.L.ma && (F.w.l.Pa(F.w.L.sl(), T.j.T, 1),
                    F.w.l.Pa(F.w.L.vl(), T.j.sa, 1),
                    F.w.l.Pa(F.w.L.nj(), T.j.Ca, 1),
                    F.w.l.Pa(F.w.L.zl(), T.j.Ea, 1),
                    F.w.l.Pa(F.w.L.Gl(), T.j.Da, 1))
                }),
                F.w.L.ug(function() {
                    he(C, F.w.L.Be())
                }),
                F.w.l.tg(function() {
                    H.ed.Nb(F.w.l.sg())
                })
            }
            ,
            X.prototype.Wa = function() {}
            ,
            X.prototype.dh = function() {
                ue(v, o("cabaefa9a729f5")),
                ue(g, o("d12b20293929b66cb0243c")),
                _[o("44e7e37a276fef")](),
                p[o("44e7e37a276fef")]()
            }
            ,
            X.prototype.to = function(H, ee) {
                this.$d !== H && (this.$d = H),
                H = z.Ic(Math.floor(100 * ee), 0, 100),
                this.Gg !== H && (h && (h[o("6cceda461c24")][o("9650314deec3")] = H + "%"),
                p) && (p[o("babf19b5ca0cef3fb6b6eaa1")] = H + "%")
            }
            ,
            X.prototype.V = function() {
                this.ed.$c(!0)
            }
            ,
            X.prototype.Td = function() {
                this.ed.$c(!1)
            }
            ,
            X.prototype.ea = function() {
                this.ed.ea()
            }
            ,
            X.prototype.Ha = function() {
                this.ed.Ha()
            }
            ,
            X.prototype.te = function() {
                return F.w.L.te()
            }
            ,
            X.prototype.ih = function() {
                return o("6070f0f62af4")
            }
            ,
            X.prototype.Un = function() {
                F.w.$g()
            }
            ,
            X
        }
        )(),
        T.om = ((ke = z.Z(T.ha, function() {
            T.ha.call(this, T.gb.nc)
        })).prototype.m = function() {}
        ,
        ke.prototype.Wa = function() {}
        ,
        ke),
        T.yl = ((ke = z.Z(T.ha, function() {
            T.ha.call(this, T.gb.nc)
        })).prototype.m = function() {}
        ,
        ke.prototype.Wa = function() {}
        ,
        ke.prototype.V = function() {}
        ,
        ke),
        T.Ml = ((ke = z.Z(T.ha, function() {
            T.ha.call(this, T.gb.nc),
            this.mh = [],
            this.ak = null
        })).prototype.m = function() {}
        ,
        ke.prototype.Wa = function() {}
        ,
        ke.prototype.V = function() {}
        ,
        ke.prototype.tn = function() {
            return this.ak != null || 0 < this.mh.length
        }
        ,
        ke.prototype.Ei = function(h) {
            this.mh.push(h),
            Ht(function() {
                F.w.g.Ri()
            }, 0)
        }
        ,
        ke),
        T.gb = {
            nc: 0,
            bf: 1
        },
        T.ga = ((m = z.Z(T.ha, function(h) {
            T.ha.call(this, T.gb.bf),
            this.$a = h,
            this.Jf = []
        })).prototype.m = function() {
            m.parent.prototype.m.call(this),
            m.Nk || (m.Nk = !0,
            F.w.L.ug(function() {}))
        }
        ,
        m.prototype.Wa = function() {}
        ,
        m.prototype.Cl = function() {
            var h = this
              , p = 2147483647 & z.Wl();
            return this.Jf.push(p),
            Ht(function() {
                h.Xh(p)
            }, 5e3),
            new wo(this,p)
        }
        ,
        m.prototype.Xh = function(h) {
            (h = this.Jf.indexOf(h)) < 0 || this.Jf.splice(h, 1)
        }
        ,
        m),
        ks.prototype.dp = function() {
            this.Ol.Xh(this.Ul)
        }
        ;
        var si, vt, Tt, ut, ft, Dt, kt, ke, wo = ks;
        function ks(h, p) {
            this.Ol = h,
            this.Ul = p
        }
        function Br() {}
        T.Ak = ((si = z.Z(T.ga, function() {
            T.ga.call(this, o("b2801bacd834"), !1)
        })).prototype.m = function() {
            si.parent.prototype.m.call(this)
        }
        ,
        si.prototype.V = function() {}
        ,
        si),
        T.Mk = ((vt = z.Z(T.ga, function() {
            T.ga.call(this, o("e47943d68cdc5848"), !0)
        })).prototype.m = function() {
            vt.parent.prototype.m.call(this)
        }
        ,
        vt.prototype.V = function() {}
        ,
        vt),
        T.bl = ((Tt = z.Z(T.ga, function() {
            T.ga.call(this, o("11cefc23fce8"), !1)
        })).prototype.m = function() {
            Tt.parent.prototype.m.call(this)
        }
        ,
        Tt.prototype.V = function() {}
        ,
        Tt),
        T.Vk = ((ut = z.Z(T.ga, function() {
            T.ga.call(this, o("33b44749d181d54f"), !0)
        })).prototype.m = function() {
            ut.parent.prototype.m.call(this)
        }
        ,
        ut.prototype.V = function() {}
        ,
        ut),
        T.dl = ((ft = z.Z(T.ga, function() {
            T.ga.call(this, o("69898ee899b701c702"), !1)
        })).prototype.m = function() {
            ft.parent.prototype.m.call(this)
        }
        ,
        ft.prototype.V = function() {}
        ,
        ft),
        T.ll = ( () => {
            let h = D(o("f226863681fdcbda9162d24e9fe1b6f071"))
              , p = D(o("baee4efec935f302a9baea96a723fb"))
              , _ = D(o("b7cd8b194c964e7dd499af62319133"))
              , g = D(o("649094041f43d9e807d4c0711539c6"))
              , v = D(o("a13711e7526cd48bc2734591486ace"))
              , P = D(o("ce7aa252a599e7b6bd0ef625b588f788ba"))
              , w = D(o("350385dbce5048bf5647d1b1a556"))
              , R = D(o("2bf91f2dd89ac271588d5b74d285d65c5e"))
              , G = D(o("89df398f7e95e6aebc6066bd7767e5"))
              , C = D(o("3bc90f1dc88ab261289d2b66b591aa5f"))
              , X = D(o("a4d0d444df0399a8c794803dc5f8"))
              , H = 0;
            var ee = z.Z(T.ga, function() {
                T.ga.call(this, o("23874e7fc9ab"), !0)
            })
              , de = (ee.prototype.init = async function() {
                var q = this;
                this.Wd = this.Lb = null,
                this.yb = [],
                this.Ni = {},
                this.Ia = new T.Pf,
                await this.Ia.init(h),
                W(X, o("75059b419a01"), () => {
                    q.nn()
                }
                ),
                W(_, o("21f1cf3dc6fd"), () => {
                    q.Lb.un()
                }
                ),
                W(g, o("cf63bd2b306f"), () => {
                    q.Lb.zn()
                }
                ),
                W(w, o("8fa3fd6b70af"), () => {
                    F.w.l.ua(H, T.j.T) && (ue(w, o("0113e040ec0062")),
                    ae(R, o("cb1daeca26f634")),
                    k["1ag"].includes(H) || k["1ag"].push(H),
                    ye())
                }
                ),
                W(R, o("cf63bd2b306f"), () => {
                    F.w.l.ua(H, T.j.T) && (k["1ag"] = k["1ag"].filter(V => V !== H),
                    ae(w, o("225287414fc18d")),
                    ue(R, o("9000b197fd93b3")),
                    ye())
                }
                )
            }
            ,
            ee.prototype.m = function() {
                ee.parent.prototype.m.call(this);
                var q = this;
                F.w.o.uf(function() {
                    var V = F.w.o.bb.Xb;
                    q.yb = [];
                    for (var I = 0; I < V[o("c582")].length; I++)
                        q.yb.push(new de(q,V[o("b91e")][I]));
                    for (q.Ni = {},
                    I = 0; I < V[o("4ceee5763e60e0d135dcd24e3b5d")].length; I++) {
                        var K = V[o("272b42f3c51ddfec4e1975cbd010")][I];
                        q.Ni[K[o("07516d")]] = K
                    }
                    q.aj()
                }),
                this.Mb(!1),
                F.w.l.tg(function() {
                    q.Mb(!1)
                })
            }
            ,
            ee.prototype.V = function() {
                this.aj(),
                this.Ia.$c(!0)
            }
            ,
            ee.prototype.Td = function() {
                this.Ia.$c(!1)
            }
            ,
            ee.prototype.ea = function() {
                this.Ia.ea()
            }
            ,
            ee.prototype.Ha = function() {
                this.Ia.Ha()
            }
            ,
            ee.prototype.aj = function() {
                if (this.Nj)
                    ue(this.Wd, o("b6261b3dd3bd19")),
                    ae(this.yb[0].Ld, o("0c3c2dab799737")),
                    this.Wd = this.yb[0].Ld;
                else {
                    this.Nj = !0;
                    for (var q = 0; q < this.yb.length; q++) {
                        let Fe = this.yb[q];
                        var V = Ui(o("4cfffb6b244efc"))
                          , I = Fe.Yb[o("1f62")];
                        I ? ((K = Ui(o("750f9a4f"))).src = I,
                        Li(V, K)) : he(V, Fe.Yb.name),
                        ae(V, o("44e2fc64656fe8ef22")),
                        W(V, o("ff536d1be05f"), () => {
                            this.Sg(Fe)
                        }
                        ),
                        p.append(V),
                        Fe.Ld = V
                    }
                    if (0 < this.yb.length) {
                        for (q = F.w.l.Oa(T.j.T),
                        V = 0; V < this.yb.length; V++)
                            for (var K = (I = this.yb[V]).Yb.list, te = 0; te < K.length; te++)
                                if (K[te] === q)
                                    return I.ac = te,
                                    void this.Sg(I);
                        this.Sg(this.yb[0])
                    }
                }
            }
            ,
            ee.prototype.Sg = function(q) {
                this.Lb !== q && (this.Lb = q,
                this.Wd && ue(this.Wd, o("69bb88e884a80a")),
                this.Lb.Ld && (ae(this.Lb.Ld, o("07596a0ee24ae8")),
                this.Wd = this.Lb.Ld),
                this.Mb(!0))
            }
            ,
            ee.prototype.fh = function() {
                return this.Lb == null ? T.$b.sf() : this.Lb.tf()
            }
            ,
            ee.prototype.nn = function() {
                var q = this.fh();
                q.wf() && this.Oj(q.Dc())
            }
            ,
            ee.prototype.Oj = function(q) {
                var V = F.w.l.df(q, T.j.T);
                if (V != null && (V = V.Kg,
                !(F.w.L.Be() < V))) {
                    let K = F.w.l.Oa(T.j.T)
                      , te = F.w.l.Oa(T.j.sa)
                      , Fe = F.w.l.Oa(T.j.Ca)
                      , pt = F.w.l.Oa(T.j.Ea)
                      , fe = F.w.l.Oa(T.j.Da);
                    var I = this.Cl();
                    F.w.L.bn(q, T.j.T, function() {
                        I.dp(),
                        F.w.g.Fa(F.w.g.Le)
                    }, function() {
                        F.w.L.Am(function() {
                            F.w.l.Pa(K, T.j.T),
                            F.w.l.Pa(te, T.j.sa),
                            F.w.l.Pa(Fe, T.j.Ca),
                            F.w.l.Pa(pt, T.j.Ea),
                            F.w.l.Pa(fe, T.j.Da),
                            F.w.l.Pa(q, T.j.T),
                            I.dp()
                        })
                    })
                }
            }
            ,
            ee.prototype.Mb = function(q) {
                var V, I = F.w.l.sg(), K = this.fh();
                K.wf() && (H = K.Dc(),
                K = F.w.l.df(H, T.j.T),
                V = !1,
                ue(w, o("9325f6f27e3e7c")),
                ue(R, o("0a7aaf6967e9b5")),
                F.w.l.ua(H, T.j.T) ? (ue(G, o("ce3ef315bb95f1")),
                ue(P, o("f58714dc109c9e")),
                k["1ag"].includes(H) ? ae(R, o("76665b7d13fd59")) : ae(w, o("4fe132b6baf2b0"))) : (V = !0,
                ae(P, o("24140583418f0f")),
                K && K.Id === 2 && (ae(G, o("d92b38783438ba")),
                he(C, K.Kg))),
                he(v, o("29d3ef799edf0a5201") + H),
                this.Ia.Nb(I.Uj(H)),
                this.Ia.$l(V),
                q) && F.w.l.Pa(H, T.j.T)
            }
            ,
            me.prototype.un = function() {
                --this.ac < 0 && (this.ac = this.Yb.list.length - 1),
                this.ne.Mb(!0)
            }
            ,
            me.prototype.zn = function() {
                ++this.ac >= this.Yb.list.length && (this.ac = 0),
                this.ne.Mb(!0)
            }
            ,
            me.prototype.tf = function() {
                return this.ac >= this.Yb.list.length ? T.$b.sf() : T.$b.kh(this.Yb.list[this.ac])
            }
            ,
            me);
            function me(q, V) {
                this.ne = q,
                this.ac = 0,
                this.Yb = V
            }
            return ee
        }
        )(),
        T.ql = function() {
            let h = D(o("c7ddfb093888224caa2da2293a6a26"))
              , p = D(o("2bf91f2ddc94de5056c94243d69aca"))
              , _ = D(o("a93f19ef5a64dccdc2495a8a46"))
              , g = D(o("a37197a550225ab7ca3fce"))
              , v = D(o("4cb8bc2c275be1f73dd1fa42"))
              , P = D(o("08f7392f632f2bf272953c"))
              , w = D(o("3bc90f1dc88ab21f30802a44a2"))
              , R = D(o("36e2cafa5927933e5be273a52d2161"))
              , G = D(o("b420c4b4cbe29365917d8ceab6bc6172aa6367e4"));
            W(R, o("6d3d83499209"), () => {
                ue(w, o("3b8d5e5ad686a4"))
            }
            ),
            W(P, o("74a6da2e1b22"), () => {
                F.w.g.kc.V(),
                ae(w, o("7e6e2365ebe521"))
            }
            ),
            W(G, o("0f237debf02f"), () => {
                F.w.g.kc.V(),
                ae(w, o("1bad7e7af6a6c4"))
            }
            ),
            W(h, o("4555ab91aa51"), () => {
                ae(_, o("3eae63a52b2561")),
                ae(h, o("7b4d1e1a964664")),
                ue(g, o("6a1a4f09078955")),
                ue(p, o("d5a734fc30bcbe")),
                he(v, o("49e9bf13bfdb6ab261e796b6f0fe67ad60fefebeed9d34f90fa1"))
            }
            ),
            W(p, o("4555ab91aa51"), () => {
                ae(p, o("b0e09177dd7393")),
                ae(g, o("c0f06167ad6363")),
                ue(_, o("b6261b3dd3bd19")),
                ue(h, o("d5a734fc30bcbe")),
                he(v, o("a2e010dad4524d0b9a9e298f8b0740648bf751f786061b2adfb80fa2cc26e522")),
                F.w.g.kc.V()
            }
            )
        }
        ,
        T.ul = ( () => {
            let h = D(o("b420c4b4cff3894adf6ebdeeaee76360"))
              , p = D(o("8553350b7a0ee44ee8536a3974f1"))
              , _ = D(o("0f6523b1e030faf4726574e5ee38f5"))
              , g = D(o("7543c51b8a1e145e1843985c6001f051f6"))
              , v = D(o("1a0eee1e6ddb8fc3471e8c5452"))
              , P = D(o("0a3efe2e79e5a3e071409a406ed3"))
              , w = D(o("9a8e6e9ee9551370c1d034c7c341"))
              , R = D(o("fa2e8e3e89f5b3d06170897072f6"))
              , G = D(o("97edab397aaf7e23fda5d87042a6"))
              , C = D(o("ec181c8c87bb4102972666b591aa5f"))
              , X = D(o("c672ba6abda1ff9cad3cdc0eb188f181"))
              , H = D(o("245054c45f83193a4f1e2f9b54"))
              , ee = D(o("52462656219d6ba839084e0833805694"))
              , de = 0;
            var me = z.Z(T.ga, function() {
                T.ga.call(this, o("6fe31d8d87cc9c8810"), !0)
            })
              , q = (me.prototype.init = async function() {
                var I = this
                  , K = this;
                this.Cc = [],
                this.sa = new q(this,T.j.sa,p),
                this.Ca = new q(this,T.j.Ca,_),
                this.Ea = new q(this,T.j.Ea,g),
                this.Da = new q(this,T.j.Da,v),
                this.Hk = this.Gf = this.Ef = this.Df = this.Bf = this.Bb = null,
                this.Ia = new T.Pf,
                await this.Ia.init(h),
                W(p, o("0919e755ee15"), () => {
                    K.ud(I.sa)
                }
                ),
                W(_, o("1ecc8cd84158"), () => {
                    K.ud(I.Ca)
                }
                ),
                W(g, o("84b6aa3eeb32"), () => {
                    K.ud(I.Ea)
                }
                ),
                W(v, o("51a1bfedb6ad"), () => {
                    K.ud(I.Da)
                }
                ),
                W(P, o("00b22e3a673e"), () => {
                    K.Bb.Wk()
                }
                ),
                W(w, o("f90917451e05"), () => {
                    K.Bb.Rk()
                }
                ),
                W(H, o("0c3e22b6738a"), () => {
                    de && F.w.l.ua(de.H, de.X) && (ue(H, o("dbedbeba36e604")),
                    ae(ee, o("3b8d5e5ad686a4")),
                    k["1ah"][de.X].includes(de.H) || k["1ah"][de.X].push(de.H),
                    ye())
                }
                ),
                W(ee, o("e5b50bf10ab1"), () => {
                    de && F.w.l.ua(de.H, de.X) && (k["1ah"][de.X] = k["1ah"][de.X].filter(te => te !== de.H),
                    ae(H, o("225287414fc18d")),
                    ue(ee, o("c2b2e7a1af21ed")),
                    ye())
                }
                ),
                this.Cc.push(this.sa),
                this.Cc.push(this.Ca),
                this.Cc.push(this.Ea),
                this.Cc.push(this.Da)
            }
            ,
            me.prototype.m = function() {
                me.parent.prototype.m.call(this);
                let I = this;
                F.w.o.uf(function() {
                    var K = F.w.o.bb.Xb;
                    I.Bf = K[o("adfb560542e6da07c1")],
                    I.Df = K[o("b2ae1bb0c22f0b0dd3a808")],
                    I.Ef = K[o("1d69f3b1d26146a7617fc4ac")],
                    I.Gf = K[o("cc756feba3e57b40a0")],
                    I.Hk = K[o("177a")],
                    I.sa.ve(Object.keys(I.Bf).map(te => parseInt(te))),
                    I.sa.xe(I.Bf),
                    I.Ca.ve(Object.keys(I.Df).map(te => parseInt(te))),
                    I.Ca.xe(I.Df),
                    I.Ea.ve(Object.keys(I.Ef).map(te => parseInt(te))),
                    I.Ea.xe(I.Ef),
                    I.Da.ve(Object.keys(I.Gf).map(te => parseInt(te))),
                    I.Da.xe(I.Gf)
                }),
                this.Mb(!1),
                F.w.l.tg(function() {
                    I.Mb(!1)
                })
            }
            ,
            me.prototype.V = function() {
                this.ud(this.Bb ?? this.sa),
                this.Ia.$c(!0)
            }
            ,
            me.prototype.Td = function() {
                this.Ia.$c(!1)
            }
            ,
            me.prototype.ea = function() {
                this.Ia.ea()
            }
            ,
            me.prototype.Ha = function() {
                this.Ia.Ha()
            }
            ,
            me.prototype.ud = function(I) {
                for (this.Bb = I,
                I = 0; I < this.Cc.length; I++)
                    ue(this.Cc[I].pi, o("cabaefa9a729f5"));
                ae(this.Bb.pi, o("0597e4cce08c6e")),
                this.Bb.Wa()
            }
            ,
            me.prototype.il = function() {
                return this.Bb == null ? T.$b.sf() : T.$b.kh({
                    H: this.Bb.tf(),
                    X: this.Bb.X
                })
            }
            ,
            me.prototype.Mb = function(I) {
                var K = F.w.l.sg()
                  , te = this.il();
                if (te.wf()) {
                    de = te = te.Dc();
                    var Fe = F.w.l.df(te.H, te.X)
                      , pt = !1;
                    switch (ue(H, o("621247010f814d")),
                    ue(ee, o("108031177d1333")),
                    F.w.l.ua(te.H, te.X) ? (ue(G, o("33855652de9edc")),
                    ue(X, o("637506228e6e8c")),
                    k["1ah"][te.X] || (k["1ah"][te.X] = []),
                    k["1ah"][de.X].includes(de.H) ? ae(ee, o("a4948503c10f8f")) : ae(H, o("4fe132b6baf2b0"))) : (pt = !0,
                    ae(X, o("e616cb0d838dc9")),
                    Fe && Fe.Id === 2 && (ae(G, o("ea9acf898709d5")),
                    he(C, Fe.Kg))),
                    he(R, o("1b85592bac91842013") + te.H),
                    Fe = this.Ia,
                    te.X) {
                    case T.j.sa:
                        Fe.Nb(K.$j(te.H)),
                        Fe.hm(pt);
                        break;
                    case T.j.Ca:
                        Fe.Nb(K.hk(te.H)),
                        Fe.lm(pt);
                        break;
                    case T.j.Ea:
                        Fe.Nb(K.sk(te.H)),
                        Fe.vm(pt);
                        break;
                    case T.j.Da:
                        Fe.Nb(K.nk(te.H)),
                        Fe.qm(pt)
                    }
                    I && F.w.l.Pa(te.H, te.X)
                }
            }
            ,
            V.prototype.ve = function(I) {
                this.ab = I.map(K => [K])
            }
            ,
            V.prototype.xe = function(I) {
                this.xf = I
            }
            ,
            V.prototype.Wa = function() {
                for (var I = F.w.l.Oa(this.X), K = 0; K < this.ab.length; K++)
                    for (var te = 0; te < this.ab[K].length; te++)
                        if (this.ab[K][te] === I)
                            return this.He(K),
                            void this.ge(te);
                this.He(0),
                this.ge(0)
            }
            ,
            V.prototype.Rk = function() {
                let I = this.zd - 1;
                I < 0 && (I = this.ab.length - 1),
                this.He(I),
                this.ge(this.Fe % this.ab[I].length)
            }
            ,
            V.prototype.Wk = function() {
                let I = this.zd + 1;
                I >= this.ab.length && (I = 0),
                this.He(I),
                this.ge(this.Fe % this.ab[I].length)
            }
            ,
            V.prototype.He = function(I) {
                I < 0 || I >= this.ab.length || (this.zd = I)
            }
            ,
            V.prototype.ge = function(I) {
                I < 0 || I >= this.ab[this.zd].length || (this.Fe = I,
                this.ne.Mb(!0))
            }
            ,
            V.prototype.tf = function() {
                return this.ab[this.zd][this.Fe]
            }
            ,
            V);
            function V(I, K, te) {
                this.ne = I,
                this.X = K,
                this.pi = te,
                this.xf = {},
                this.ab = [[]],
                this.Fe = this.zd = -10
            }
            return me
        }
        )(),
        T.fk = ((Dt = z.Z(T.ga, function() {
            T.ga.call(this, o("2f3758d6db00c7c7404d0b9af803d3dd5a1e35"), !1)
        })).prototype.m = function() {
            Dt.parent.prototype.m.call(this)
        }
        ,
        Dt.prototype.V = function() {}
        ,
        Dt),
        T.qk = ((kt = z.Z(T.ga, function() {
            T.ga.call(this, o("cdff2ce33eb7bdf0f0f467ec3ca6bef8b4a131"), !1)
        })).prototype.m = function() {
            kt.parent.prototype.m.call(this)
        }
        ,
        kt.prototype.V = function() {}
        ,
        kt.prototype.dq = function() {}
        ,
        kt),
        T.Yc = (Br.prototype.V = function() {}
        ,
        Br),
        T.Zm = ((ke = z.Z(T.Yc, function() {
            T.Yc.call(this)
        })).prototype.V = function() {
            F.w.Ze.zo()
        }
        ,
        ke),
        T.Vm = ((ke = z.Z(T.Yc, function() {
            T.Yc.call(this)
        })).prototype.V = function() {
            F.w.Ze.yo()
        }
        ,
        ke),
        T.ro = ((ke = z.Z(T.Yc, function() {
            T.Yc.call(this)
        })).prototype.V = function() {
            Ht(function() {}, 0)
        }
        ,
        ke),
        T.Zl = ((ke = z.Z(T.ha, function() {
            T.ha.call(this, T.gb.nc)
        })).prototype.m = function() {}
        ,
        ke.prototype.Wa = function() {}
        ,
        ke.prototype.V = function() {}
        ,
        ke),
        T.gm = ( () => {
            let h = D(o("2f450391c41ef0d4453a5cdec915"))
              , p = D(o("28dc58485b07439a42731df1"))
              , _ = D(o("edfb5d9316839ec1ba9012da"))
              , g = D(o("9dab2d6340e2d3"))
              , v = D(o("253395ebde6006bf4870db85c30f5f8b5442d29a"))
              , P = z.Z(T.ha, function() {
                T.ha.call(this, T.gb.nc),
                h[o("b0ee9c60d86c95ec")] = () => {
                    ue(p, o("a658185cc4")),
                    ue(_, o("79858bc993")),
                    ue(v, o("19ebf838f4f87a")),
                    ue(g, o("82fa37b8ea78297de3f52b")),
                    F.w.g.Fa(F.w.g.xa)
                }
            });
            return P.prototype.$m = () => {
                ue(p, o("cc727efabe"))
            }
            ,
            P.prototype.m = function() {}
            ,
            P.prototype.Wa = function() {
                ue(g, o("a65e0614cdda01d8")),
                ae(v, o("bf91a2462a8220")),
                ae(g, o("996368e17161feb4c87c44")),
                ae(p, o("af8fc1475d"))
            }
            ,
            P.prototype.V = function() {}
            ,
            P
        }
        )(),
        z.sm = function() {
            return (h = {
                ui: !1
            }).yi = z.Ve(),
            h.bd = 0,
            h.Fg = 0,
            h.Ho = null,
            h.h = null,
            h.o = null,
            h.Fd = null,
            h.Ze = null,
            h.g = null,
            h.l = null,
            h.L = null,
            h.m = async function() {
                h.h = new T.dn,
                h.h.be = new T.Gn(h.h),
                h.o = new T.La,
                await h.o.init(),
                h.Fd = new T.vj,
                await h.Fd.init(),
                h.Ze = new T.yk,
                h.g = new T.Bj,
                await h.g.init(),
                h.l = new T.pl,
                h.L = new T.En,
                h.h.Vi = function() {
                    h.g.Fa(h.g.Oe)
                }
                ,
                h.h.Yi = function() {
                    h.g.xa.ih(),
                    h.g.Fa(h.g.v.Ud())
                }
                ,
                h.h.$i = function() {
                    h.o.Ai(null, null, null),
                    h.Kn(Math.floor(h.h.W.Kb), h.h.ff)
                }
                ,
                h.h.ej = function(p) {
                    p(h.g.v.Jb, h.g.v.tb)
                }
                ,
                h.L.pm(function() {
                    var p = h.g.xn();
                    p != null && p.X === T.gb.bf && h.g.Fa(h.g.xa),
                    h.L.ma && h.L.Mf(),
                    h.hj()
                }),
                h.h.m(),
                h.g.m(),
                h.l.m(),
                h.o.m(),
                h.g.Fa(h.g.xa),
                h.Fd.m(function() {
                    h.Ze.m(),
                    h.L.m(),
                    h.o.Ai(function() {
                        h.g.xa.dh(),
                        h.g.Fa(h.g.xa)
                    }, function() {
                        h.g.xa.dh(),
                        h.g.Fa(h.g.Le)
                    }, function(p, _) {
                        h.g.Kf.to(p, _),
                        h.g.xa.to(p, _)
                    }),
                    h.hj()
                })
            }
            ,
            h.Yn = function() {}
            ,
            h.Jn = function() {
                h.gh()
            }
            ,
            h.gh = function(p, _) {
                var g;
                Ei(1),
                U.k && (U.k.d = performance.now()),
                Di.Wg(),
                h.h.Ij() && (h.g.Fa(h.g.Kf),
                g = h.g.xa.ih(),
                T.na.wd(T.na.Dk, g),
                T.na.wd(T.na.kk, !0),
                h.L.ma ? (U.$ = _,
                h.Pj(p)) : (p = h.g.xa.te(),
                T.na.wd(T.na.Kk, p),
                T.na.wd(T.na.xh, h.l.Oa(T.j.T))))
            }
            ,
            To = function(p, _) {
                h.gh(p, _)
            }
            ,
            h.Pj = async function(p=null) {
                U.Dg && new Date > U.Dg && (k["1ak"] = 0,
                ye(),
                ve.location.reload()),
                li % 6 != 0 && (li += 1),
                h.g.Oe.$m(),
                h.g.v.rl();
                var _ = k["1ak"]
                  , g = h.l.Oa(T.j.T)
                  , v = h.l.Oa(T.j.sa)
                  , P = h.l.Oa(T.j.Ca)
                  , w = h.l.Oa(T.j.Ea)
                  , R = h.l.Oa(T.j.Da)
                  , G = (U.Ah(0),
                U.Rh(0),
                new FormData);
                G.append(o("d45179ccbdc7"), k["1ak"]);
                try {
                    var C, X, H = await (await ve[o("bc6b9bfba3f9")](o("d16761423436be2deb0c28783c3cab4f86330e714064a13dda1c1d395e1a") + 1, {
                        [o("504cf7d73ccaf2")]: o("0889050858"),
                        [o("c635e73db3")]: G
                    })).json();
                    H[o("bf93ae5626")] === 200 && (U.ng = p || H[o("e76d9b36")],
                    H[o("a641")] === 1 ? (p && U.$ || (U.$ = H[o("486d")]),
                    h.h.bk(U.ng, _, g, v, P, w, R)) : (C = D(o("afc583114694510bda87dd4b57c14a5cde80b15731"))) && (ae(C, o("ac929e1ade")),
                    X = D(o("18cc68587b0c338a6f870701"))) && ue(X, o("8af43cf8e0")))
                } catch {
                    h.g.Fa(h.g.Oe)
                }
            }
            ,
            h.ao = function() {}
            ,
            h.Kn = function(p, _) {
                h.g.xa.te(),
                h.g.v.Jm(p, _),
                h.g.Fa(h.g.v.$e())
            }
            ,
            h.Xn = function() {
                var p;
                return h.$g() && (p = parseInt(T.na.ag(T.na.xh))) != null && h.l.ua(p, T.j.T) ? p : h.l.xi()
            }
            ,
            h.$n = function(p) {
                T.na.wd(T.na.Ch, o(p ? "ee0bc2f497" : "883fabb7ffb8"))
            }
            ,
            h.$g = function() {
                return T.na.ag(T.na.Ch) === o("6360172382")
            }
            ,
            h.hj = function() {
                h.ui !== !0 && (h.ui = !0,
                o("c317aad8341d27ceae18"),
                o("13a37176e58bf66468a9737a"))
            }
            ,
            h.el = function() {
                return T.na.ag(T.na.dk) === o("b6330a3cdf")
            }
            ,
            h.Go = function() {
                return !1
            }
            ,
            h.Ha = function() {
                h.bd = z.Ve(),
                h.Fg = h.bd - h.yi,
                h.h.Cd(h.bd, h.Fg),
                h.g.Cd(h.bd, h.Fg),
                h.yi = h.bd
            }
            ,
            h.ea = function() {
                h.g.ea()
            }
            ,
            h;
            var h
        }
        ,
        T.dn = function() {
            o("76724b6c5fb90cfe0a7d2972f6");
            var h = {
                Ik: 30,
                ec: new Float32Array(100),
                yh: 0,
                sd: 0,
                vd: 0,
                jc: 0,
                Mc: 0,
                jl: 0,
                ka: 0,
                ja: null,
                Wi: 300,
                vi: 0,
                Yi: function() {},
                $i: function() {},
                ej: function() {},
                Vi: function() {},
                C: new T.Zc,
                be: null,
                W: null,
                Vb: {},
                xb: {},
                Bi: 12.5,
                Kc: 40,
                Ad: 1,
                Qh: -1,
                Sh: 1,
                Ug: 1,
                Yh: -1,
                ai: -1,
                bi: 1,
                fi: 1,
                ii: -1,
                ff: 500,
                si: 500
            };
            return h.C.lh = 500,
            h.W = new T.Ee(h.C),
            h.m = function() {
                h.W.ei(F.w.g.v.D),
                setInterval(function() {
                    h.ej(function(p, _) {
                        h.fr(p, _)
                    })
                }, 20)
            }
            ,
            h.gl = function(p, _, g, v) {
                h.Qh = p,
                h.Sh = _,
                h.Ug = g,
                h.Yh = v,
                h.li()
            }
            ,
            h.nm = function(p) {
                h.Ad = p,
                h.li()
            }
            ,
            h.li = function() {
                h.ai = h.Qh - h.Ad,
                h.bi = h.Sh + h.Ad,
                h.fi = h.Ug - h.Ad,
                h.ii = h.Yh + h.Ad
            }
            ,
            h.Cd = function(p, _) {
                h.vd += _,
                h.sd -= .2 * h.yh * _,
                h.be.zj(),
                h.ja == null || h.ka !== 2 && h.ka !== 3 || (h.tm(p, _),
                h.Kc = 4 + h.Bi * h.W.kb),
                p = 1e3 / Math.max(1, _);
                for (var g = _ = 0; g < h.ec.length - 1; g++)
                    _ += h.ec[g],
                    h.ec[g] = h.ec[g + 1];
                h.ec[h.ec.length - 1] = p,
                h.Ik = (_ + p) / h.ec.length
            }
            ,
            h.Ue = function(p, _) {
                return h.ai < p && p < h.bi && h.fi < _ && _ < h.ii
            }
            ,
            h.tm = function(p, _) {
                var g, v, P = (h.vd + h.sd - h.jc) / (h.Mc - h.jc), w = (h.W.we(p, _),
                h.W.Ae(p, _, P, h.Ue),
                0);
                for (g in h.xb) {
                    var R = h.xb[g];
                    R.we(p, _),
                    R.Ae(p, _, P, h.Ue),
                    R.eb && R.kb > w && (w = R.kb),
                    R.oc || !(R.Ma < .005) && R.eb || (R.Hd(),
                    delete h.xb[R.G.H])
                }
                for (v in h.nm(3 * w),
                h.Vb)
                    P = h.Vb[v],
                    P.we(p, _),
                    P.Ae(p, _, h.Ue),
                    P.Lg && (P.Ma < .005 || !h.Ue(P.Af, P.Cf)) && (P.Hd(),
                    delete h.Vb[P.G.H])
            }
            ,
            h.ol = function(p, _) {
                h.ka === 1 && (h.ka = 2,
                h.Yi());
                var g = F.w.bd;
                (h.jl = p) === 0 ? (h.jc = g - 95,
                h.Mc = g,
                h.vd = h.jc,
                h.sd = 0) : (h.jc = h.Mc,
                h.Mc += _),
                h.yh = (h.vd + h.sd - h.jc) / (h.Mc - h.jc)
            }
            ,
            h.Pn = function() {
                var p;
                h.ka !== 1 && h.ka !== 2 || (h.ka = 3,
                p = h.ja,
                Ht(function() {
                    h.ka === 3 && (h.ka = 0),
                    p != null && p === h.ja && (h.ja[o("7fd3ed9d70d1")](),
                    h.ja = null)
                }, 3e3),
                h.$i())
            }
            ,
            h.Ij = function() {
                return h.ka = 1,
                h.be.Yg(),
                h.Vb = {},
                h.xb = {},
                h.W.Zg(),
                h.ja != null && (h.ja[o("fd8d13dff297")](),
                h.ja = null),
                !0
            }
            ,
            h.xg = async function() {
                try {
                    (await (await ve[o("6530826c8a32")](o("b90f09aa5c5ed6d5f3742f9b225fa9ddfb7c") + k["1ak"])).json())[o("b78bd64e5e")] === 201 && ve.location.reload()
                } catch {}
                h.ja = null,
                h.be.Yg(),
                h.ka !== 3 && h.Vi(),
                h.ka = 0
            }
            ,
            h.bk = function(p, _, g, v, P, w, R) {
                h.zi(p, function() {
                    var G = Math.min(2048, _.length)
                      , C = new T.oh(17 + 2 * G)
                      , X = new T.ah(new T.vf(C));
                    X.Sm(),
                    X.Eb(g),
                    X.Eb(v),
                    X.Eb(P),
                    X.Eb(w),
                    X.Eb(R),
                    X.vn(U.r ? k["1y"] : 0),
                    X.An(k["1ae"]);
                    for (var H = 0; H < G; H++)
                        X.Eb(_.charCodeAt(H));
                    h.Cg(C)
                })
            }
            ,
            h.eo = function(p, _, g) {
                h.zi(p, function() {
                    var v = Math.min(32, _.length)
                      , P = new T.oh(7 + 2 * v)
                      , w = new T.ah(new T.vf(P));
                    w.Yf(129),
                    w.Eb(2800),
                    w.Yf(0),
                    w.Eb(g),
                    w.Yf(v);
                    for (var R = 0; R < v; R++)
                        w.Eb(_.charCodeAt(R));
                    h.Cg(P)
                })
            }
            ,
            h.Cg = function(p) {
                try {
                    h.ja != null && h.ja.readyState === WebSocket.OPEN && h.ja.send(p)
                } catch {
                    h.xg()
                }
            }
            ,
            h.fr = function(p, _) {
                p = z.Il(p) / 6.283185307179586 * 256 & 255,
                _ = U.Ff << 1 | _ << 0,
                U.Ff && (U.Ff = !1),
                h.Wi === p && h.vi == _ || (h.Cg(new Uint8Array([p, _]).buffer),
                h.Wi = p,
                h.vi = _)
            }
            ,
            h.zi = function(p, _) {
                var g = h.ja = new WebSocket(p);
                g[o("feeda9ff6361bd417fe7ad")] = o("0f2163f0f23df7f3712e7cf8"),
                g[o("a8168494dc9880")] = function() {
                    for (var v in U.cf = !0,
                    U.wb)
                        F.w.g.v.D.t.removeChild(U.wb[v]),
                        delete U.wb[v];
                    h.ja === g && _()
                }
                ,
                g[o("043a28b464b6393e")] = function() {
                    U.cf = !1,
                    h.ja === g && h.xg()
                }
                ,
                g[o("3a2492284cbd6fa3")] = function() {
                    U.cf = !1,
                    h.ja === g && h.xg()
                }
                ,
                g[o("46b866b42f287f3c29ba")] = function(v) {
                    h.ja === g && h.be.tj(v.data)
                }
            }
            ,
            h
        }
        ,
        W(ve, o("33875a48c38dc15e5689535b"), function(h) {
            return h.preventDefault(),
            h.stopPropagation(),
            !1
        }),
        F.w = z.sm(),
        await F.w.m(),
        (function h() {
            requestAnimationFrame(h),
            F.w.Ha()
        }
        )()
    });
}
)();
